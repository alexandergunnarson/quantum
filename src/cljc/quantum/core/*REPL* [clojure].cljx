> 
test=> (conjl (list 1 2 3) 3)
IllegalArgumentException No implementation of method: :conjl- of protocol: #'quantum.core.collections.core/CollMod found for class: clojure.lang.PersistentList  clojure.core/-cache-protocol-fn (core_deftype.clj:554)
test=> (refresh)
:reloading (quantum.core.type quantum.core.collections quantum.core.print quantum.core.collections.core)
Reflection warning, quantum/core/type.cljc:63:26 - reference to field isArray can't be resolved.
Boxed math warning, quantum/core/collections/core.cljc:148:55 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:166:35 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:167:35 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:168:49 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_minus(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:168:44 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:270:7 - call: public static boolean clojure.lang.Numbers.gt(long,java.lang.Object).
Reflection warning, quantum/core/collections/core.cljc:305:40 - call to method indexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
Reflection warning, quantum/core/collections/core.cljc:306:40 - call to method lastIndexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
Reflection warning, quantum/core/collections/core.cljc:305:40 - call to method indexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
Reflection warning, quantum/core/collections/core.cljc:306:40 - call to method lastIndexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
Boxed math warning, quantum/core/collections.cljc:241:15 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:287:3 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:293:26 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:300:7 - call: public static boolean clojure.lang.Numbers.gt(long,java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:302:9 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:309:7 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:322:7 - call: public static boolean clojure.lang.Numbers.gt(long,java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:324:9 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:331:7 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:366:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:401:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:423:15 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_minus(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:470:3 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:658:24 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:776:20 - call: public static boolean clojure.lang.Numbers.gt(java.lang.Object,long).
Boxed math warning, quantum/core/collections.cljc:839:28 - call: public static java.lang.Number clojure.lang.Numbers.divide(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:840:16 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:901:33 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:901:33 - call: public static boolean clojure.lang.Numbers.lt(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:909:35 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:1044:33 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Reflection warning, quantum/core/collections.cljc:1191:14 - call to method put on java.util.HashMap can't be resolved (no such method).
Boxed math warning, quantum/core/collections.cljc:1401:25 - call: public static boolean clojure.lang.Numbers.lt(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:148:55 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:166:35 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:167:35 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:168:49 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_minus(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:168:44 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:270:7 - call: public static boolean clojure.lang.Numbers.gt(long,java.lang.Object).
Reflection warning, quantum/core/collections/core.cljc:305:40 - call to method indexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
Reflection warning, quantum/core/collections/core.cljc:306:40 - call to method lastIndexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
Reflection warning, quantum/core/collections/core.cljc:305:40 - call to method indexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
Reflection warning, quantum/core/collections/core.cljc:306:40 - call to method lastIndexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
:ok
test=> (conjl (list 1 2 3) 3)
IllegalArgumentException No implementation of method: :conjl- of protocol: #'quantum.core.collections.core/CollMod found for class: clojure.lang.PersistentList  clojure.core/-cache-protocol-fn (core_deftype.clj:554)
test=> 
test=> (ns
  ^{:doc "Retakes on core collections functions like first, rest,
          get, nth, last, index-of, etc.

          Also includes innovative functions like getr, etc."}
  quantum.core.collections.core
  #?(:clj (:refer-clojure :exclude [vector hash-map]))
  (:require
    [quantum.core.error
      #?@(:clj [:refer [try+ throw+]])]
    [quantum.core.function :as fn :refer
      #?@(:clj  [[compr f*n fn* unary firsta rfn fn->> fn-> <-]]
          :cljs [[compr f*n fn* unary firsta]
                 :refer-macros
                 [fn->> fn-> <-]])]
    [quantum.core.logic :as log :refer
      #?@(:clj  [[splice-or fn-and fn-or fn-not ifn if*n whenc whenf whenf*n whencf*n
                  condf condfc condf*n nnil? nempty?]]
          :cljs [[splice-or fn-and fn-or fn-not nnil? nempty?]
                 :refer-macros
                 [ifn if*n whenc whenf whenf*n whencf*n condf condfc condf*n]])]
    [quantum.core.ns :as ns :refer
      #?(:clj  [alias-ns defalias]
         :cljs [Exception IllegalArgumentException
                Nil Bool Num ExactNum Int Decimal Key Vec Set
                ArrList TreeMap LSeq Regex Editable Transient Queue Map])]
    [quantum.core.reducers :as red :refer
      #?@(:clj  [[map+ reduce+ filter+ remove+ take+ take-while+ taker+ dropr+
                  count* fold+ range+ drop+ for+]]
          :cljs [[map+ reduce+ filter+ remove+ take+ take-while+
                  fold+ range+ drop+]
                 :refer-macros [for+]])]
    [quantum.core.string :as str]
    [quantum.core.data.set :as set]
    [quantum.core.type     :as type :refer
      [#?(:clj bigint?) #?(:cljs class) instance+? array-list? boolean? double? map-entry?
       sorted-map? queue? lseq? coll+? pattern? regex? editable?
       transient? #?(:clj should-transientize?) name-from-class #?(:clj arr-types)]
      #?@(:cljs [:refer-macros [should-transientize?]])]
    [quantum.core.data.vector :as vec :refer
      [subvec+ catvec vector+]]
    [quantum.core.macros
      #?(:clj  :refer
         :cljs :refer-macros)
      [extend-protocol-type extend-protocol-types extend-protocol-for-all]]
    #?(:clj [clj-tuple :as tup]))
  #?@(:clj
      [(:import
        clojure.core.Vec
        java.util.ArrayList clojure.lang.Keyword
        (quantum.core.ns
          Nil Bool Num ExactNum Int Decimal Key Set
                 ArrList TreeMap LSeq Regex Editable Transient Queue Map))
       (:gen-class)]))

#?(:clj (ns/require-all *ns* :clj))

; TODO Queues need support

; TODO need to somehow incorporate |vector++| and |vector+|
; #+clj (defalias vector   tup/vector)
; #+clj (defalias hash-map tup/hash-map)

(defn lasti
  "Last index of a coll."
  [coll]
  (-> coll count dec))

(defprotocol
  CollCount
  (count+ [coll]))

(extend-protocol CollCount
  nil
    (count+ [coll] 0)
  #?(:clj  Object
     :cljs default)
    (count+ [coll] (count coll)))

#?(:clj 
  (defmacro extend-coll-count-for-type
    "With helpful hints from:
    http://www.learningclojure.com/2010/09/macros-and-type-hints-metadata-and.html"
    [type-key]
    (let [coll (with-meta (gensym) {:tag (-> type-key name (str "s"))})]
     `(extend-protocol CollCount (get ~arr-types ~type-key)
        (count+ [~coll]
          (alength ~coll))))))

#?(:clj 
  (defmacro extend-coll-count-to-all-arr! []
    (reduce-kv
      (fn [ret type type-class]
        ;(println type)
        (eval `(extend-coll-count-for-type ~type)))
      nil arr-types)))

#?(:clj (extend-coll-count-to-all-arr!))
;___________________________________________________________________________________________________________________________________
;=================================================={         RETRIEVAL        }=====================================================
;=================================================={     get, first, rest     }=====================================================
(defprotocol CollRetrieve
  (getr+    [coll a] [coll a b] "Get range")
  (get+     [coll n] [coll n if-not-found])
  (first+   [coll])
  (second+  [coll])
  (rest+    [coll])
  (butlast+ [coll])
  (last+    [coll])) 

#?(:clj
  (defmacro extend-coll-retrieve-for-type
    [type-key]
    (let [coll (with-meta (gensym) {:tag (-> type-key name (str "s"))})]
     `(extend-protocol CollRetrieve (get ~arr-types ~type-key)
        (get+
          ([~coll n#]  (get+ ~coll n# nil))
          ([~coll n# if-not-found#]
            (try (aget ~coll n#)
              (catch ArrayIndexOutOfBoundsException e# if-not-found#))))
        (first+  [~coll]  (aget ~coll 0))
        (second+ [~coll]  (aget ~coll 1))
        (last+   [~coll]  (aget ~coll (-> ~coll alength dec)))))))

#?(:clj
  (defmacro extend-coll-retrieve-to-all-arr! []
    (reduce-kv
      (fn [ret type type-class]
        ;(println type)
        (eval `(extend-coll-retrieve-for-type ~type)))
      nil arr-types)))

#?(:clj
  (extend-coll-retrieve-to-all-arr!))

; take-up-to (combination of getr and index-of + 1)

#?(:clj ; TODO: port to cljs for Arrays and ArrayLists
  (extend-protocol CollRetrieve ArrayList
    (getr+ [^ArrayList coll a b] (.subList ^ArrayList coll a b))
    (get+
      ([^ArrayList coll n]  (get+ ^ArrayList coll n nil))
      ([^ArrayList coll n if-not-found]
        (try (.get ^ArrayList coll n)
          (catch ArrayIndexOutOfBoundsException e# if-not-found))))
    (first+  [^ArrayList coll]  (get+ ^ArrayList coll 0))
    (second+ [^ArrayList coll]  (get+ ^ArrayList coll 1))
    (last+   [^ArrayList coll]  (get+ ^ArrayList coll (-> coll count+ dec)))))
; extend first+ to use /first/ when the object is unknown.
; first+ with non-collection items (java.util.Collection) will return itself.

(extend-protocol CollRetrieve
  Keyword
    (rest+ [k]
      (rest+ (name k)))
  #?(:clj String :cljs string)
    (first+   [coll]
      (try (subs coll 0 1)
        #?(:clj (catch StringIndexOutOfBoundsException _ nil))))
    (second+  [coll]
      (try (subs coll 1 2)
        #?(:clj (catch StringIndexOutOfBoundsException _ nil))))
    (rest+    [coll]
      (try (subs coll 1 (count+ coll))
        #?(:clj (catch StringIndexOutOfBoundsException _ nil))))
    (butlast+ [coll] (subs coll 0 (-> coll count+ dec)))
    (last+    [coll] (subs coll   (-> coll count+ dec)))
    (getr+    [coll a b] (str/subs+ coll a (inc (- b a))))) ; now inclusive range with |inc|; this could break lots of things

#?(:clj
(extend-protocol-for-all CollRetrieve
  [#?@(:clj  [clojure.core.protocols.CollReduce
              quantum.core.reducers.Folder]
       )]
          (getr+    [coll a b] (->> coll (take+ b) (drop+ a)))
          (first+   [coll]     (take+ 1 coll))
          (rest+    [coll]     (drop+ 1 coll))
  #?(:clj (butlast+ [coll]     (dropr+ 1 coll)))
  #?(:clj (last+    [coll]     (taker+ 1 coll)))))

; TODO FIX
; (extend-protocol-for-all CollRetrieve
;   [cljs.core.Delay]
;           (getr+    [coll a b] (->> coll (take+ b) (drop+ a)))
;           (first+   [coll]     (take+ 1 coll))
;           (rest+    [coll]     (drop+ 1 coll))
;   #?(:clj (butlast+ [coll]     (dropr+ 1 coll)))
;   #?(:clj (last+    [coll]     (taker+ 1 coll))))

; ===== REDUCERS =====

#?(:cljs
  (extend-protocol CollRetrieve
    cljs.core/Delay
      (getr+          [coll a b] (->> coll (take+ b) (drop+ a)))
      (first+         [coll]     (take+ 1 coll))
      (rest+          [coll]     (drop+ 1 coll))))
; _____________________________________________________________________________________
; ====================================== VECTOR =======================================
; `````````````````````````````````````````````````````````````````````````````````````
; TODO THIS IS CLJS COMPATIBLE
#?(:clj
(doseq  [type (:vec type/types)]
  (extend type CollRetrieve
    {:getr+
      (fn ([coll a b] (subvec+ coll a b))
          ([coll a]   (subvec+ coll a (-> coll count))))
    :first+   (fn [coll] (get coll 0)) ; perhaps implement in terms of |reduce|?
    :second+  (fn [coll] (get coll 1))
    :rest+    (fn [coll] (subvec+ coll 1 (count coll)))
    :butlast+ (fn [coll] (whenf coll nempty? pop))
    :last+    (fn [coll] (peek coll))
    :get+
      (fn ([coll n]              (get+ coll n nil))
          ([coll n if-not-found] (get coll n if-not-found)))})))
; _____________________________________________________________________________________
; ======================================== MAP ========================================
; `````````````````````````````````````````````````````````````````````````````````````
; TODO make more efficient
; TODO This is CLJS compatible
#?(:clj
(doseq [type (:map type/types)]
  (extend type CollRetrieve
    {:get+
      (fn
        ([coll n]              (get+ coll n nil))
        ([coll n if-not-found] (get coll n if-not-found)))})))
; _____________________________________________________________________________________
; ==================================== COLLECTION =====================================
; `````````````````````````````````````````````````````````````````````````````````````
; TODO this is CLJS compatible
#?(:clj
(doseq #?(:clj  [type [clojure.lang.IPersistentCollection]]
          :cljs [type (set/union (:iseq type/types) (:set type/types))])
  (extend type CollRetrieve
    {:getr+
      (fn ([coll a]   (->> coll (drop a)))
          ([coll a b] (->> coll (take b) (drop a))))
    :first+   (fn [coll] (nth     coll 0) ) ; perhaps implement in terms of |reduce|?
    :second+  (fn [coll] (get     coll 1))
    :rest+    (fn [coll] (rest    coll))
    :butlast+ (fn [coll] (butlast coll))
    :last+    (fn [coll] (last    coll))
    :get+
      (fn ([coll n]              (get+ coll n nil))
          ([coll n if-not-found] (nth coll n if-not-found)))})))

#?(:cljs
  (extend-protocol CollRetrieve
    cljs.core/EmptyList
      (first+   [coll] nil)))

(extend-protocol CollRetrieve
  ; sorted-map or sorted-set getr+ like subseq
 #?(:clj  Object ; "default"
    :cljs default)
    (get+
      ([obj n]              (get+ obj n nil))
      ([obj n if-not-found] (get obj n)))
    (first+   [obj] obj)
    (last+    [obj] obj)
    (butlast+ [obj] obj)
  nil
    (get+     [obj n] obj)
    (first+   [obj]   obj)
    (last+    [obj]   obj)
    (butlast+ [obj]   obj))

(defn gets+ [coll & indices]
  (if (should-transientize? indices)
      (persistent!
        (reduce
          (fn [ret ind] (conj! ret (get+ coll ind)))
          (transient [])
          indices))
      (reduce
        (fn [ret ind] (conj ret (get+ coll ind)))
        []
        indices)))

(def  pop+  butlast+)
(def  popr+ butlast+)
(def  popl+ rest+)
(def  peek+ last+)

(defn getf+ [n] (f*n get+ n))
;___________________________________________________________________________________________________________________________________
;=================================================={        SEARCH/FIND       }=====================================================
;=================================================={    index-of, contains?   }=====================================================
(defprotocol CollSearch
  (index-of+      [coll elem])
  (last-index-of+ [coll elem]))

#?(:clj
(defmacro extend1 [type0 protocol0 fn-map]
 `(doseq [[f-key# f#] ~fn-map]
    (let [f-name# (-> f-key# name symbol)]
      (extend-protocol ~protocol0
        ~type0 (f-name# (rest 'f#)))))))

; TODO implement more...
#?(:clj
  (doseq [type (:vec type/types)]
    (extend type CollSearch
      {:index-of+      (fn [coll elem] (.indexOf     ^clojure.lang.IPersistentVector coll elem))
       :last-index-of+ (fn [coll elem] (.lastIndexOf ^clojure.lang.IPersistentVector coll elem))})))

(extend-protocol CollSearch
  #?(:clj String :cljs string)
    (index-of+      [coll elem] (.indexOf     ^String coll ^String elem))
    (last-index-of+ [coll elem] (.lastIndexOf ^String coll ^String elem)))

(defn third [coll] (-> coll rest+ rest+ first+))

;___________________________________________________________________________________________________________________________________
;=================================================={           MODIFY         }=====================================================
;=================================================={    conjl, conjr, etc.    }=====================================================
; TODO This is a mess and needs to be "hygienized" by macros
; that determine clj variadic support vs. cljs non, and act accordingly. Also multiple arity builder  
; Variadic protocols aren't supported by CLJS
(defprotocol CollMod
  (conjl-
    #?@(:clj  ([coll arg] [coll arg & args])
       :cljs ([coll args])))
  (conjr-
    #?@(:clj  ([coll arg] [coll arg & args])
       :cljs ([coll args]))))

;--------------------------------------------------{           CONJL          }-----------------------------------------------------
(defn- conjl-list
  {:todo ["Add var-args"]}
  ([coll a]           (->> coll (cons a)                                             ))
  ([coll a b]         (->> coll (cons b) (cons a)                                    ))
  ([coll a b c]       (->> coll (cons c) (cons b) (cons a)                           ))
  ([coll a b c d]     (->> coll (cons d) (cons c) (cons b) (cons a)                  ))
  ([coll a b c d e]   (->> coll (cons e) (cons d) (cons c) (cons b) (cons a)         ))
  ([coll a b c d e f] (->> coll (cons f) (cons e) (cons d) (cons c) (cons b) (cons a))))

; TODO CLJS compatible
#?(:clj
(doseq [type (:iseq type/types)]
  (extend type CollMod
    {:conjl-
     #?(:clj  conjl-list
        :cljs (fn [coll args] (apply conjl-list coll args)))})))

(defn- conjl-vec
  ([coll a]                  (catvec (vector+ a          ) coll))
  ([coll a b]                (catvec (vector+ a b        ) coll))
  ([coll a b c]              (catvec (vector+ a b c      ) coll))
  ([coll a b c d]            (catvec (vector+ a b c d    ) coll))
  ([coll a b c d e]          (catvec (vector+ a b c d e  ) coll))
  ([coll a b c d e f]        (catvec (vector+ a b c d e f) coll))
  ([coll a b c d e f & args] (catvec (apply vector+ args ) coll)))

; TODO CLJS compatible
#?(:clj
(doseq [type (:vec type/types)]
  (extend type CollMod
    {:conjl-
     #?(:clj  conjl-vec
        :cljs (fn [coll args] (apply conjl-vec coll args)))})))

;--------------------------------------------------{           CONJR          }-----------------------------------------------------
; TODO CLJS compatible
#?(:clj
(doseq [type (:vec type/types)]
  (extend type CollMod
    {:conjr-
     #?(:clj  conj
        :cljs (fn [coll args] (apply conj coll args)))})))

; TODO CLJS compatible
#?(:clj
(doseq [type (:iseq type/types)]
  (extend type CollMod
    {:conjr-
      #?(:clj
           (fn ([coll arg]        (concat coll (list arg)))
               ([coll arg & args] (concat coll (cons arg args))))
         :cljs
           (fn [coll args] (concat coll args)))})))

; TODO: conjl with cons or conj, etc.


; TODO add arity
(def conjl #?(:clj conjl- :cljs (fn [coll & args] (conjr- coll args))))
(def conjr #?(:clj conjr- :cljs (fn [coll & args] (conjl- coll args))))

(def doto! swap!)

; If the array is not sorted:
; java.util.Arrays.asList(theArray).indexOf(o)
; If the array is sorted, you can make use of a binary search for performance:
; java.util.Arrays.binarySearch(theArray, o)




nil
quantum.core.collections.core=> quantum.core.collections.core=> flatland.ordered.map.OrderedMap
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> #'quantum.core.collections.core/lasti
quantum.core.collections.core=> quantum.core.collections.core=> CollCount
quantum.core.collections.core=> quantum.core.collections.core=> nil
quantum.core.collections.core=> quantum.core.collections.core=> #'quantum.core.collections.core/extend-coll-count-for-type
quantum.core.collections.core=> quantum.core.collections.core=> #'quantum.core.collections.core/extend-coll-count-to-all-arr!
quantum.core.collections.core=> quantum.core.collections.core=> nil
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> CollRetrieve
quantum.core.collections.core=> quantum.core.collections.core=> #'quantum.core.collections.core/extend-coll-retrieve-for-type
quantum.core.collections.core=> quantum.core.collections.core=> #'quantum.core.collections.core/extend-coll-retrieve-to-all-arr!
quantum.core.collections.core=> quantum.core.collections.core=> nil
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:4111:55 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
nil
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:4129:35 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:4130:35 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:4131:49 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_minus(java.lang.Object,java.lang.Object).
Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:4131:44 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
nil
quantum.core.collections.core=> quantum.core.collections.core=> nil
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> nil
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> nil
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> nil
quantum.core.collections.core=> quantum.core.collections.core=> nil
quantum.core.collections.core=> quantum.core.collections.core=> Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:4233:7 - call: public static boolean clojure.lang.Numbers.gt(long,java.lang.Object).
#'quantum.core.collections.core/gets+
quantum.core.collections.core=> quantum.core.collections.core=> #'quantum.core.collections.core/pop+
quantum.core.collections.core=> #'quantum.core.collections.core/popr+
quantum.core.collections.core=> #'quantum.core.collections.core/popl+
quantum.core.collections.core=> #'quantum.core.collections.core/peek+
quantum.core.collections.core=> quantum.core.collections.core=> #'quantum.core.collections.core/getf+
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> CollSearch
quantum.core.collections.core=> quantum.core.collections.core=> #'quantum.core.collections.core/extend1
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> Reflection warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:4268:40 - call to method indexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
Reflection warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:4269:40 - call to method lastIndexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
Reflection warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:4268:40 - call to method indexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
Reflection warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:4269:40 - call to method lastIndexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
nil
quantum.core.collections.core=> quantum.core.collections.core=> nil
quantum.core.collections.core=> quantum.core.collections.core=> #'quantum.core.collections.core/third
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> CollMod
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> #'quantum.core.collections.core/conjl-list
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> nil
quantum.core.collections.core=> quantum.core.collections.core=> #'quantum.core.collections.core/conjl-vec
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> nil
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> nil
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> nil
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> #'quantum.core.collections.core/conjl
quantum.core.collections.core=> #'quantum.core.collections.core/conjr
quantum.core.collections.core=> quantum.core.collections.core=> #'quantum.core.collections.core/doto!
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> (conjl (list 1 2 3) 3)
IllegalArgumentException No implementation of method: :conjl- of protocol: #'quantum.core.collections.core/CollMod found for class: clojure.lang.PersistentList  clojure.core/-cache-protocol-fn (core_deftype.clj:554)
quantum.core.collections.core=> 
quantum.core.collections.core=> 
quantum.core.collections.core=> (conjl (list 1 2 3) 3 3)
ArityException Wrong number of args (3) passed to: core/eval46167/fn--46168/G--46156--46183  clojure.lang.AFn.throwArity (AFn.java:429)
quantum.core.collections.core=> (conjl (list 1 2 3) 3)
IllegalArgumentException No implementation of method: :conjl- of protocol: #'quantum.core.collections.core/CollMod found for class: clojure.lang.PersistentList  clojure.core/-cache-protocol-fn (core_deftype.clj:554)
quantum.core.collections.core=> (conjl- (list 1 2 3) 3)
IllegalArgumentException No implementation of method: :conjl- of protocol: #'quantum.core.collections.core/CollMod found for class: clojure.lang.PersistentList  clojure.core/-cache-protocol-fn (core_deftype.clj:554)
quantum.core.collections.core=> (conjl- (list 1 2 3) 3 3)
CompilerException java.lang.IllegalArgumentException: No single method: conjl_ of interface: quantum.core.collections.core.CollMod found for function: conjl- of protocol: CollMod, compiling:(/private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:4370:1) 
quantum.core.collections.core=> 
quantum.core.collections.core=> (ns
  ^{:doc "Retakes on core collections functions like first, rest,
          get, nth, last, index-of, etc.

          Also includes innovative functions like getr, etc."}
  quantum.core.collections.core
  #?(:clj (:refer-clojure :exclude [vector hash-map]))
  (:require
    [quantum.core.error
      #?@(:clj [:refer [try+ throw+]])]
    [quantum.core.function :as fn :refer
      #?@(:clj  [[compr f*n fn* unary firsta rfn fn->> fn-> <-]]
          :cljs [[compr f*n fn* unary firsta]
                 :refer-macros
                 [fn->> fn-> <-]])]
    [quantum.core.logic :as log :refer
      #?@(:clj  [[splice-or fn-and fn-or fn-not ifn if*n whenc whenf whenf*n whencf*n
                  condf condfc condf*n nnil? nempty?]]
          :cljs [[splice-or fn-and fn-or fn-not nnil? nempty?]
                 :refer-macros
                 [ifn if*n whenc whenf whenf*n whencf*n condf condfc condf*n]])]
    [quantum.core.ns :as ns :refer
      #?(:clj  [alias-ns defalias]
         :cljs [Exception IllegalArgumentException
                Nil Bool Num ExactNum Int Decimal Key Vec Set
                ArrList TreeMap LSeq Regex Editable Transient Queue Map])]
    [quantum.core.reducers :as red :refer
      #?@(:clj  [[map+ reduce+ filter+ remove+ take+ take-while+ taker+ dropr+
                  count* fold+ range+ drop+ for+]]
          :cljs [[map+ reduce+ filter+ remove+ take+ take-while+
                  fold+ range+ drop+]
                 :refer-macros [for+]])]
    [quantum.core.string :as str]
    [quantum.core.data.set :as set]
    [quantum.core.type     :as type :refer
      [#?(:clj bigint?) #?(:cljs class) instance+? array-list? boolean? double? map-entry?
       sorted-map? queue? lseq? coll+? pattern? regex? editable?
       transient? #?(:clj should-transientize?) name-from-class #?(:clj arr-types)]
      #?@(:cljs [:refer-macros [should-transientize?]])]
    [quantum.core.data.vector :as vec :refer
      [subvec+ catvec vector+]]
    [quantum.core.macros
      #?(:clj  :refer
         :cljs :refer-macros)
      [extend-protocol-type extend-protocol-types extend-protocol-for-all]]
    #?(:clj [clj-tuple :as tup]))
  #?@(:clj
      [(:import
        clojure.core.Vec
        java.util.ArrayList clojure.lang.Keyword
        (quantum.core.ns
          Nil Bool Num ExactNum Int Decimal Key Set
                 ArrList TreeMap LSeq Regex Editable Transient Queue Map))
       (:gen-class)]))

#?(:clj (ns/require-all *ns* :clj))

; TODO Queues need support

; TODO need to somehow incorporate |vector++| and |vector+|
; #+clj (defalias vector   tup/vector)
; #+clj (defalias hash-map tup/hash-map)

(defn lasti
  "Last index of a coll."
  [coll]
  (-> coll count dec))

(defprotocol
  CollCount
  (count+ [coll]))

(extend-protocol CollCount
  nil
    (count+ [coll] 0)
  #?(:clj  Object
     :cljs default)
    (count+ [coll] (count coll)))

#?(:clj 
  (defmacro extend-coll-count-for-type
    "With helpful hints from:
    http://www.learningclojure.com/2010/09/macros-and-type-hints-metadata-and.html"
    [type-key]
    (let [coll (with-meta (gensym) {:tag (-> type-key name (str "s"))})]
     `(extend-protocol CollCount (get ~arr-types ~type-key)
        (count+ [~coll]
          (alength ~coll))))))

#?(:clj 
  (defmacro extend-coll-count-to-all-arr! []
    (reduce-kv
      (fn [ret type type-class]
        ;(println type)
        (eval `(extend-coll-count-for-type ~type)))
      nil arr-types)))

#?(:clj (extend-coll-count-to-all-arr!))
;___________________________________________________________________________________________________________________________________
;=================================================={         RETRIEVAL        }=====================================================
;=================================================={     get, first, rest     }=====================================================
(defprotocol CollRetrieve
  (getr+    [coll a] [coll a b] "Get range")
  (get+     [coll n] [coll n if-not-found])
  (first+   [coll])
  (second+  [coll])
  (rest+    [coll])
  (butlast+ [coll])
  (last+    [coll])) 

#?(:clj
  (defmacro extend-coll-retrieve-for-type
    [type-key]
    (let [coll (with-meta (gensym) {:tag (-> type-key name (str "s"))})]
     `(extend-protocol CollRetrieve (get ~arr-types ~type-key)
        (get+
          ([~coll n#]  (get+ ~coll n# nil))
          ([~coll n# if-not-found#]
            (try (aget ~coll n#)
              (catch ArrayIndexOutOfBoundsException e# if-not-found#))))
        (first+  [~coll]  (aget ~coll 0))
        (second+ [~coll]  (aget ~coll 1))
        (last+   [~coll]  (aget ~coll (-> ~coll alength dec)))))))

#?(:clj
  (defmacro extend-coll-retrieve-to-all-arr! []
    (reduce-kv
      (fn [ret type type-class]
        ;(println type)
        (eval `(extend-coll-retrieve-for-type ~type)))
      nil arr-types)))

#?(:clj
  (extend-coll-retrieve-to-all-arr!))

; take-up-to (combination of getr and index-of + 1)

#?(:clj ; TODO: port to cljs for Arrays and ArrayLists
  (extend-protocol CollRetrieve ArrayList
    (getr+ [^ArrayList coll a b] (.subList ^ArrayList coll a b))
    (get+
      ([^ArrayList coll n]  (get+ ^ArrayList coll n nil))
      ([^ArrayList coll n if-not-found]
        (try (.get ^ArrayList coll n)
          (catch ArrayIndexOutOfBoundsException e# if-not-found))))
    (first+  [^ArrayList coll]  (get+ ^ArrayList coll 0))
    (second+ [^ArrayList coll]  (get+ ^ArrayList coll 1))
    (last+   [^ArrayList coll]  (get+ ^ArrayList coll (-> coll count+ dec)))))
; extend first+ to use /first/ when the object is unknown.
; first+ with non-collection items (java.util.Collection) will return itself.

(extend-protocol CollRetrieve
  Keyword
    (rest+ [k]
      (rest+ (name k)))
  #?(:clj String :cljs string)
    (first+   [coll]
      (try (subs coll 0 1)
        #?(:clj (catch StringIndexOutOfBoundsException _ nil))))
    (second+  [coll]
      (try (subs coll 1 2)
        #?(:clj (catch StringIndexOutOfBoundsException _ nil))))
    (rest+    [coll]
      (try (subs coll 1 (count+ coll))
        #?(:clj (catch StringIndexOutOfBoundsException _ nil))))
    (butlast+ [coll] (subs coll 0 (-> coll count+ dec)))
    (last+    [coll] (subs coll   (-> coll count+ dec)))
    (getr+    [coll a b] (str/subs+ coll a (inc (- b a))))) ; now inclusive range with |inc|; this could break lots of things

#?(:clj
(extend-protocol-for-all CollRetrieve
  [#?@(:clj  [clojure.core.protocols.CollReduce
              quantum.core.reducers.Folder]
       )]
          (getr+    [coll a b] (->> coll (take+ b) (drop+ a)))
          (first+   [coll]     (take+ 1 coll))
          (rest+    [coll]     (drop+ 1 coll))
  #?(:clj (butlast+ [coll]     (dropr+ 1 coll)))
  #?(:clj (last+    [coll]     (taker+ 1 coll)))))

; TODO FIX
; (extend-protocol-for-all CollRetrieve
;   [cljs.core.Delay]
;           (getr+    [coll a b] (->> coll (take+ b) (drop+ a)))
;           (first+   [coll]     (take+ 1 coll))
;           (rest+    [coll]     (drop+ 1 coll))
;   #?(:clj (butlast+ [coll]     (dropr+ 1 coll)))
;   #?(:clj (last+    [coll]     (taker+ 1 coll))))

; ===== REDUCERS =====

#?(:cljs
  (extend-protocol CollRetrieve
    cljs.core/Delay
      (getr+          [coll a b] (->> coll (take+ b) (drop+ a)))
      (first+         [coll]     (take+ 1 coll))
      (rest+          [coll]     (drop+ 1 coll))))
; _____________________________________________________________________________________
; ====================================== VECTOR =======================================
; `````````````````````````````````````````````````````````````````````````````````````
; TODO THIS IS CLJS COMPATIBLE
#?(:clj
(doseq  [type (:vec type/types)]
  (extend type CollRetrieve
    {:getr+
      (fn ([coll a b] (subvec+ coll a b))
          ([coll a]   (subvec+ coll a (-> coll count))))
    :first+   (fn [coll] (get coll 0)) ; perhaps implement in terms of |reduce|?
    :second+  (fn [coll] (get coll 1))
    :rest+    (fn [coll] (subvec+ coll 1 (count coll)))
    :butlast+ (fn [coll] (whenf coll nempty? pop))
    :last+    (fn [coll] (peek coll))
    :get+
      (fn ([coll n]              (get+ coll n nil))
          ([coll n if-not-found] (get coll n if-not-found)))})))
; _____________________________________________________________________________________
; ======================================== MAP ========================================
; `````````````````````````````````````````````````````````````````````````````````````
; TODO make more efficient
; TODO This is CLJS compatible
#?(:clj
(doseq [type (:map type/types)]
  (extend type CollRetrieve
    {:get+
      (fn
        ([coll n]              (get+ coll n nil))
        ([coll n if-not-found] (get coll n if-not-found)))})))
; _____________________________________________________________________________________
; ==================================== COLLECTION =====================================
; `````````````````````````````````````````````````````````````````````````````````````
; TODO this is CLJS compatible
#?(:clj
(doseq #?(:clj  [type [clojure.lang.IPersistentCollection]]
          :cljs [type (set/union (:iseq type/types) (:set type/types))])
  (extend type CollRetrieve
    {:getr+
      (fn ([coll a]   (->> coll (drop a)))
          ([coll a b] (->> coll (take b) (drop a))))
    :first+   (fn [coll] (nth     coll 0) ) ; perhaps implement in terms of |reduce|?
    :second+  (fn [coll] (get     coll 1))
    :rest+    (fn [coll] (rest    coll))
    :butlast+ (fn [coll] (butlast coll))
    :last+    (fn [coll] (last    coll))
    :get+
      (fn ([coll n]              (get+ coll n nil))
          ([coll n if-not-found] (nth coll n if-not-found)))})))

#?(:cljs
  (extend-protocol CollRetrieve
    cljs.core/EmptyList
      (first+   [coll] nil)))

(extend-protocol CollRetrieve
  ; sorted-map or sorted-set getr+ like subseq
 #?(:clj  Object ; "default"
    :cljs default)
    (get+
      ([obj n]              (get+ obj n nil))
      ([obj n if-not-found] (get obj n)))
    (first+   [obj] obj)
    (last+    [obj] obj)
    (butlast+ [obj] obj)
  nil
    (get+     [obj n] obj)
    (first+   [obj]   obj)
    (last+    [obj]   obj)
    (butlast+ [obj]   obj))

(defn gets+ [coll & indices]
  (if (should-transientize? indices)
      (persistent!
        (reduce
          (fn [ret ind] (conj! ret (get+ coll ind)))
          (transient [])
          indices))
      (reduce
        (fn [ret ind] (conj ret (get+ coll ind)))
        []
        indices)))

(def  pop+  butlast+)
(def  popr+ butlast+)
(def  popl+ rest+)
(def  peek+ last+)

(defn getf+ [n] (f*n get+ n))
;___________________________________________________________________________________________________________________________________
;=================================================={        SEARCH/FIND       }=====================================================
;=================================================={    index-of, contains?   }=====================================================
(defprotocol CollSearch
  (index-of+      [coll elem])
  (last-index-of+ [coll elem]))

#?(:clj
(defmacro extend1 [type0 protocol0 fn-map]
 `(doseq [[f-key# f#] ~fn-map]
    (let [f-name# (-> f-key# name symbol)]
      (extend-protocol ~protocol0
        ~type0 (f-name# (rest 'f#)))))))

; TODO implement more...
#?(:clj
  (doseq [type (:vec type/types)]
    (extend type CollSearch
      {:index-of+      (fn [coll elem] (.indexOf     ^clojure.lang.IPersistentVector coll elem))
       :last-index-of+ (fn [coll elem] (.lastIndexOf ^clojure.lang.IPersistentVector coll elem))})))

(extend-protocol CollSearch
  #?(:clj String :cljs string)
    (index-of+      [coll elem] (.indexOf     ^String coll ^String elem))
    (last-index-of+ [coll elem] (.lastIndexOf ^String coll ^String elem)))

(defn third [coll] (-> coll rest+ rest+ first+))

;___________________________________________________________________________________________________________________________________
;=================================================={           MODIFY         }=====================================================
;=================================================={    conjl, conjr, etc.    }=====================================================
; TODO This is a mess and needs to be "hygienized" by macros
; that determine clj variadic support vs. cljs non, and act accordingly. Also multiple arity builder  
; Variadic protocols aren't supported by CLJS
(defprotocol CollMod
  (conjl-
    #?@(:clj ([coll a]
              [coll a b]
              [coll a b c]
              [coll a b c d] 
              [coll arg & args])
       :cljs ([coll args])))
  (conjr-
    #?@(:clj  ([coll arg] [coll arg & args])
       :cljs ([coll args]))))

;--------------------------------------------------{           CONJL          }-----------------------------------------------------
(defn- conjl-list
  {:todo ["Add var-args"]}
  ([coll a]           (->> coll (cons a)                                             ))
  ([coll a b]         (->> coll (cons b) (cons a)                                    ))
  ([coll a b c]       (->> coll (cons c) (cons b) (cons a)                           ))
  ([coll a b c d]     (->> coll (cons d) (cons c) (cons b) (cons a)                  ))
  ([coll a b c d e]   (->> coll (cons e) (cons d) (cons c) (cons b) (cons a)         ))
  ([coll a b c d e f] (->> coll (cons f) (cons e) (cons d) (cons c) (cons b) (cons a))))

; TODO CLJS compatible
#?(:clj
(doseq [type (:iseq type/types)]
  (extend type CollMod
    {:conjl-
     #?(:clj  conjl-list
        :cljs (fn [coll args] (apply conjl-list coll args)))})))

(defn- conjl-vec
  ([coll a]                  (catvec (vector+ a          ) coll))
  ([coll a b]                (catvec (vector+ a b        ) coll))
  ([coll a b c]              (catvec (vector+ a b c      ) coll))
  ([coll a b c d]            (catvec (vector+ a b c d    ) coll))
  ([coll a b c d e]          (catvec (vector+ a b c d e  ) coll))
  ([coll a b c d e f]        (catvec (vector+ a b c d e f) coll))
  ([coll a b c d e f & args] (catvec (apply vector+ args ) coll)))

; TODO CLJS compatible
#?(:clj
(doseq [type (:vec type/types)]
  (extend type CollMod
    {:conjl-
     #?(:clj  conjl-vec
        :cljs (fn [coll args] (apply conjl-vec coll args)))})))

;--------------------------------------------------{           CONJR          }-----------------------------------------------------
; TODO CLJS compatible
#?(:clj
(doseq [type (:vec type/types)]
  (extend type CollMod
    {:conjr-
     #?(:clj  conj
        :cljs (fn [coll args] (apply conj coll args)))})))

; TODO CLJS compatible
#?(:clj
(doseq [type (:iseq type/types)]
  (extend type CollMod
    {:conjr-
      #?(:clj
           (fn ([coll arg]        (concat coll (list arg)))
               ([coll arg & args] (concat coll (cons arg args))))
         :cljs
           (fn [coll args] (concat coll args)))})))

; TODO: conjl with cons or conj, etc.


; TODO add arity
(def conjl #?(:clj conjl- :cljs (fn [coll & args] (conjr- coll args))))
(def conjr #?(:clj conjr- :cljs (fn [coll & args] (conjl- coll args))))

(def doto! swap!)

; If the array is not sorted:
; java.util.Arrays.asList(theArray).indexOf(o)
; If the array is sorted, you can make use of a binary search for performance:
; java.util.Arrays.binarySearch(theArray, o)




nil
quantum.core.collections.core=> quantum.core.collections.core=> flatland.ordered.map.OrderedMap
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> #'quantum.core.collections.core/lasti
quantum.core.collections.core=> quantum.core.collections.core=> CollCount
quantum.core.collections.core=> quantum.core.collections.core=> nil
quantum.core.collections.core=> quantum.core.collections.core=> #'quantum.core.collections.core/extend-coll-count-for-type
quantum.core.collections.core=> quantum.core.collections.core=> #'quantum.core.collections.core/extend-coll-count-to-all-arr!
quantum.core.collections.core=> quantum.core.collections.core=> nil
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> CollRetrieve
quantum.core.collections.core=> quantum.core.collections.core=> #'quantum.core.collections.core/extend-coll-retrieve-for-type
quantum.core.collections.core=> quantum.core.collections.core=> #'quantum.core.collections.core/extend-coll-retrieve-to-all-arr!
quantum.core.collections.core=> quantum.core.collections.core=> nil
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:4519:55 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
nil
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:4537:35 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:4538:35 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:4539:49 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_minus(java.lang.Object,java.lang.Object).
Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:4539:44 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
nil
quantum.core.collections.core=> quantum.core.collections.core=> nil
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> nil
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> nil
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> nil
quantum.core.collections.core=> quantum.core.collections.core=> nil
quantum.core.collections.core=> quantum.core.collections.core=> Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:4641:7 - call: public static boolean clojure.lang.Numbers.gt(long,java.lang.Object).
#'quantum.core.collections.core/gets+
quantum.core.collections.core=> quantum.core.collections.core=> #'quantum.core.collections.core/pop+
quantum.core.collections.core=> #'quantum.core.collections.core/popr+
quantum.core.collections.core=> #'quantum.core.collections.core/popl+
quantum.core.collections.core=> #'quantum.core.collections.core/peek+
quantum.core.collections.core=> quantum.core.collections.core=> #'quantum.core.collections.core/getf+
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> CollSearch
quantum.core.collections.core=> quantum.core.collections.core=> #'quantum.core.collections.core/extend1
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> Reflection warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:4676:40 - call to method indexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
Reflection warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:4677:40 - call to method lastIndexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
Reflection warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:4676:40 - call to method indexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
Reflection warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:4677:40 - call to method lastIndexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
nil
quantum.core.collections.core=> quantum.core.collections.core=> nil
quantum.core.collections.core=> quantum.core.collections.core=> #'quantum.core.collections.core/third
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> CompilerException java.lang.ClassFormatError: Duplicate method name&signature in class file quantum/core/collections/core/CollMod, compiling:(form-init3623728042651227831.clj:4692:1) 
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> #'quantum.core.collections.core/conjl-list
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> nil
quantum.core.collections.core=> quantum.core.collections.core=> #'quantum.core.collections.core/conjl-vec
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> nil
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> nil
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> nil
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> #'quantum.core.collections.core/conjl
quantum.core.collections.core=> #'quantum.core.collections.core/conjr
quantum.core.collections.core=> quantum.core.collections.core=> #'quantum.core.collections.core/doto!
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> 
quantum.core.collections.core=> (conjl- (list 1 2 3) 3 3)
CompilerException java.lang.IllegalArgumentException: No single method: conjl_ of interface: quantum.core.collections.core.CollMod found for function: conjl- of protocol: CollMod, compiling:(/private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:4777:1) 
quantum.core.collections.core=> (conjl- (list 1 2 3) 3 3)
CompilerException java.lang.IllegalArgumentException: No single method: conjl_ of interface: quantum.core.collections.core.CollMod found for function: conjl- of protocol: CollMod, compiling:(/private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:4778:1) 
quantum.core.collections.core=> #?(:clj
(doseq [type (:iseq type/types)]
  (extend type CollMod
    {:conjl-
     #?(:clj  conjl-list
        :cljs (fn [coll args] (apply conjl-list coll args)))})))
nil
quantum.core.collections.core=> (conjl- (list 1 2 3) 3 3)
CompilerException java.lang.IllegalArgumentException: No single method: conjl_ of interface: quantum.core.collections.core.CollMod found for function: conjl- of protocol: CollMod, compiling:(/private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:4785:1) 
quantum.core.collections.core=> 
quantum.core.collections.core=> (extend-protocol-for-all CollMod
  [java.util.List]
  (conjl-
    ([coll a]           (->> coll (cons a)                                             ))
    ([coll a b]         (->> coll (cons b) (cons a)                                    ))
    ([coll a b c]       (->> coll (cons c) (cons b) (cons a)                           ))
    ([coll a b c d]     (->> coll (cons d) (cons c) (cons b) (cons a)                  ))
    ([coll a b c d e]   (->> coll (cons e) (cons d) (cons c) (cons b) (cons a)         ))
    ([coll a b c d e f] (->> coll (cons f) (cons e) (cons d) (cons c) (cons b) (cons a)))))

nil
quantum.core.collections.core=> quantum.core.collections.core=> (conjl- (list 1 2 3) 3 3)
CompilerException java.lang.IllegalArgumentException: No single method: conjl_ of interface: quantum.core.collections.core.CollMod found for function: conjl- of protocol: CollMod, compiling:(/private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:4797:1) 
quantum.core.collections.core=> 
quantum.core.collections.core=> (defprotocol CollMod
  (conjl-
    #?@(:clj ([coll a]
              [coll a b]
              [coll a b c]
              [coll a b c d] 
              [coll arg & args])
       :cljs ([coll args])))
  (conjr-
    #?@(:clj  ([coll arg] [coll arg & args])
       :cljs ([coll args]))))
CompilerException java.lang.ClassFormatError: Duplicate method name&signature in class file quantum/core/collections/core/CollMod, compiling:(form-init3623728042651227831.clj:4799:1) 
quantum.core.collections.core=> (defprotocol CollMod
  (conjl-
    #?@(:clj ([coll a]
              [coll a b]
              [coll a b c]
              [coll a b c d] 
              [coll a b c d e])
       :cljs ([coll args])))
  (conjr-
    #?@(:clj  ([coll arg] [coll arg & args])
       :cljs ([coll args]))))
CollMod
quantum.core.collections.core=> (conjl- (list 1 2 3) 3 3)
(3 3 1 2 3)
quantum.core.collections.core=> (conjl- (list 1 2 3) 4 5 6)
(4 5 6 1 2 3)
quantum.core.collections.core=> (conjl- (list 1 2 3) 4 5 6 7)
(4 5 6 7 1 2 3)
quantum.core.collections.core=> (conjl- (list 1 2 3) 4 5 6 7 8)
(4 5 6 7 8 1 2 3)
quantum.core.collections.core=> (conjl- (list 1 2 3) 4 5 6 7 8 9)
CompilerException java.lang.IllegalArgumentException: No single method: conjl_ of interface: quantum.core.collections.core.CollMod found for function: conjl- of protocol: CollMod, compiling:(/private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:4825:1) 
quantum.core.collections.core=> 
quantum.core.collections.core=> (:vec type/types)
#{clojure.lang.IPersistentVector}
quantum.core.collections.core=> (:vec type/types)
#{clojure.lang.IPersistentVector}
quantum.core.collections.core=> 
quantum.core.collections.core=> (ns
  ^{:doc "Retakes on core collections functions like first, rest,
          get, nth, last, index-of, etc.

          Also includes innovative functions like getr, etc."}
  quantum.core.collections.core
  #?(:clj (:refer-clojure :exclude [vector hash-map]))
  (:require
    [quantum.core.error
      #?@(:clj [:refer [try+ throw+]])]
    [quantum.core.function :as fn :refer
      #?@(:clj  [[compr f*n fn* unary firsta rfn fn->> fn-> <-]]
          :cljs [[compr f*n fn* unary firsta]
                 :refer-macros
                 [fn->> fn-> <-]])]
    [quantum.core.logic :as log :refer
      #?@(:clj  [[splice-or fn-and fn-or fn-not ifn if*n whenc whenf whenf*n whencf*n
                  condf condfc condf*n nnil? nempty?]]
          :cljs [[splice-or fn-and fn-or fn-not nnil? nempty?]
                 :refer-macros
                 [ifn if*n whenc whenf whenf*n whencf*n condf condfc condf*n]])]
    [quantum.core.ns :as ns :refer
      #?(:clj  [alias-ns defalias]
         :cljs [Exception IllegalArgumentException
                Nil Bool Num ExactNum Int Decimal Key Vec Set
                ArrList TreeMap LSeq Regex Editable Transient Queue Map])]
    [quantum.core.reducers :as red :refer
      #?@(:clj  [[map+ reduce+ filter+ remove+ take+ take-while+ taker+ dropr+
                  count* fold+ range+ drop+ for+]]
          :cljs [[map+ reduce+ filter+ remove+ take+ take-while+
                  fold+ range+ drop+]
                 :refer-macros [for+]])]
    [quantum.core.string :as str]
    [quantum.core.data.set :as set]
    [quantum.core.type     :as type :refer
      [#?(:clj bigint?) #?(:cljs class) instance+? array-list? boolean? double? map-entry?
       sorted-map? queue? lseq? coll+? pattern? regex? editable?
       transient? #?(:clj should-transientize?) name-from-class #?(:clj arr-types)]
      #?@(:cljs [:refer-macros [should-transientize?]])]
    [quantum.core.data.vector :as vec :refer
      [subvec+ catvec vector+]]
    [quantum.core.macros
      #?(:clj  :refer
         :cljs :refer-macros)
      [extend-protocol-type extend-protocol-types extend-protocol-for-all]]
    #?(:clj [clj-tuple :as tup]))
  #?@(:clj
      [(:import
        clojure.core.Vec
        java.util.ArrayList clojure.lang.Keyword
        (quantum.core.ns
          Nil Bool Num ExactNum Int Decimal Key Set
                 ArrList TreeMap LSeq Regex Editable Transient Queue Map))
       (:gen-class)]))

#?(:clj (ns/require-all *ns* :clj))

; TODO Queues need support

; TODO need to somehow incorporate |vector++| and |vector+|
; #+clj (defalias vector   tup/vector)
; #+clj (defalias hash-map tup/hash-map)

(defn lasti
  "Last index of a coll."
  [coll]
  (-> coll count dec))

(defprotocol
  CollCount
  (count+ [coll]))

(extend-protocol CollCount
  nil
    (count+ [coll] 0)
  #?(:clj  Object
     :cljs default)
    (count+ [coll] (count coll)))

#?(:clj 
  (defmacro extend-coll-count-for-type
    "With helpful hints from:
    http://www.learningclojure.com/2010/09/macros-and-type-hints-metadata-and.html"
    [type-key]
    (let [coll (with-meta (gensym) {:tag (-> type-key name (str "s"))})]
     `(extend-protocol CollCount (get ~arr-types ~type-key)
        (count+ [~coll]
          (alength ~coll))))))

#?(:clj 
  (defmacro extend-coll-count-to-all-arr! []
    (reduce-kv
      (fn [ret type type-class]
        ;(println type)
        (eval `(extend-coll-count-for-type ~type)))
      nil arr-types)))

#?(:clj (extend-coll-count-to-all-arr!))
;___________________________________________________________________________________________________________________________________
;=================================================={         RETRIEVAL        }=====================================================
;=================================================={     get, first, rest     }=====================================================
(defprotocol CollRetrieve
  (getr+    [coll a] [coll a b] "Get range")
  (get+     [coll n] [coll n if-not-found])
  (first+   [coll])
  (second+  [coll])
  (rest+    [coll])
  (butlast+ [coll])
  (last+    [coll])) 

#?(:clj
  (defmacro extend-coll-retrieve-for-type
    [type-key]
    (let [coll (with-meta (gensym) {:tag (-> type-key name (str "s"))})]
     `(extend-protocol CollRetrieve (get ~arr-types ~type-key)
        (get+
          ([~coll n#]  (get+ ~coll n# nil))
          ([~coll n# if-not-found#]
            (try (aget ~coll n#)
              (catch ArrayIndexOutOfBoundsException e# if-not-found#))))
        (first+  [~coll]  (aget ~coll 0))
        (second+ [~coll]  (aget ~coll 1))
        (last+   [~coll]  (aget ~coll (-> ~coll alength dec)))))))

#?(:clj
  (defmacro extend-coll-retrieve-to-all-arr! []
    (reduce-kv
      (fn [ret type type-class]
        ;(println type)
        (eval `(extend-coll-retrieve-for-type ~type)))
      nil arr-types)))

#?(:clj
  (extend-coll-retrieve-to-all-arr!))

; take-up-to (combination of getr and index-of + 1)

#?(:clj ; TODO: port to cljs for Arrays and ArrayLists
  (extend-protocol CollRetrieve ArrayList
    (getr+ [^ArrayList coll a b] (.subList ^ArrayList coll a b))
    (get+
      ([^ArrayList coll n]  (get+ ^ArrayList coll n nil))
      ([^ArrayList coll n if-not-found]
        (try (.get ^ArrayList coll n)
          (catch ArrayIndexOutOfBoundsException e# if-not-found))))
    (first+  [^ArrayList coll]  (get+ ^ArrayList coll 0))
    (second+ [^ArrayList coll]  (get+ ^ArrayList coll 1))
    (last+   [^ArrayList coll]  (get+ ^ArrayList coll (-> coll count+ dec)))))
; extend first+ to use /first/ when the object is unknown.
; first+ with non-collection items (java.util.Collection) will return itself.

(extend-protocol CollRetrieve
  Keyword
    (rest+ [k]
      (rest+ (name k)))
  #?(:clj String :cljs string)
    (first+   [coll]
      (try (subs coll 0 1)
        #?(:clj (catch StringIndexOutOfBoundsException _ nil))))
    (second+  [coll]
      (try (subs coll 1 2)
        #?(:clj (catch StringIndexOutOfBoundsException _ nil))))
    (rest+    [coll]
      (try (subs coll 1 (count+ coll))
        #?(:clj (catch StringIndexOutOfBoundsException _ nil))))
    (butlast+ [coll] (subs coll 0 (-> coll count+ dec)))
    (last+    [coll] (subs coll   (-> coll count+ dec)))
    (getr+    [coll a b] (str/subs+ coll a (inc (- b a))))) ; now inclusive range with |inc|; this could break lots of things

#?(:clj
(extend-protocol-for-all CollRetrieve
  [#?@(:clj  [clojure.core.protocols.CollReduce
              quantum.core.reducers.Folder]
       )]
          (getr+    [coll a b] (->> coll (take+ b) (drop+ a)))
          (first+   [coll]     (take+ 1 coll))
          (rest+    [coll]     (drop+ 1 coll))
  #?(:clj (butlast+ [coll]     (dropr+ 1 coll)))
  #?(:clj (last+    [coll]     (taker+ 1 coll)))))

; TODO FIX
; (extend-protocol-for-all CollRetrieve
;   [cljs.core.Delay]
;           (getr+    [coll a b] (->> coll (take+ b) (drop+ a)))
;           (first+   [coll]     (take+ 1 coll))
;           (rest+    [coll]     (drop+ 1 coll))
;   #?(:clj (butlast+ [coll]     (dropr+ 1 coll)))
;   #?(:clj (last+    [coll]     (taker+ 1 coll))))

; ===== REDUCERS =====

#?(:cljs
  (extend-protocol CollRetrieve
    cljs.core/Delay
      (getr+          [coll a b] (->> coll (take+ b) (drop+ a)))
      (first+         [coll]     (take+ 1 coll))
      (rest+          [coll]     (drop+ 1 coll))))
; _____________________________________________________________________________________
; ====================================== VECTOR =======================================
; `````````````````````````````````````````````````````````````````````````````````````
; TODO THIS IS CLJS COMPATIBLE
#?(:clj
(doseq  [type (:vec type/types)]
  (extend type CollRetrieve
    {:getr+
      (fn ([coll a b] (subvec+ coll a b))
          ([coll a]   (subvec+ coll a (-> coll count))))
    :first+   (fn [coll] (get coll 0)) ; perhaps implement in terms of |reduce|?
    :second+  (fn [coll] (get coll 1))
    :rest+    (fn [coll] (subvec+ coll 1 (count coll)))
    :butlast+ (fn [coll] (whenf coll nempty? pop))
    :last+    (fn [coll] (peek coll))
    :get+
      (fn ([coll n]              (get+ coll n nil))
          ([coll n if-not-found] (get coll n if-not-found)))})))
; _____________________________________________________________________________________
; ======================================== MAP ========================================
; `````````````````````````````````````````````````````````````````````````````````````
; TODO make more efficient
; TODO This is CLJS compatible
#?(:clj
(doseq [type (:map type/types)]
  (extend type CollRetrieve
    {:get+
      (fn
        ([coll n]              (get+ coll n nil))
        ([coll n if-not-found] (get coll n if-not-found)))})))
; _____________________________________________________________________________________
; ==================================== COLLECTION =====================================
; `````````````````````````````````````````````````````````````````````````````````````
; TODO this is CLJS compatible
#?(:clj
(doseq #?(:clj  [type [clojure.lang.IPersistentCollection]]
          :cljs [type (set/union (:iseq type/types) (:set type/types))])
  (extend type CollRetrieve
    {:getr+
      (fn ([coll a]   (->> coll (drop a)))
          ([coll a b] (->> coll (take b) (drop a))))
    :first+   (fn [coll] (nth     coll 0) ) ; perhaps implement in terms of |reduce|?
    :second+  (fn [coll] (get     coll 1))
    :rest+    (fn [coll] (rest    coll))
    :butlast+ (fn [coll] (butlast coll))
    :last+    (fn [coll] (last    coll))
    :get+
      (fn ([coll n]              (get+ coll n nil))
          ([coll n if-not-found] (nth coll n if-not-found)))})))

#?(:cljs
  (extend-protocol CollRetrieve
    cljs.core/EmptyList
      (first+   [coll] nil)))

(extend-protocol CollRetrieve
  ; sorted-map or sorted-set getr+ like subseq
 #?(:clj  Object ; "default"
    :cljs default)
    (get+
      ([obj n]              (get+ obj n nil))
      ([obj n if-not-found] (get obj n)))
    (first+   [obj] obj)
    (last+    [obj] obj)
    (butlast+ [obj] obj)
  nil
    (get+     [obj n] obj)
    (first+   [obj]   obj)
    (last+    [obj]   obj)
    (butlast+ [obj]   obj))

(defn gets+ [coll & indices]
  (if (should-transientize? indices)
      (persistent!
        (reduce
          (fn [ret ind] (conj! ret (get+ coll ind)))
          (transient [])
          indices))
      (reduce
        (fn [ret ind] (conj ret (get+ coll ind)))
        []
        indices)))

(def  pop+  butlast+)
(def  popr+ butlast+)
(def  popl+ rest+)
(def  peek+ last+)

(defn getf+ [n] (f*n get+ n))
;___________________________________________________________________________________________________________________________________
;=================================================={        SEARCH/FIND       }=====================================================
;=================================================={    index-of, contains?   }=====================================================
(defprotocol CollSearch
  (index-of+      [coll elem])
  (last-index-of+ [coll elem]))

#?(:clj
(defmacro extend1 [type0 protocol0 fn-map]
 `(doseq [[f-key# f#] ~fn-map]
    (let [f-name# (-> f-key# name symbol)]
      (extend-protocol ~protocol0
        ~type0 (f-name# (rest 'f#)))))))

; TODO implement more...
#?(:clj
  (doseq [type (:vec type/types)]
    (extend type CollSearch
      {:index-of+      (fn [coll elem] (.indexOf     ^clojure.lang.IPersistentVector coll elem))
       :last-index-of+ (fn [coll elem] (.lastIndexOf ^clojure.lang.IPersistentVector coll elem))})))

(extend-protocol CollSearch
  #?(:clj String :cljs string)
    (index-of+      [coll elem] (.indexOf     ^String coll ^String elem))
    (last-index-of+ [coll elem] (.lastIndexOf ^String coll ^String elem)))

(defn third [coll] (-> coll rest+ rest+ first+))

;___________________________________________________________________________________________________________________________________
;=================================================={           MODIFY         }=====================================================
;=================================================={    conjl, conjr, etc.    }=====================================================
; TODO This is a mess and needs to be "hygienized" by macros
; that determine clj variadic support vs. cljs non, and act accordingly. Also multiple arity builder  
; Variadic protocols aren't supported by CLJS
(defprotocol CollMod
  (conjl-
    #?@(:clj ([coll a]
              [coll a b]
              [coll a b c]
              [coll a b c d] 
              [coll a b c d e])
       :cljs ([coll args])))
  (conjr-
    #?@(:clj  ([coll arg] [coll arg & args])
       :cljs ([coll args]))))

;--------------------------------------------------{           CONJL          }-----------------------------------------------------

(extend-protocol-for-all CollMod
  [java.util.List]
  (conjl-
    ([coll a]           (->> coll (cons a)                                             ))
    ([coll a b]         (->> coll (cons b) (cons a)                                    ))
    ([coll a b c]       (->> coll (cons c) (cons b) (cons a)                           ))
    ([coll a b c d]     (->> coll (cons d) (cons c) (cons b) (cons a)                  ))
    ([coll a b c d e]   (->> coll (cons e) (cons d) (cons c) (cons b) (cons a)         ))
    ([coll a b c d e f] (->> coll (cons f) (cons e) (cons d) (cons c) (cons b) (cons a)))))

(extend-protocol-for-all CollMod
  [clojure.lang.IPersistentVector]
  (conjl-
    ([coll a]                  (catvec (vector+ a          ) coll))
    ([coll a b]                (catvec (vector+ a b        ) coll))
    ([coll a b c]              (catvec (vector+ a b c      ) coll))
    ([coll a b c d]            (catvec (vector+ a b c d    ) coll))
    ([coll a b c d e]          (catvec (vector+ a b c d e  ) coll))
    ([coll a b c d e f]        (catvec (vector+ a b c d e f) coll))
    ([coll a b c d e f & args] (catvec (apply vector+ args ) coll)))
  ; (conjl-
  ;   ([coll args] (apply conjl-vec coll args)))
  )

;--------------------------------------------------{           CONJR          }-----------------------------------------------------
; TODO CLJS compatible
#?(:clj
(doseq [type (:vec type/types)]
  (extend type CollMod
    {:conjr-
     #?(:clj  conj
        :cljs (fn [coll args] (apply conj coll args)))})))

; TODO CLJS compatible
#?(:clj
(doseq [type (:iseq type/types)]
  (extend type CollMod
    {:conjr-
      #?(:clj
           (fn ([coll arg]        (concat coll (list arg)))
               ([coll arg & args] (concat coll (cons arg args))))
         :cljs
           (fn [coll args] (concat coll args)))})))

; TODO: conjl with cons or conj, etc.


; TODO add arity
(def conjl #?(:clj conjl- :cljs (fn [coll & args] (conjr- coll args))))
(def conjr #?(:clj conjr- :cljs (fn [coll & args] (conjl- coll args))))

(def doto! swap!)

; If the array is not sorted:
; java.util.Arrays.asList(theArray).indexOf(o)
; If the array is sorted, you can make use of a binary search for performance:
; java.util.Arrays.binarySearch(theArray, o)




nil
quantum.core.collections.core=> quantum.core.collections.core=> flatland.ordered.map.OrderedMap
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> #'quantum.core.collections.core/lasti
quantum.core.collections.core=> quantum.core.collections.core=> CollCount
quantum.core.collections.core=> quantum.core.collections.core=> nil
quantum.core.collections.core=> quantum.core.collections.core=> #'quantum.core.collections.core/extend-coll-count-for-type
quantum.core.collections.core=> quantum.core.collections.core=> #'quantum.core.collections.core/extend-coll-count-to-all-arr!
quantum.core.collections.core=> quantum.core.collections.core=> nil
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> CollRetrieve
quantum.core.collections.core=> quantum.core.collections.core=> #'quantum.core.collections.core/extend-coll-retrieve-for-type
quantum.core.collections.core=> quantum.core.collections.core=> #'quantum.core.collections.core/extend-coll-retrieve-to-all-arr!
quantum.core.collections.core=> quantum.core.collections.core=> nil
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:4977:55 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
nil
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:4995:35 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:4996:35 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:4997:49 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_minus(java.lang.Object,java.lang.Object).
Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:4997:44 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
nil
quantum.core.collections.core=> quantum.core.collections.core=> nil
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> nil
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> nil
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> nil
quantum.core.collections.core=> quantum.core.collections.core=> nil
quantum.core.collections.core=> quantum.core.collections.core=> Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:5099:7 - call: public static boolean clojure.lang.Numbers.gt(long,java.lang.Object).
#'quantum.core.collections.core/gets+
quantum.core.collections.core=> quantum.core.collections.core=> #'quantum.core.collections.core/pop+
quantum.core.collections.core=> #'quantum.core.collections.core/popr+
quantum.core.collections.core=> #'quantum.core.collections.core/popl+
quantum.core.collections.core=> #'quantum.core.collections.core/peek+
quantum.core.collections.core=> quantum.core.collections.core=> #'quantum.core.collections.core/getf+
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> CollSearch
quantum.core.collections.core=> quantum.core.collections.core=> #'quantum.core.collections.core/extend1
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> Reflection warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:5134:40 - call to method indexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
Reflection warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:5135:40 - call to method lastIndexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
Reflection warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:5134:40 - call to method indexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
Reflection warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:5135:40 - call to method lastIndexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
nil
quantum.core.collections.core=> quantum.core.collections.core=> nil
quantum.core.collections.core=> quantum.core.collections.core=> #'quantum.core.collections.core/third
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> CollMod
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> nil
quantum.core.collections.core=> quantum.core.collections.core=> nil
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> nil
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> nil
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> #'quantum.core.collections.core/conjl
quantum.core.collections.core=> #'quantum.core.collections.core/conjr
quantum.core.collections.core=> quantum.core.collections.core=> #'quantum.core.collections.core/doto!
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> 
quantum.core.collections.core=> (conjl- (list 1 2 3) 4 5 6 7 8 9)
CompilerException java.lang.IllegalArgumentException: No single method: conjl_ of interface: quantum.core.collections.core.CollMod found for function: conjl- of protocol: CollMod, compiling:(/private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:5226:1) 
quantum.core.collections.core=> (conjl- (list 1 2 3) 4 5 6 7 8 )
IllegalArgumentException No implementation of method: :conjl- of protocol: #'quantum.core.collections.core/CollMod found for class: clojure.lang.PersistentList  clojure.core/-cache-protocol-fn (core_deftype.clj:554)
quantum.core.collections.core=> (conjl- (list 1 2 3) 4 5 6 7 )
IllegalArgumentException No implementation of method: :conjl- of protocol: #'quantum.core.collections.core/CollMod found for class: clojure.lang.PersistentList  clojure.core/-cache-protocol-fn (core_deftype.clj:554)
quantum.core.collections.core=> 
quantum.core.collections.core=> (defprotocol CollMod
  (conjl-
    #?@(:clj ([coll a]
              [coll a b]
              [coll a b c]
              [coll a b c d] 
              [coll a b c d e])
       :cljs ([coll args])))
  (conjr-
    #?@(:clj  ([coll arg] [coll arg & args])
       :cljs ([coll args]))))
CollMod
quantum.core.collections.core=> 
quantum.core.collections.core=> (extend-protocol-for-all CollMod
  [java.util.List]
  (conjl-
    ([coll a]           (->> coll (cons a)                                             ))
    ([coll a b]         (->> coll (cons b) (cons a)                                    ))
    ([coll a b c]       (->> coll (cons c) (cons b) (cons a)                           ))
    ([coll a b c d]     (->> coll (cons d) (cons c) (cons b) (cons a)                  ))
    ([coll a b c d e]   (->> coll (cons e) (cons d) (cons c) (cons b) (cons a)         ))
    ([coll a b c d e f] (->> coll (cons f) (cons e) (cons d) (cons c) (cons b) (cons a)))))
nil
quantum.core.collections.core=> (conjl- (list 1 2 3) 4 5 6 7 )
IllegalArgumentException No implementation of method: :conjl- of protocol: #'quantum.core.collections.core/CollMod found for class: clojure.lang.PersistentList  clojure.core/-cache-protocol-fn (core_deftype.clj:554)
quantum.core.collections.core=> (extend-protocol-for-all CollMod
  [java.util.List clojure.lang.IPersistentList] ; java.util.List isn't enough
  (conjl-
    ([coll a]           (->> coll (cons a)                                             ))
    ([coll a b]         (->> coll (cons b) (cons a)                                    ))
    ([coll a b c]       (->> coll (cons c) (cons b) (cons a)                           ))
    ([coll a b c d]     (->> coll (cons d) (cons c) (cons b) (cons a)                  ))
    ([coll a b c d e]   (->> coll (cons e) (cons d) (cons c) (cons b) (cons a)         ))
    ([coll a b c d e f] (->> coll (cons f) (cons e) (cons d) (cons c) (cons b) (cons a)))))
nil
quantum.core.collections.core=> (conjl- (list 1 2 3) 4 5 6 7 )
IllegalArgumentException No implementation of method: :conjl- of protocol: #'quantum.core.collections.core/CollMod found for class: clojure.lang.PersistentList  clojure.core/-cache-protocol-fn (core_deftype.clj:554)
quantum.core.collections.core=> 
quantum.core.collections.core=> (extend-protocol-for-all CollMod
  [java.util.List clojure.lang.IPersistentList
   clojure.lang.PersistentList] ; java.util.List isn't enough; clojure.lang.IPersistentList isn't enough
  (conjl-
    ([coll a]           (->> coll (cons a)                                             ))
    ([coll a b]         (->> coll (cons b) (cons a)                                    ))
    ([coll a b c]       (->> coll (cons c) (cons b) (cons a)                           ))
    ([coll a b c d]     (->> coll (cons d) (cons c) (cons b) (cons a)                  ))
    ([coll a b c d e]   (->> coll (cons e) (cons d) (cons c) (cons b) (cons a)         ))
    ([coll a b c d e f] (->> coll (cons f) (cons e) (cons d) (cons c) (cons b) (cons a)))))

nil
quantum.core.collections.core=> quantum.core.collections.core=> (conjl- (list 1 2 3) 4 5 6 7 )
(4 5 6 7 1 2 3)
quantum.core.collections.core=> 
quantum.core.collections.core=> (ns test
  (:require
    [clojure.tools.namespace.repl :refer [refresh refresh-all set-refresh-dirs]]
    [quantum.core.ns :as ns]))

;(ns/require :clj :lib)
(ns/require-all *ns* :clj :lib)

(defn init! [] (println "Hey :)"))
; (refresh-all :after 'test/init!)

(in-ns 'clojure.tools.namespace.parse)
(defn read-ns-decl
  "Attempts to read a (ns ...) declaration from a
  java.io.PushbackReader, and returns the unevaluated form. Returns
  the first top-level ns form found. Returns nil if read fails or if a
  ns declaration cannot be found. Note that read can execute code
  (controlled by *read-eval*), and as such should be used only with
  trusted sources."
  [rdr]
  {:pre [(instance? java.io.PushbackReader rdr)]}
  (try
   (loop []
     (let [form (doto (read {:read-cond :allow} rdr) str)]  ; str forces errors, see TNS-1
       (if (ns-decl? form)
         form
         (recur))))
   (catch Exception e nil)))
(in-ns 'test)
nil
test=> test=> test=> IllegalStateException Alias coll already exists in namespace test, aliasing quantum.core.collections  clojure.lang.Namespace.addAlias (Namespace.java:224)
test=> test=> #'test/init!
test=> test=> test=> #object[clojure.lang.Namespace 0x2f00f851 "clojure.tools.namespace.parse"]
clojure.tools.namespace.parse=> #'clojure.tools.namespace.parse/read-ns-decl
clojure.tools.namespace.parse=> #object[clojure.lang.Namespace 0x6ec53a5 "test"]
test=> (refresh)
:reloading (quantum.core.collections.core)
Boxed math warning, quantum/core/collections/core.cljc:148:55 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:166:35 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:167:35 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:168:49 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_minus(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:168:44 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:270:7 - call: public static boolean clojure.lang.Numbers.gt(long,java.lang.Object).
Reflection warning, quantum/core/collections/core.cljc:305:40 - call to method indexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
Reflection warning, quantum/core/collections/core.cljc:306:40 - call to method lastIndexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
Reflection warning, quantum/core/collections/core.cljc:305:40 - call to method indexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
Reflection warning, quantum/core/collections/core.cljc:306:40 - call to method lastIndexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
:ok
test=> (conjl- (list 1 2 3) 4 5 6 7 )
CompilerException java.lang.RuntimeException: Unable to resolve symbol: conjl- in this context, compiling:(/private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:5306:1) 
test=> (conjl (list 1 2 3) 4 5 6 7 )
ArityException Wrong number of args (5) passed to: core/eval44098/fn--44099/G--44087--44114  clojure.lang.AFn.throwArity (AFn.java:429)
test=> (conjr (list 1 2 3) 4 5 6 7 )
ArityException Wrong number of args (5) passed to: core/eval44098/fn--44122/G--44089--44137  clojure.lang.AFn.throwArity (AFn.java:429)
test=> (refresh)
:reloading (quantum.core.collections.core)
Boxed math warning, quantum/core/collections/core.cljc:148:55 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:166:35 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:167:35 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:168:49 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_minus(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:168:44 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:270:7 - call: public static boolean clojure.lang.Numbers.gt(long,java.lang.Object).
Reflection warning, quantum/core/collections/core.cljc:305:40 - call to method indexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
Reflection warning, quantum/core/collections/core.cljc:306:40 - call to method lastIndexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
Reflection warning, quantum/core/collections/core.cljc:305:40 - call to method indexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
Reflection warning, quantum/core/collections/core.cljc:306:40 - call to method lastIndexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
:ok
test=> (conjr (list 1 2 3) 4 5 6 7 )
ArityException Wrong number of args (5) passed to: core/eval44098/fn--44122/G--44089--44137  clojure.lang.AFn.throwArity (AFn.java:429)
test=> (conjl (list 1 2 3) 4 5 6 7 )
ArityException Wrong number of args (5) passed to: core/eval44098/fn--44099/G--44087--44114  clojure.lang.AFn.throwArity (AFn.java:429)
test=> (conjl (list 1 2 3) 4 5 6 7 )
ArityException Wrong number of args (5) passed to: core/eval44098/fn--44099/G--44087--44114  clojure.lang.AFn.throwArity (AFn.java:429)
test=> (refresh)
:reloading (quantum.core.collections quantum.core.print)
:error-while-loading quantum.core.collections
IllegalStateException error? already refers to: #'quantum.core.type/error? in namespace: test  clojure.lang.Namespace.warnOrFailOnReplace (Namespace.java:88)
test=> 
test=> #?(:clj
  (ns quantum.core.collections
    (:refer-clojure :exclude
      [for doseq contains? repeat repeatedly range merge count vec reduce into
       first second rest last butlast get pop peek])))

(ns
  ^{:doc
      "Various collections functions.

       Includes better versions of the following than clojure.core:

       for, doseq, repeat, repeatedly, range, merge,
       count, vec, reduce, into, first, second, rest,
       last, butlast, get, pop, peek ...

       and more.

       Many of them are aliased from other namespaces like
       quantum.core.collections.core, or quantum.core.reducers."
    :attribution "Alex Gunnarson"}
  quantum.core.collections
  (:refer-clojure :exclude
    [for doseq contains?
     repeat repeatedly
     range
     merge
     count
     vec
     reduce into
     first second rest last butlast get pop peek])
  (:require
    [quantum.core.ns :as ns :refer
      #?(:clj  [alias-ns defalias]
         :cljs [Exception IllegalArgumentException
                Nil Bool Num ExactNum Int Decimal Key Vec Set
                ArrList TreeMap LSeq Regex Editable Transient Queue Map])
      #?@(:cljs [:refer-macros [defalias]])]
    [quantum.core.logic :as logic :refer
      #?@(:clj  [[splice-or fn-and fn-or fn-not ifn if*n whenc whenf whenf*n whencf*n
                  condf condfc condf*n nnil? nempty? fn= fn-eq? any?]]
          :cljs [[splice-or fn-and fn-or fn-not nnil? nempty? fn= fn-eq? any?]
                 :refer-macros
                 [ifn if*n whenc whenf whenf*n whencf*n condf condfc condf*n]])]
    [quantum.core.type     :as type :refer
      [#?(:clj bigint?) #?(:cljs class) instance+? array-list? boolean? double? map-entry?
       sorted-map? queue? lseq? coll+? pattern? regex? editable?
       transient? #?(:clj should-transientize?) name-from-class #?(:clj arr-types)]
      #?@(:cljs [:refer-macros [should-transientize?]])]
    [quantum.core.numeric          :as num   :refer [greatest least]               ]
    [quantum.core.data.vector      :as vec   :refer [vector+? subvec+ catvec]]
    [quantum.core.data.map         :as map   :refer [#?(:clj ordered-map) map-entry]]
    [quantum.core.data.set         :as set   :refer [#?(:clj ordered-set)]          ]
    [quantum.core.collections.core :as coll                                        ]
    [quantum.core.log              :as log                                         ]
    [quantum.core.error            :as err   #?@(:clj [:refer [try+ throw+]])      ]
    [quantum.core.function :as fn :refer
      #?@(:clj  [[compr *fn f*n fn* unary zeroid fn->> fn-> <- with->>]]
          :cljs [[compr *fn f*n fn* unary zeroid]
                 :refer-macros
                 [fn->> fn-> <- with->> mfn]])]
    [quantum.core.reducers :as red]
    [quantum.core.string   :as str]
    [quantum.core.loops    :as loops]
    #?(:clj [clojure.pprint :refer [pprint]])
    [clojure.walk :as walk]
    [#?(:clj clojure.core.async :cljs cljs.core.async) :as async :refer
      [#?@(:clj [>!! <!! thread]) close! chan]]
    #?(:clj [clj-time.core]))
  #?(:cljs (:require-macros [quantum.core.loops :as loops :refer [for reducei]]))
  #?@(:clj
      [(:import
        clojure.core.Vec
        java.util.ArrayList
        (clojure.lang Keyword MapEntry Delay)
        (quantum.core.ns
          Nil Bool Num ExactNum Int Decimal Key Set
          Fn ArrList TreeMap LSeq Regex Editable Transient Queue Map))
       (:gen-class)]))

(defalias vec         red/vec+       )    
(defalias into        red/into+      )    
(defalias reduce      red/reduce     )
#?(:clj (defalias reducei loops/reducei  ))
(defalias redv        red/fold+      )
(defalias redm        red/reducem+   )
(defalias fold        red/fold+      ) ; only certain arities
(defalias foldv       red/foldp+     ) ; only certain arities
(defalias foldm       red/foldm+     ) 
(defalias map+        red/map+       )
(defalias filter+     red/filter+    )
(defalias lfilter     filter         )
(defalias remove+     red/remove+    )
(defalias lremove     remove         )
(defalias take+       red/take+      )
(defalias take-while+ red/take-while+)
(defalias drop+       red/drop+      )
(defalias group-by+   red/group-by+  )
(defalias flatten+    red/flatten+   )

; ; ====== LOOPS ======
;(def cljs-for+ (var red/for+))
; (defalias for+   #?(:clj red/for+         :cljs red/for+))
; (alter-meta! (var for+) assoc :macro true)

; (def cljs-for (var loops/for)) ; doesn't work because not a var
; (def cljs-for (mfn loops/for)) ; doesn't work because no |eval|
#?(:clj (defalias for loops/for))
#?(:clj (alter-meta! (var for) assoc :macro true))

;(def cljs-lfor (var clojure.core/for))
;(defalias lfor   #?(:clj clojure.core/for :cljs cljs-lfor))
;#?(:clj (defalias lfor clojure.core/for))
#?(:clj (defmacro lfor [& args] `(clojure.core/for ~@args)))

;(def cljs-doseq (var loops/doseq))
;(defalias doseq  #?(:clj loops/doseq      :cljs cljs-doseq))
#?(:clj (defmacro doseq [& args] `(loops/doseq ~@args)))

;(def cljs-doseqi (var loops/doseqi))
;(defalias doseqi #?(:clj loops/doseqi     :cljs cljs-doseqi))
#?(:clj (defmacro doseqi [& args] `(loops/doseqi ~@args)))

#?(:cljs
  (defn kv+
    "For some reason ClojureScript reducers have an issue and it's terrible... so use it like so:
     (map+ (compr kv+ <myfunc>) _)
     |reduce| doesn't have this problem."
    {:todo ["Eliminate the need for this."]}
    ([obj] obj)
    ([k v] k)))

; ; ====== COLLECTIONS ======

; ; TODO Don't redefine these vars
; #?(:cljs (defn map+    [f coll] (red/map+    (compr kv+ f) coll)))
; #?(:cljs (defn filter+ [f coll] (red/filter+ (compr kv+ f) coll)))
; #?(:cljs (defn remove+ [f coll] (red/remove+ (compr kv+ f) coll)))


(def      lasti         coll/lasti         )
(def      index-of      coll/index-of+     )
(def      last-index-of coll/last-index-of+)
(def      count         coll/count+        )
(def      getr          coll/getr+         )
(def      get           coll/get+          )
(def      gets          coll/gets+         )
(def      getf          coll/getf+         )

; If not |defalias|ed, "ArityException Wrong number of args (2) passed to: core/eval36441/fn--36457/G--36432--36466"
(defalias conjl         coll/conjl         )
(defalias conjr         coll/conjr         )
(def      pop           coll/pop+          )
(def      popr          coll/popr+         )
(def      popl          coll/popl+         )
(def      peek          coll/peek+         )
(def      first         coll/first+        )
(def      second        coll/second+       )
(def      third         coll/third         )
(def      rest          coll/rest+         )
(defalias lrest        #?(:clj  clojure.core/rest
                          :cljs cljs.core.rest    ))
(def      butlast       coll/butlast+      )
(def      last          coll/last+         )

(defalias merge map/merge+)

(defn merge-meta [sym-0 sym-f]
  (with-meta sym-0 (meta sym-f)))

(def frest (fn-> rest first))

; ===== REPEATEDLY =====

#?(:clj
(defmacro repeatedly-into
  [coll n & body]
  `(let [coll# ~coll
         n#    ~n]
     (if (should-transientize? coll#)
         (loop [v# (transient coll#) idx# 0]
           (if (>= idx# n#)
               (persistent! v#)
               (recur (conj! v# ~@body)
                      (inc idx#))))
         (loop [v#   coll# idx# 0]
           (if (>= idx# n#)
               v#
               (recur (conj v# ~@body)
                      (inc idx#))))))))

(def lrepeatedly clojure.core/repeatedly)

#?(:clj
(defmacro repeatedly
  "Like |clojure.core/.repeatedly| but (significantly) faster and returns a vector."
  ; ([n f]
  ;   `(repeatedly-into* [] ~n ~arg1 ~@body))
  ([n arg1 & body]
    `(repeatedly-into* [] ~n ~arg1 ~@body))))

; ===== RANGE =====

(#?(:clj defalias :cljs def) range+ red/range+)

(defalias lrange clojure.core/range)

(defn range
  ([]    (lrange))
  ([a]   (-> (range+ a)   redv))
  ([a b] (-> (range+ a b) redv)))

; ===== REPEAT =====

(defn repeat
  ([obj]   (clojure.core/repeat obj))
  ([n obj] (for [i (range n)] obj)))

; ===== ....

(defn ^Set abs-difference 
  "Returns the absolute difference between a and b.
   That is, (a diff b) union (b diff a)."
  {:todo ["Probably a better name for this."]}
  [a b]
  (set/union
    (set/difference a b)
    (set/difference b a)))

; ; a better merge?
; ; a better merge-with?
#?(:clj
  (defn get-map-constructor
    "Gets a record's map-constructor function via its class name."
    [rec]
    (let [^String class-name-0
            (if (class? rec)
                (-> rec str)
                (-> rec class str))
          ^String class-name
            (getr class-name-0
              (-> class-name-0 (last-index-of ".") inc)
              (-> class-name-0 count))
          ^Fn map-constructor-fn
            (->> class-name (str "map->") symbol eval)]
      map-constructor-fn)))

; ================================================ REDUCE ================================================

(defn reduce-2
  "Like |reduce|, but reduces over two items in a collection at a time.

   Its function @func must take three arguments:
   1) The accumulated return value of the reduction function
   2) The                next item in the collection being reduced over
   3) The item after the next item in the collection being reduced over"
  {:attribution "Alex Gunnarson"}
  [func init coll] ; not actually implementing of CollReduce... so not as fast...
  (loop [ret init coll-n coll]
    (if (empty? coll-n)
        ret
        (recur (func ret (first coll-n) (second coll-n))
               (-> coll-n rest rest)))))

; ================================================ FILTER ================================================

(defn ffilter
  "Returns the first result of a |filter| operation.
   Uses lazy |filter| so as to do it in the fastest possible way."
   [^Fn filter-fn coll]
   (->> coll (filter filter-fn) first))

(defn ffilter+
  {:todo ["Use a delayed reduction as the base!"]}
  [^Fn pred coll]
  (reduce
    (fn [ret elem-n]
      (when (pred elem-n)
        (reduced elem-n)))
    nil
    coll))

(defn ^MapEntry ffilteri+
  {:todo ["Use a delayed reduction as the base!" "Allow parallelization"]
   :in   ['(ffilteri+ fn-eq? "4") '["a" "d" "t" "4" "10"]]
   :out  ["4" "3"]}
  [^Fn pred coll]
  (reducei
    (fn [ret elem-n index-n]
      (if (pred elem-n)
          (reduced (map-entry index-n elem-n))
          (if (= index-n (lasti coll)) ; If it's looked through all elements and they don't match,
              (map-entry -1 nil)
              (map-entry (inc index-n) nil))))
    (map-entry 0 nil)
    coll))

(defn filteri+
  {:todo ["Use reducers"]}
  [pred coll]
  (if (should-transientize? coll)
      (persistent!
        (reducei
          (fn [ret elem-n n]
            (if (pred elem-n)
                (conj! ret (map-entry n elem-n))
                ret))
          (transient [])
          coll))
      (reducei
        (fn [ret elem-n n]
          (if (pred elem-n)
              (conj ret (map-entry n elem-n))
              ret))
        []
        coll)))

; ================================================ INDEX-OF ================================================

(defn indices-of+
  {:todo ["Make parallizeable"]}
  [coll elem-0]
  (if (should-transientize? coll)
      (persistent!
        (reducei
          (fn [ret elem-n n]
            (if (= elem-0 elem-n)
                (conj! ret n)
                ret))
          (transient [])
          coll))
      (reducei
        (fn [ret elem-n n]
          (if (= elem-0 elem-n)
              (conj ret n)
              ret))
        []
        coll)))

; ================================================ TAKE ================================================

; ============ TAKE-LEFT ============

(defn takel+ [coll n]
  (getr coll 0 n))

(defn take-from+
  "Take starting at and including index n."
  {:todo ["Use reducers"]}
  [obj ^Int n]
  (getr obj n (count obj)))

(defn take-fromi+
  {:todo ["Use reducers"]
   :in  ["asdbsd" "db"]
   :out "dbsd"}
  [obj sub-obj]
  (take-from+ obj (index-of obj sub-obj)))

(defn take-afteri+
  {:todo ["Use reducers"]
   :in  ["asdbsd" "db"]
   :out "dbsd"}
  [obj sub-obj]
  (take-from+
    obj
    (+ (index-of obj sub-obj)
       (count sub-obj))))

(defn take-untili+ [obj sub-obj]
  (getr obj 0 (index-of obj sub-obj)))

; ============ TAKE-RIGHT ============

(defn takeri+
  "Take up to and including right index of."
  {:todo "Combine code with /taker-untili+/"
   :in  "(untilri+ 'abcdefg' 'c')"
   :out "'defg'"}
  [super sub]
  (let [index-r-0 (last-index-of super sub)
        index-r
          ; (whenc (last-index-of super sub) (fn= -1) ; Throws a strange undefined error in ClojureScript... ugh...
          ;   (throw (str "Index of" (squote sub) "not found.")))
          (if (= -1 index-r-0)
              (throw (str "Index of" (str/squote sub) "not found."))
              index-r-0)]
    (getr super
      index-r
      (-> super lasti))))

(defn taker-untili+
  "Until right index of."
  {:todo "Combine code with /takeri/"
   :in  ["abcdefg" "c"]
   :out "'defg'"}
  [super sub]
  (let [index-r
          (whenc (last-index-of super sub) (fn= -1)
            (throw (str "Index of" (str/squote sub) "not found.")))])
  (getr super
    (inc (last-index-of super sub))
    (-> super lasti)))

#?(:clj
  (defn take-while-not
    {:attribution "Alex Gunnarson"
     :todo ["Rewrite this"]}
    [^String s ^String elem]
    (getr s 0
      (whenc (index-of s elem) (fn-eq? -1)
        (count s)))))

; ================================================ DROP ================================================

(defn dropl+
  {:attribution "Alex Gunnarson"}
  [obj ^Int n]
  (getr obj n (count obj)))

(defn dropr+
  {:attribution "Alex Gunnarson"}
  [obj n]
  (getr obj 0 (- (lasti obj) n)))

; ================================================ MERGE ================================================

(defn merge-keep-left [a b] (merge b a))
              
(defn split-remove+
  {:todo ["Slightly inefficient  two /index-of/ implicit."]}
  [coll split-at-obj]
  [(take-untili+ coll split-at-obj)
   (take-afteri+ coll split-at-obj)])

#?(:clj
(defmacro kmap [& ks]
 `(zipmap (map keyword (quote ~ks)) (list ~@ks))))

(defn select
  "Applies a list of functions, @fns, separately to an object, @coll.
   A good use case is returning values from an associative structure with keys as @fns.
   Returns a vector of the results."
  ^{:attribution "Alex Gunnarson"
    :usage "(select {:a 1 :b [3]} :a (compr :b 0)) => [1 3]"}
  [coll & fns]
  ((apply juxt fns) coll))

(defn comparator-extreme-of
  "For compare-fns that don't have enough arity to do, say,
   |(apply time/latest [date1 date2 date3])|.

   Gets the most \"extreme\" element in collection @coll,
   \"extreme\" being defined on the @compare-fn.

   In the case of |time/latest|, it would return the latest
   DateTime in a collection.

   In the case of |>| (greater than), it would return the
   greatest element in the collection:

   (comparator-extreme-of [1 2 3] (fn [a b] (if (> a b) a b)) )
   :: 3

   |(fn [a b] (if (> a b) a b))| is the same thing as
   |(choice-comparator >)|."
  {:todo ["Rename this function."
          "HOW DOES THIS HAVE ANY RELEVANCE?"
          "Possibly belongs in a different namespace"]}
  [coll ^Fn compare-fn]
  (reducei
    (fn [ret elem n]
      (if (= n 0)
          elem
          (compare-fn ret elem)))
    nil
    coll))

(defn coll-if [obj]
  (whenf obj (fn-not coll?) vector))

(defn seq-if [obj]
  (condf obj
    (fn-or seq? nil?) identity
    coll?             seq
    :else             list))
;___________________________________________________________________________________________________________________________________
;=================================================={         LAZY SEQS        }=====================================================
;=================================================={                          }=====================================================
#?(:clj (defalias lseq lazy-seq))

#?(:clj
  (def lseq+
    (condf*n
      (fn-or seq? nil? coll?) #(lseq %) ; not |partial|, because can't take value of a macro
      :else (fn-> list lseq first))))

(defn unchunk
  "Takes a seqable and returns a lazy sequence that
   is maximally lazy and doesn't realize elements due to either
   chunking or apply.

   Useful when you don't want chunking, for instance,
   (first awesome-website? (map slurp <a-bunch-of-urls>))
   may slurp up to 31 unneed webpages, whereas
   (first awesome-website? (map slurp (unchunk <a-bunch-of-urls>)))
   is guaranteed to stop slurping after the first awesome website.

  Taken from http://stackoverflow.com/questions/3407876/how-do-i-avoid-clojures-chunking-behavior-for-lazy-seqs-that-i-want-to-short-ci"
  {:attribution "prismatic.plumbing"}
  [s]
  (when (seq s)
    (cons (first s)
          (lseq (s rest unchunk)))))
;___________________________________________________________________________________________________________________________________
;=================================================={  POSITION IN COLLECTION  }=====================================================
;=================================================={ first, rest, nth, get ...}=====================================================
; (defn- nth-red
;   "|nth| implemented in terms of |reduce|."
;   {:deprecated  true
;    :attribution "Alex Gunnarson"
;    :performance "Twice as slow as |nth|"}
;   [coll n]
;   (let [nn (volatile! 0)]
;     (->> coll
;          (reduce
;            (fn
;              ([ret elem]
;               (if (= n @nn)
;                   (reduced elem)
;                   (do (vswap! nn inc) ret)))
;              ([ret k v]
;                (if (= n @nn)
;                    (reduced [k v])
;                    (do (vswap! nn inc) ret))))
;            []))))

(defn key+
  "Like |key| but more robust."
  ^{:attribution "Alex Gunnarson"
    :todo ["Determine which objects are |key| able, 
            i.e., are associative."]}
  ([obj] 
    (#?(:clj try+ :cljs try)
      (ifn obj vector? first key)
      (catch #?(:clj Object :cljs js/Error) _
        (println "Error in key+ with obj:" (class obj)) nil)))
  ([k v] k)) ; For use with kv-reduce

(defn val+
  "Like |val| but more robust."
  ^{:attribution "Alex Gunnarson"}
  ([obj]
    (#?(:clj try+ :cljs try)
      (ifn obj vector? second key)
      (catch #?(:clj Object :cljs js/Error) _ nil)))
  ([k v] v)) ; For use with kv-reduce

(defn fkey+ [m]
  (-> m first key+))
(defn fval+ [m]
  (-> m first val+))

(defn up-val
  {:in '[{:a "ABC" :b 123} :a]
   :out '{"ABC" {:b 123}}
   :todo ["hash-map creation inefficient ATM"]}
  [^Map m k]
  (hash-map
    (get m k)
    (-> m (dissoc k))))

#?(:cljs
  (defn rename-keys [m-0 rename-m]
    (reduce
      (fn [ret k-0 k-f]
        (-> ret
            (assoc  k-f (get ret k-0))
            (dissoc k-0)))
      m-0
      rename-m)))

; ; for /subseq/, the coll must be a sorted collection (e.g., not a [], but rather a sorted-map or sorted-set)
; ; test(s) one of <, <=, > or >=

; ; /nthrest/
; ; (nthrest (range 10) 4) => (4 5 6 7 8 9)

; ; TODO: get-in from clojure, make it better
(defn get-in+ [coll [iden :as keys-0]] ; implement recursively
  (if (= iden identity)
      coll
      (get-in coll keys-0)))
(defn reverse+ [coll] ; what about arrays? some transient loop or something
  (ifn coll reversible? rseq reverse))
(def single?
  "Does coll have only one element?"
  (fn-and seq (fn-not next)))
;___________________________________________________________________________________________________________________________________
;=================================================={   ADDITIVE OPERATIONS    }=====================================================
;=================================================={    conj, cons, assoc     }=====================================================

;___________________________________________________________________________________________________________________________________
;=================================================={           MERGE          }=====================================================
;=================================================={      zipmap, zipvec      }=====================================================
; A better zipvec...
;(defn zipvec+ [& colls-0] ; (map vector [] [] [] []) ; 1.487238 ms for zipvec+ vs. 1.628670 ms for doall + map-vector.
;   (let [colls (->> colls-0 (map+ fold+) fold+)]
;     (for+ [n (range 0 (count (get colls 0)))] ; should be easy, because count will be O(1) with folded colls
;       (->> colls
;            (map (f*n get+ n)))))) ; get+ doesn't take long at all; also, apparently can't use map+ within for+...
;                                   ; 234.462665 ms if you realize them
; (defn zipfor- [& colls-0] ;  [[1 2 3] [4 5 6] [7 8 9]]
;   (let [colls (->> colls-0 (map+ fold+) fold+) ; nested /for/s, no
;         rng   (range 0 (-> colls count dec))]
;     (for   [n  rng] ; [[1 2 3] [4 5 6] [7 8 9]]
;       (for [cn rng] ; ((1 4 7) (4 5 6) ...)
;         (-> colls (get cn) (get n))))))
;; (zipvec-- [[1 2 3] [4 5 6] [7 8 9]])
;(defn zipvec-- [& colls-0] ; nested /map/s, no
;  (let [colls (vec+ colls-0)]
;    (map+
;      (fn [n]
;        (map+ (getf+ n) colls))
;      (range 0 (inc 2)))))

(declare contains?)

(defn merge-with+
  "Like merge-with, but the merging function takes the key being merged
   as the first argument"
   {:attribution  "prismatic.plumbing"
    :todo ["Make it not output HashMaps but preserve records"]
    :contributors ["Alex Gunnarson"]}
  [f & maps]
  (when (any? identity maps)
    (let [merge-entry
           (fn [m e]
             (let [k (key e) v (val e)]
               (if (contains? m k)
                 (assoc m k (f k (get m k) v))
                 (assoc m k v))))
          merge2
            (fn ([] {})
                ([m1 m2]
                 (reduce merge-entry (or m1 {}) (seq m2))))]
      (reduce merge2 maps))))

(defn ^Map merge-vals-left
  "Merges into the left map all elements of the right map whose
   keys are found in the left map.

   Combines using @f, a |merge-with| function."
  {:todo "Make a reducer, not just implement using |reduce| function."
   :in ['{:a {:aa 1}
          :b {:aa 3}}
         {:a {:aa 5}
          :c {:bb 4}}
         (fn [k v1 v2] (+ v1 v2))]
   :out '{:a {:aa 6}
          :b {:aa 3}}}
  [^Map left ^Map right ^Fn f]
  (persistent!
    (reduce
      (fn [left-f ^Key k-right ^Map v-right]
       ;(if ((fn-not contains?) left-f k-right) ; can't call |contains?| on a transient, apparently...
       ;    left-f)
       (let [^Map v-left
               (get left k-right)]
         (if (nil? v-left)
             left-f
             (let [^Map merged-vs
                   (merge-with+ f v-left v-right)]
               (assoc! left-f k-right merged-vs)))))
      (transient left)
      right)))
;___________________________________________________________________________________________________________________________________
;=================================================={      CONCATENATION       }=====================================================
;=================================================={ cat, fold, (map|con)cat  }=====================================================
(defn- concat++
  {:todo ["Needs optimization"]}
  ([coll]
    (try (reduce catvec coll)
      (catch Exception e (reduce (zeroid into []) coll))))
  ([coll & colls]
    (try (apply catvec coll colls)
      (catch Exception e (into [] coll colls)))))
;  Use original vectors until they are split. Subvec-orig below a certain range? Before the inflection point of log-n
;___________________________________________________________________________________________________________________________________
;=================================================={  FINDING IN COLLECTION   }=====================================================
;=================================================={  in?, index-of, find ... }=====================================================
(defprotocol Contains?
  (contains? [coll elem]))
(extend-protocol Contains?
  #?(:clj String :cljs string)
    (contains? [coll elem]
     #?(:clj  (.contains ^String coll ^String elem)
        :cljs (not= -1 (.indexOf coll elem))))
  Regex
    (contains? [coll elem]
      (nnil? (str/re-find+ elem coll)))
  #?(:clj Object :cljs default)
    (contains? [coll elem]
      (any? (fn-eq? elem) coll)))

(doseq [type (:map type/types)]
  (extend type Contains?
    {:contains? (fn [coll k] (clojure.core/contains? coll k))}))

(defn in?
  "The inverse of |contains?|"
  {:todo ["|definline| this?"]}
  [elem coll] (contains? coll elem))

; TODO limit it to only strings
(def subs? in?)

; ;-----------------------{       SELECT-KEYS       }-----------------------
(defn- ^Map select-keys-large
  "A transient and reducing version of clojure.core's |select-keys|."
  {:performance
    "45.3 ms vs. core's 60.29 ms on:
     (dotimes [_ 100000]
       (select-keys
         {:a 1 :b 2 :c 3 :d 4 :e 5 :f 6 :g 7}
         [:b :c :e]))).
     Performs much better on large set of keys."} 
  [keyseq m]
    (-> (transient {})
        (reduce
          (fn [ret k]
            (let [entry (. clojure.lang.RT (find m k))]
              (if entry
                  (conj! ret entry)
                  ret)))
          (seq keyseq))
        persistent!
        (with-meta (meta m))))

(defn- ^Map select-keys-small
  "A transient version of clojure.core's |select-keys|.

   Note: using a reducer here incurs the overhead of creating a
   function on the fly (can't extern it because of a closure).
   This is better for small set of keys."
  {:performance
    "39.09 ms vs. core's 60.29 ms on:
     (dotimes [_ 100000]
       (select-keys
         {:a 1 :b 2 :c 3 :d 4 :e 5 :f 6 :g 7}
         [:b :c :e])))"} 
  [keyseq m]
    (loop [ret (transient {}) keys (seq keyseq)]
      (if keys
        (let [entry (. clojure.lang.RT (find m (first keys)))]
          (recur
           (if entry
             (conj! ret entry)
             ret)
           (next keys)))
        (with-meta (persistent! ret) (meta m)))))

(defn- ^Delay select-keys-delay
  "Not as fast as select-keys with transients."
  {:todo ["FIX THIS"]}
  [ks m]
  (let [ks-set (into #{} ks)]
    (->> m
         (filter+
           (compr key+ (f*n in? ks-set))))))

(defn ^Map select-keys+
  {:todo
    ["Determine actual inflection point at which select-keys-large
      should be used over select-keys-small."]}
  [m ks]
  (if (-> ks count (> 10))
      (select-keys-small m ks)
      (select-keys-large m ks)))

; ;-----------------------{       CONTAINMENT       }-----------------------

; ; index-of-from [o val index-from] - index-of, starting at index-from
; (defn contains-or? [coll elems]
;   (apply-or (map (partial contains? coll) elems)))
(defn get-keys
  {:attribution "Alex Gunnarson"}
  [m obj]
  (persistent!
    (reduce
      (fn [ret k v]
        (if (identical? obj v)
            (conj! ret k)
            ret))
      (transient [])
      m)))
(defn get-key [m obj] (-> m (get-keys obj) first))
; ; /find/ Returns the map entry for key, or nil if key not present
; ; (find {:b 2 :a 1 :c 3} :a) => [:a 1]
; ; (select-keys {:a 1 :b 2} [:a :c]) =>  {:a 1}
; ; /frequencies/
; ; (frequencies ['a 'b 'a 'a])
; ; {a 3, b 1}
; ; /partition-by/
; ; splits the coll each time f returns a new value
; ; (partition-by odd? [1 1 1 2 2 3 3])
; ; => ((1 1 1) (2 2) (3 3)) /lseq/
;___________________________________________________________________________________________________________________________________
;=================================================={  FILTER + REMOVE + KEEP  }=====================================================
;=================================================={                          }=====================================================
(defn filter-keys+ [pred coll] (->> coll (filter+ (compr key+ pred))))
(defn remove-keys+ [pred coll] (->> coll (remove+ (compr key+ pred))))
(defn filter-vals+ [pred coll] (->> coll (filter+ (compr val+ pred))))
(defn remove-vals+ [pred coll] (->> coll (remove+ (compr key+ pred))))

(defn vals+
  {:attribution "Alex Gunnarson"
   :todo ["Compare performance with core functions"]}
  [m]
  (->> m (map+ val+) redv))
(defn keys+
  {:attribution "Alex Gunnarson"
   :todo ["Compare performance with core functions"]}
  [m]
  (->> m (map+ key+) redv))
;___________________________________________________________________________________________________________________________________
;=================================================={     PARTITION, GROUP     }=====================================================
;=================================================={       incl. slice        }=====================================================
; slice-from [o start] - like slice, but until the end of o
; slice-to [o end] - like slice, but from the beginning of o
(defn slice
  "Divide coll into n approximately equal slices.
   Like partition."
  {:attribution "flatland.useful.seq"
   :todo ["Optimize" "Use transients"]}
  [n-0 coll]
  (loop [n-n n-0 slices [] items (vec coll)]
    (if (empty? items)
      slices
      (let [size (num/ceil (/ (count items) n-n))]
        (recur (dec n-n)
               (conj slices (subvec+ items 0 size))
               (subvec+ items size))))))
; /partition/
; (partition 4 (range 20))
; => ((0 1 2 3) (4 5 6 7) (8 9 10 11) (12 13 14 15) (16 17 18 19))
; (partition 4 6 ["a" "b" "c" "d"] (range 20))
; => ((0 1 2 3) (6 7 8 9) (12 13 14 15) (18 19 "a" "b"))
; /partition-all/
; Returns a lazy sequence of lists like partition, but may include
; partitions with fewer than n items at the end.
; (partition-all 4 [0 1 2 3 4 5 6 7 8 9])
; => ((0 1 2 3) (4 5 6 7) (8 9))
;___________________________________________________________________________________________________________________________________
;=================================================={  DIFFERENTIAL OPERATIONS }=====================================================
;=================================================={     take, drop, split    }=====================================================
; /take-nth/
; (take-nth 2 (range 10))
; => (0 2 4 6 8)
; /cycle/
; (take 5 (cycle ["a" "b"]))
; => ("a" "b" "a" "b" "a")
; /take-last/ ; turn this into a subvec
; (take-last 2 [1 2 3 4]) => (3 4)
; /last/    is a limiting case (1) of take-last
; /drop-last/ ; (drop-last 2 [1 2 3 4]) => (1 2)
; /butlast/ is a limiting case (1) of drop-last

; splice [o index n val] - fast remove and insert in one go
; splice-arr [o index n val-arr] - fast remove and insert in one go
; insert-before [o index val] - insert one item inside coll
; insert-before-arr [o index val] - insert array of items inside coll
; remove-at [o index] - remove one item from index pos
; remove-n [o index n] - remove n items starting at index pos
; triml [o n] - trims n items from left
; trimr [o n] - trims n items from right
; trim [o nl nr] - trims nl items from left and nr items from right
; rip [o index] - rips coll and returns [pre-coll item-at suf-coll]
; sew [pre-coll item-arr suf-coll] - opposite of rip, but with arr
(defn split [ind coll-0]
  (if (vector? coll-0)
      [(subvec+ coll-0 0   ind)
       (subvec+ coll-0 ind (count coll-0))]
      (split-at coll-0 ind)))
(defn split-with-v+ [pred coll-0] ; IMPROVE
  (->> coll-0
       (split-with pred)
       (map+ vec)))
;_._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._
;=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*{        ASSOCIATIVE       }=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=
;=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*{                          }=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=
;___________________________________________________________________________________________________________________________________
;=================================================={          ASSOC           }=====================================================
;=================================================={ update(-in), assoc(-in)  }=====================================================
(defn- extend-coll-to
  "Extends an associative structure (for now, only vector) to a given index."
  {:attribution "Alex Gunnarson"
   :usage "USAGE: (extend-coll-to [1 2 3] 5) => [1 2 3 nil nil]"}
  [coll-0 k]
  (if (and (vector? coll-0)
           (number? k)
           (-> coll-0 count dec (< k)))
      (let [trans?   (transient? coll-0)
            trans-fn (if trans? identity transient)
            pers-fn  (if trans? identity persistent!)]
        (pers-fn
          (reduce
            (fn [coll-n _] (conj! coll-n nil)) ; extend-vec part
            (trans-fn coll-0)
            (range (count coll-0) (inc k)))))
      coll-0))
(defn assoc+
  {:todo ["Protocolize on IEditableCollection"
          "Probably has performance issues"]}
  ([coll-0 k v]
    (assoc (extend-coll-to coll-0 k) k v))
    ; once probably gives no performance benefit from transience
  ([coll-0 k v & kvs-0]
    (let [edit?    (editable? coll-0)
          trans-fn (if edit? transient   identity)
          pers-fn  (if edit? persistent! identity)
          assoc-fn (if edit? assoc!      assoc)]
      (loop [kvs-n  kvs-0
             coll-f (-> coll-0 trans-fn
                        (extend-coll-to k)
                        (assoc-fn k v))]
        (if (empty? kvs-n)
            (pers-fn coll-f)
            (recur (-> kvs-n rest rest)
                   (let [k-n (first kvs-n)]
                     (-> coll-f (extend-coll-to k-n)
                         (assoc-fn k-n (second kvs-n))))))))))
(defn update+
  "Updates the value in an associative data structure @coll associated with key @k
   by applying the function @f to the existing value."
  ^{:attribution "weavejester.medley"
    :contributors ["Alex Gunnarson"]}
  ([coll k f]      (assoc+ coll k       (f (get coll k))))
  ([coll k f args] (assoc+ coll k (apply f (get coll k) args))))

(defn updates+
  "For each key-function pair in @kfs,
   updates value in an associative data structure @coll associated with key
   by applying the function @f to the existing value."
  ^{:attribution "Alex Gunnarson"
    :todo ["Probably updates and update are redundant"]}
  ([coll & kfs]
    (reduce-2 ; This is inefficient
      (fn [ret k f] (update+ ret k f))
      coll
      kfs)))

(defn update-key+
  {:attribution "Alex Gunnarson"
   :usage '(->> {:a 4 :b 12}
                (map+ (update-key+ str)))}
  ([f]
    (fn
      ([kv]
        (assoc+ kv 0 (f (get kv 0))))
      ([k v]
        (map-entry (f k) v)))))

(defn update-val+
  {:attribution "Alex Gunnarson"
   :usage '(->> {:a 4 :b 12}
                (map+ (update-val+ (f*n / 2))))}
  ([f]
    (fn
      ([kv]
        (assoc+ kv 1 (f (get kv 1))))
      ([k v]
        (map-entry k (f v))))))

(defn mapmux
  ([kv]  kv)
  ([k v] (map-entry k v)))
(defn record->map [rec]
  (into {} rec))

;--------------------------------------------------{        UPDATE-IN         }-----------------------------------------------------
(defn update-in!
  "'Updates' a value in a nested associative structure, where ks is a sequence of keys and
  f is a function that will take the old value and any supplied args and return the new
  value, and returns a new nested structure. The associative structure can have transients
  in it, but if any levels do not exist, non-transient hash-maps will be created."
  {:attribution "flatland.useful"}
  [m [k & ks] f & args]
  (let [assoc-fn (if (transient? m) assoc! assoc)
        val (get m k)]
    (assoc-fn m k
      (if ks
          (apply update-in! val ks f args)
          (apply f val args)))))
; perhaps make a version of update-in : update :: assoc-in : assoc ?

(defn update-in+
  "Created so vectors would also automatically be grown like maps,
   given indices not present in the vector."
  {:attribution "Alex Gunnarson"
   :todo ["optimize via transients"
          "allow to use :last on vectors"
          "allow |identity| function for unity's sake"]}
  [coll-0 [k0 & keys-0] v0]
  (let [value (get coll-0 k0 (when (-> keys-0 first number?) []))
        coll-f (extend-coll-to coll-0 k0)
        val-f (if keys-0
                  (update-in+ value keys-0 v0) ; make a non-stack-consuming version, possibly via trampoline? 
                  v0)]
    (assoc coll-f k0 (whenf val-f fn? (*fn (get coll-f k0))))))
;--------------------------------------------------{         ASSOC-IN         }-----------------------------------------------------
(defn assoc-in+
  [coll ks v]
  (update-in+ coll ks (constantly v)))

(defn assoc-in!
  "Associates a value in a nested associative structure, where ks is a sequence of keys
  and v is the new value and returns a new nested structure. The associative structure
  can have transients in it, but if any levels do not exist, non-transient hash-maps will
  be created."
  ^{:attribution "flatland.useful"}
  [m ks v]
  (update-in! m ks (constantly v)))

(defn assocs-in+
  {:usage "(assocs-in ['file0' 'file1' 'file2']
             [0] 'file10'
             [1] 'file11'
             [2] 'file12')"}
  [coll & kvs]
  (reduce-2 ; this is inefficient
    (fn [ret k v] (assoc-in+ ret k v))
    coll
    kvs))
;___________________________________________________________________________________________________________________________________
;=================================================={          DISSOC          }=====================================================
;=================================================={                          }=====================================================
(defn dissoc+
  {:todo ["Protocolize"]}
  ([coll key-0]
    (try
      (cond ; probably use tricks to see which subvec is longer to into is less consumptive
        (vector? coll)
          (catvec (subvec+ coll 0 key-0)
                  (subvec+ coll (inc key-0) (count coll)))
        (editable? coll)
          (-> coll transient (dissoc! coll key-0) persistent!)
        :else
          (dissoc coll key-0))
      (catch ClassCastException e (dissoc coll key-0)))) ; Probably because of transients...
  ([coll key-0 & keys-0]
    (reduce dissoc+ coll (cons key-0 keys-0))))

(defn dissocs+ [coll & ks]
  (reduce
    (fn [ret k]
      (dissoc+ ret k))
    coll
    ks))

(defn dissoc-if+ [coll pred k] ; make dissoc-ifs+
  (whenf coll (fn-> (get k) pred)
    (f*n dissoc+ k)))

(defn dissoc-in+
  "Dissociate a value in a nested assocative structure, identified by a sequence
  of keys. Any collections left empty by the operation will be dissociated from
  their containing structures.
  This implementation was adapted from clojure.core.contrib"
  {:attribution "weavejester.medley"
   :todo ["Transientize"]}
  [m ks]
  (if-let [[k & ks] (seq ks)]
    (if (seq ks)
      (let [new-n (dissoc-in+ (get m k) ks)] ; this is terrible
        (if (empty? new-n) ; dissoc's empty ones
            (dissoc m k)
            (assoc m k new-n)))
      (dissoc m k))
    m))

(defn updates-in+
  [coll & kfs]
  (reduce-2 ; Inefficient
    (fn [ret k-n f-n] (update-in+ ret k-n f-n))
    coll
    kfs))

(defn re-assoc+ [coll k-0 k-f]
  (if (contains? coll k-0)
      (-> coll
         (assoc+  k-f (get coll k-0))
         (dissoc+ k-0))
      coll))

(defn re-assocs+ [coll & kfs]
  (reduce-2 ; Inefficient
    (fn [ret k-n f-n] (re-assoc+ ret k-n f-n))
    coll
    kfs))

(defn ^Map select-as+
  {:todo ["Name this function more appropriately"]
   :attribution "Alex Gunnarson"}
  ([coll kfs]
    (->> (reduce
           (fn [ret k f]
             (assoc+ ret k (f coll)))
           {}
           kfs)))
  ([coll k1 f1 & {:as kfs}]
    (select-as+ coll (assoc+ kfs k1 f1))))
;___________________________________________________________________________________________________________________________________
;=================================================={   DISTINCT, INTERLEAVE   }=====================================================
;=================================================={  interpose, frequencies  }=====================================================
#?(:clj
  (defn distinct-by-java
    "Returns elements of coll which return unique
     values according to f. If multiple elements of coll return the same
     value under f, the first is returned"
    {:attribution "prismatic.plumbing"
     :performance "Faster than |core/distinct-by|"}
    [f coll]
    (let [s (java.util.HashSet.)] ; instead of #{}
      (lfor [x coll
             :let [id (f x)]
             :when (not (.contains s id))]
       (do (.add s id)
           x)))))

; (defn plicates
;   {:attribution "Alex Gunnarson"}
;   [oper n]
;   (fn [coll]
;      (-> (fn [elem]
;            (-> (filter+ (fn-eq? elem) coll)
;                count
;                (oper n))) ; duplicates? keep them
;          (filter+ coll)
;          distinct+
;          redv)))

(defprotocol Interpose
  (interpose+- [coll elem]))

; TODO: make a reducers version of coll/elem
(extend-protocol Interpose
  #?(:clj String :cljs string)
    (interpose+- [coll elem]
      (str/join elem coll))
  #?(:clj Object :cljs default)
    (interpose+- [coll elem]
      (interpose elem coll)))

(defn interpose+
  {:todo ["|definline| this"]}
  [elem coll] (interpose+- coll elem))

(defn linterleave-all
  "Analogy: partition:partition-all :: interleave:interleave-all"
  {:attribution "prismatic/plumbing"}
  [& colls]
  (lazy-seq
   ((fn helper [seqs]
      (when (seq seqs)
        (concat (map first seqs)
                (lazy-seq (helper (keep next seqs))))))
    (keep seq colls))))

; (defn interleave+ [& args] ; 4.307220 ms vs. 1.424329 ms normal interleave :/ because of zipvec...
;   (reduce
;     (fn ([]      [])
;         ([a]     (conj [] a))
;         ([a b]   (conj    a b)) 
;         ([a b c] (conj    a b c)))
;     (apply zipvec+ args)))

#?(:clj
  (defn frequencies+
    "Like clojure.core/frequencies, but faster.
     Uses Java's equal/hash, so may produce incorrect results if
     given values that are = but not .equal"
    {:attribution "prismatic.plumbing"
     :performance "4.048617 ms vs. |frequencies| 6.341091 ms"}
    [xs]
    (let [res (java.util.HashMap.)]
      (doseq [x xs]
        (->> (.get res x)
             (or 0)
             int
             unchecked-inc)
             (.put res x))
      (into {} res))))
;___________________________________________________________________________________________________________________________________
;=================================================={         GROUPING         }=====================================================
;=================================================={     group, aggregate     }=====================================================
(defn ^Delay group-merge-with+
  {:attribution "Alex Gunnarson"
   :todo ["Can probably make the |merge| process parallel."]
   :in [":a"
        "(fn [k v1 v2] v1)"
        "[{:a 1 :b 2} {:a 1 :b 5} {:a 5 :b 65}]"]
   :out "[{:b 65, :a 5} {:a 1, :b 2}]"}
  [group-by-f merge-with-f coll]
  (let [merge-like-elems 
         (fn [grouped-elems]
           (if (single? grouped-elems)
               grouped-elems
               (reduce
                 (fn [ret elem]
                   (merge-with+ merge-with-f ret elem))
                 (first grouped-elems)
                 (rest  grouped-elems))))]
    (->> coll
         (group-by+ group-by-f)
         (map+ val+) ; [[{}] [{}{}{}]]
         (map+ merge-like-elems)
         flatten+)))

(defn merge-left 
  ([^Key alert-level]
    (fn [k v1 v2]
      (when (not= v1 v2)
        (log/pr alert-level
          "Values do not match for merge key"
          (str (str/squote k) ":")
          (str/squote v1) "|" (str/squote v2)))
      v1))
  ([k v1 v2] v1))

(defn merge-right
  ([^Key alert-level]
    (fn [k v1 v2]
      (when (not= v1 v2)
        (log/pr alert-level
          "Values do not match for merge key"
          (str (str/squote k) ":")
          (str/squote v1) "|" (str/squote v2)))
      v1))
  ([k v1 v2] v2))

(defn ^Delay first-uniques-by+ [k coll]
  (->> coll
       (group-by+ k)
       (map+ (update-val+ first))))
;___________________________________________________________________________________________________________________________________
;=================================================={     TREE STRUCTURES      }=====================================================
;=================================================={                          }=====================================================
; Stuart Sierra: "In my tests, clojure.walk2 is about 2 times faster than clojure.walk."

(defprotocol ^{:added "1.6"} Walkable
  (^{:added "1.6"
     :attribution "Stuart Sierra, stuartsierra/clojure.walk2"}
     walk2 [coll f]
    "If coll is a collection, applies f to each element of the collection
     and returns a collection of the results, of the same type and order
     as coll. If coll is not a collection, returns it unchanged. \"Same
     type\" means a type with the same behavior. For example, a hash-map
     may be returned as an array-map, but a a sorted-map will be returned
     as a sorted-map with the same comparator."))

#?(:clj
  (extend-protocol Walkable
    nil
      (walk2 [coll f] nil)
    java.lang.Object  ; default: not a collection
      (walk2 [x f] x)
    clojure.lang.IMapEntry
      (walk2 [coll f]
        (clojure.lang.MapEntry. (f (.key coll)) (f (.val coll))))
    clojure.lang.ISeq  ; generic sequence fallback
      (walk2 [coll f]
        (map f coll))
    clojure.lang.PersistentList  ; special case to preserve type
      (walk2 [coll f]
        (apply list (map f coll)))
    clojure.lang.PersistentList$EmptyList  ; special case to preserve type
      (walk2 [coll f] '())
    clojure.lang.IRecord  ; any defrecord
      (walk2 [coll f]
        (reduce (fn [r x] (conj r (f x))) coll coll))))

(defn- walk2-transient [coll f]
  ;; `transient` discards metadata as of Clojure 1.6.0
  (persistent!
    (reduce
      (fn [r x] (conj! r (f x)))
      (transient (empty coll)) coll)))

;; Persistent collections that support transients
#?(:clj
  (doseq [type [clojure.lang.PersistentArrayMap
                clojure.lang.PersistentHashMap
                clojure.lang.PersistentHashSet
                clojure.lang.PersistentVector]]
    (extend type Walkable {:walk2 walk2-transient})))

(defn- walk2-default [coll f]
  (reduce
    (fn [r x] (conj r (f x)))
    (empty coll) coll))

;; Persistent collections that don't support transients
#?(:clj
  (doseq [type [clojure.lang.PersistentQueue
                clojure.lang.PersistentStructMap
                clojure.lang.PersistentTreeMap
                clojure.lang.PersistentTreeSet]]
    (extend type Walkable {:walk2 walk2-default})))

(defn walk
  "Traverses form, an arbitrary data structure.  inner and outer are
  functions.  Applies inner to each element of form, building up a
  data structure of the same type, then applies outer to the result.
  Recognizes all Clojure data structures. Consumes seqs as with doall."
  {:attribution "Stuart Sierra, stuartsierra/clojure.walk2"}
  [inner outer form]
  (outer (walk2 form inner)))

(defn postwalk
  "Performs a depth-first, post-order traversal of form.  Calls f on
  each sub-form, uses f's return value in place of the original.
  Recognizes all Clojure data structures. Consumes seqs as with doall."
  {:attribution "Stuart Sierra, stuartsierra/clojure.walk2"}
  [f form]
  (walk (partial postwalk f) f form))

(defn prewalk
  "Like postwalk, but does pre-order traversal."
  {:attribution "Stuart Sierra, stuartsierra/clojure.walk2"}
  [f form]
  (walk (partial prewalk f) identity (f form)))

; COMBINE THESE TWO
(defn keywordify-keys
  "Recursively transforms all map keys from keywords to strings."
  {:attribution "Stuart Sierra, stuartsierra/clojure.walk2"
   :contributors #{"Alex Gunnarson"}}
  [^Map m]
  (let [stringify-key
         (fn [[k v]]
           (if (string? k)
               (map-entry (keyword? k) v)
               (map-entry k v)))]
    ; only apply to maps
    (postwalk
      (whenf*n map? (fn->> (map+ stringify-key) redm))
      m)))

; COMBINE THESE TWO
(defn stringify-keys
  "Recursively transforms all map keys from keywords to strings."
  {:attribution "Stuart Sierra, stuartsierra/clojure.walk2"
   :contributors #{"Alex Gunnarson"}}
  [^Map m]
  (let [stringify-key
         (fn [[k v]]
           (if (keyword? k)
               (map-entry (name k) v)
               (map-entry k v)))]
    ; only apply to maps
    (postwalk
      (whenf*n map? (fn->> (map+ stringify-key) redm))
      m)))

(defn prewalk-replace
  "Recursively transforms form by replacing keys in smap with their
  values.  Like clojure/replace but works on any data structure.  Does
  replacement at the root of the tree first."
  {:attribution "Stuart Sierra, stuartsierra/clojure.walk2"}
  [smap form]
  (prewalk (whenf*n (f*n in? smap) smap) form))

(defn postwalk-replace
  "Recursively transforms form by replacing keys in smap with their
  values.  Like clojure/replace but works on any data structure.  Does
  replacement at the leaves of the tree first."
  {:attribution "Stuart Sierra, stuartsierra/clojure.walk2"}
  [smap form]
  (postwalk (whenf*n (f*n in? smap) smap) form))

(defn tree-filter
  "Like |filter|, but performs a |postwalk| on a treelike structure @tree, putting in a new vector
   only the elements for which @pred is true."
  {:attribution "Alex Gunnarson"}
  [^Fn pred tree]
  (let [results (transient [])]
    (postwalk
      (whenf*n pred
        (fn->> (with->> conj! results))) ; keep it the same
      tree)
    (persistent! results)))

(defn- sort-parts
  "Lazy, tail-recursive, incremental quicksort. Works against
   and creates partitions based on the pivot, defined as 'work'."
  {:attribution "The Joy of Clojure, 2nd ed."}
  [work]
  (lazy-seq
    (loop [[part & parts] work]
      (if-let [[pivot & xs] (seq part)]
        (let [smaller? #(< % pivot)]
          (recur (list*
                  (filter smaller? xs)
                  pivot
                  (remove smaller? xs)
                  parts)))
        (when-let [[x & parts] parts]
          (cons x (sort-parts parts)))))))

(defn lsort
  "Lazy 'quick'-sorting"
  {:attribution "The Joy of Clojure, 2nd ed."}
  [elems]
  (sort-parts (list elems))) 
;___________________________________________________________________________________________________________________________________
;=================================================={   COLLECTIONS CREATION   }=====================================================
;=================================================={                          }=====================================================
; ; DEPRECATED; Created while learning Scheme, in which a loop-recur kind of form is the norm 
; (defn coll-struct
;   "Usage:
;   (lib/coll-struct :size 5 :in [] :element {})
;   => [{} {} {} {} {}]
;   (lib/coll-struct :size 5 :in {} :elem-func #(hash-map (keyword (str %)) %))
;   => {:4 4, :3 3, :2 2, :1 1, :0 0}"
;   [& {:keys [in size element elem-func]
;       :or   [elem-func identity]
;       :as   args}]
;   (let [elem-func-f
;          (cond (nnil? element)   (fn [n] element)
;                (nnil? elem-func) elem-func)]
;     (loop [n 0 coll-n in]
;       (if (= n size)
;           coll-n
;           (recur (inc n) (conj coll-n (elem-func-f n)))))))
; ; DEPRECATED; Created while learning Scheme, in which a loop-recur kind of form is the norm 
; (defn accumulate
;   ^{:usage "(accumulate :decum [1 2 3] :accum () :func #(conj %1 (inc %2)))
;             => (4 3 2)"}
;   [& {:keys [decum accum func]
;       :as args}]
;   (loop [[list-n-0 & list-r :as list-n] decum
;          list-f accum]
;     (if (empty? list-n)
;         list-f
;         (recur list-r
;                (func list-f list-n-0)))))

nil
quantum.core.collections=> quantum.core.collections=> nil
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/vec
quantum.core.collections=> #'quantum.core.collections/into
quantum.core.collections=> #'quantum.core.collections/reduce
quantum.core.collections=> #'quantum.core.collections/reducei
quantum.core.collections=> #'quantum.core.collections/redv
quantum.core.collections=> #'quantum.core.collections/redm
quantum.core.collections=> #'quantum.core.collections/fold
quantum.core.collections=> #'quantum.core.collections/foldv
quantum.core.collections=> #'quantum.core.collections/foldm
quantum.core.collections=> #'quantum.core.collections/map+
quantum.core.collections=> #'quantum.core.collections/filter+
quantum.core.collections=> #'quantum.core.collections/lfilter
quantum.core.collections=> #'quantum.core.collections/remove+
quantum.core.collections=> #'quantum.core.collections/lremove
quantum.core.collections=> #'quantum.core.collections/take+
quantum.core.collections=> #'quantum.core.collections/take-while+
quantum.core.collections=> #'quantum.core.collections/drop+
quantum.core.collections=> #'quantum.core.collections/group-by+
quantum.core.collections=> #'quantum.core.collections/flatten+
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/for
quantum.core.collections=> {:line 5422, :column 9, :file "/private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj", :name for, :ns #object[clojure.lang.Namespace 0x2a0063a2 "quantum.core.collections"], :macro true}
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/lfor
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/doseq
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/doseqi
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/lasti
quantum.core.collections=> #'quantum.core.collections/index-of
quantum.core.collections=> #'quantum.core.collections/last-index-of
quantum.core.collections=> #'quantum.core.collections/count
quantum.core.collections=> #'quantum.core.collections/getr
quantum.core.collections=> #'quantum.core.collections/get
quantum.core.collections=> #'quantum.core.collections/gets
quantum.core.collections=> #'quantum.core.collections/getf
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/conjl
quantum.core.collections=> CompilerException java.lang.RuntimeException: Unable to resolve var: coll/conjr in this context, compiling:(/private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:5466:1) 
quantum.core.collections=> #'quantum.core.collections/pop
quantum.core.collections=> #'quantum.core.collections/popr
quantum.core.collections=> #'quantum.core.collections/popl
quantum.core.collections=> #'quantum.core.collections/peek
quantum.core.collections=> #'quantum.core.collections/first
quantum.core.collections=> #'quantum.core.collections/second
quantum.core.collections=> #'quantum.core.collections/third
quantum.core.collections=> #'quantum.core.collections/rest
quantum.core.collections=> #'quantum.core.collections/lrest
quantum.core.collections=> #'quantum.core.collections/butlast
quantum.core.collections=> #'quantum.core.collections/last
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/merge
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/merge-meta
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/frest
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/repeatedly-into
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/lrepeatedly
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/repeatedly
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/range+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/lrange
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/range
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/repeat
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/abs-difference
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:5556:15 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
#'quantum.core.collections/get-map-constructor
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/reduce-2
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/ffilter
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/ffilter+
quantum.core.collections=> quantum.core.collections=> Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:5602:3 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:5608:26 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
#'quantum.core.collections/ffilteri+
quantum.core.collections=> quantum.core.collections=> Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:5615:7 - call: public static boolean clojure.lang.Numbers.gt(long,java.lang.Object).
Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:5617:9 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:5624:7 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
#'quantum.core.collections/filteri+
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:5637:7 - call: public static boolean clojure.lang.Numbers.gt(long,java.lang.Object).
Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:5639:9 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:5646:7 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
#'quantum.core.collections/indices-of+
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/takel+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/take-from+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/take-fromi+
quantum.core.collections=> quantum.core.collections=> Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:5681:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(java.lang.Object,java.lang.Object).
#'quantum.core.collections/take-afteri+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/take-untili+
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/takeri+
quantum.core.collections=> quantum.core.collections=> Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:5716:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
#'quantum.core.collections/taker-untili+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/take-while-not
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/dropl+
quantum.core.collections=> quantum.core.collections=> Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:5738:15 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_minus(java.lang.Object,java.lang.Object).
#'quantum.core.collections/dropr+
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/merge-keep-left
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/split-remove+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/kmap
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/select
quantum.core.collections=> quantum.core.collections=> Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:5785:3 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
#'quantum.core.collections/comparator-extreme-of
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/coll-if
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/seq-if
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/lseq
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/lseq+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/unchunk
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/key+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/val+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/fkey+
quantum.core.collections=> #'quantum.core.collections/fval+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/up-val
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/get-in+
quantum.core.collections=> #'quantum.core.collections/reverse+
quantum.core.collections=> #'quantum.core.collections/single?
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/contains?
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/merge-with+
quantum.core.collections=> quantum.core.collections=> Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:5973:24 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(java.lang.Object,java.lang.Object).
#'quantum.core.collections/merge-vals-left
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/concat++
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> Contains?
quantum.core.collections=> nil
quantum.core.collections=> quantum.core.collections=> nil
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/in?
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/subs?
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/select-keys-large
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/select-keys-small
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/select-keys-delay
quantum.core.collections=> quantum.core.collections=> Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:6091:20 - call: public static boolean clojure.lang.Numbers.gt(java.lang.Object,long).
#'quantum.core.collections/select-keys+
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/get-keys
quantum.core.collections=> #'quantum.core.collections/get-key
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/filter-keys+
quantum.core.collections=> #'quantum.core.collections/remove-keys+
quantum.core.collections=> #'quantum.core.collections/filter-vals+
quantum.core.collections=> #'quantum.core.collections/remove-vals+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/vals+
quantum.core.collections=> #'quantum.core.collections/keys+
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:6154:28 - call: public static java.lang.Number clojure.lang.Numbers.divide(java.lang.Object,java.lang.Object).
Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:6155:16 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
#'quantum.core.collections/slice
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/split
quantum.core.collections=> #'quantum.core.collections/split-with-v+
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:6216:33 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:6216:33 - call: public static boolean clojure.lang.Numbers.lt(java.lang.Object,java.lang.Object).
Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:6224:35 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
#'quantum.core.collections/extend-coll-to
quantum.core.collections=> #'quantum.core.collections/assoc+
quantum.core.collections=> #'quantum.core.collections/update+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/updates+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/update-key+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/update-val+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/mapmux
quantum.core.collections=> #'quantum.core.collections/record->map
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/update-in!
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/update-in+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/assoc-in+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/assoc-in!
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/assocs-in+
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:6359:33 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
#'quantum.core.collections/dissoc+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/dissocs+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/dissoc-if+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/dissoc-in+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/updates-in+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/re-assoc+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/re-assocs+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/select-as+
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/distinct-by-java
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> Interpose
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> nil
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/interpose+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/linterleave-all
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> Reflection warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:6506:14 - call to method put on java.util.HashMap can't be resolved (no such method).
#'quantum.core.collections/frequencies+
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/group-merge-with+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/merge-left
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/merge-right
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/first-uniques-by+
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> Walkable
quantum.core.collections=> quantum.core.collections=> nil
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/walk2-transient
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> nil
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/walk2-default
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> nil
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/walk
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/postwalk
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/prewalk
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/keywordify-keys
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/stringify-keys
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/prewalk-replace
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/postwalk-replace
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/tree-filter
quantum.core.collections=> quantum.core.collections=> Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:6716:25 - call: public static boolean clojure.lang.Numbers.lt(java.lang.Object,java.lang.Object).
#'quantum.core.collections/sort-parts
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/lsort
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> 
quantum.core.collections=> (ns test
  (:require
    [clojure.tools.namespace.repl :refer [refresh refresh-all set-refresh-dirs]]
    [quantum.core.ns :as ns]))

;(ns/require :clj :lib)
(ns/require-all *ns* :clj :lib)

(defn init! [] (println "Hey :)"))
; (refresh-all :after 'test/init!)

(in-ns 'clojure.tools.namespace.parse)
(defn read-ns-decl
  "Attempts to read a (ns ...) declaration from a
  java.io.PushbackReader, and returns the unevaluated form. Returns
  the first top-level ns form found. Returns nil if read fails or if a
  ns declaration cannot be found. Note that read can execute code
  (controlled by *read-eval*), and as such should be used only with
  trusted sources."
  [rdr]
  {:pre [(instance? java.io.PushbackReader rdr)]}
  (try
   (loop []
     (let [form (doto (read {:read-cond :allow} rdr) str)]  ; str forces errors, see TNS-1
       (if (ns-decl? form)
         form
         (recur))))
   (catch Exception e nil)))
(in-ns 'test)
nil
test=> test=> test=> IllegalStateException Alias coll already exists in namespace test, aliasing quantum.core.collections  clojure.lang.Namespace.addAlias (Namespace.java:224)
test=> test=> #'test/init!
test=> test=> test=> #object[clojure.lang.Namespace 0x2f00f851 "clojure.tools.namespace.parse"]
clojure.tools.namespace.parse=> #'clojure.tools.namespace.parse/read-ns-decl
clojure.tools.namespace.parse=> #object[clojure.lang.Namespace 0x6ec53a5 "test"]
test=> (refresh)
:reloading (quantum.core.collections quantum.core.print)
:error-while-loading quantum.core.collections
IllegalStateException error? already refers to: #'quantum.core.type/error? in namespace: test  clojure.lang.Namespace.warnOrFailOnReplace (Namespace.java:88)
test=> 
test=> (ns test
  (:require
    [clojure.tools.namespace.repl :refer [refresh refresh-all set-refresh-dirs]]
    [quantum.core.ns :as ns]))

;(ns/require :clj :lib)
(ns/require-all *ns* :clj :lib)

(defn init! [] (println "Hey :)"))
nil
test=> test=> test=> CompilerException java.lang.Exception: namespace 'quantum.core.collections' not found, compiling:(/private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:6801:1) 
test=> test=> #'test/init!
test=> 
test=> #?(:clj
  (ns quantum.core.collections
    (:refer-clojure :exclude
      [for doseq contains? repeat repeatedly range merge count vec reduce into
       first second rest last butlast get pop peek])))

(ns
  ^{:doc
      "Various collections functions.

       Includes better versions of the following than clojure.core:

       for, doseq, repeat, repeatedly, range, merge,
       count, vec, reduce, into, first, second, rest,
       last, butlast, get, pop, peek ...

       and more.

       Many of them are aliased from other namespaces like
       quantum.core.collections.core, or quantum.core.reducers."
    :attribution "Alex Gunnarson"}
  quantum.core.collections
  (:refer-clojure :exclude
    [for doseq contains?
     repeat repeatedly
     range
     merge
     count
     vec
     reduce into
     first second rest last butlast get pop peek])
  (:require
    [quantum.core.ns :as ns :refer
      #?(:clj  [alias-ns defalias]
         :cljs [Exception IllegalArgumentException
                Nil Bool Num ExactNum Int Decimal Key Vec Set
                ArrList TreeMap LSeq Regex Editable Transient Queue Map])
      #?@(:cljs [:refer-macros [defalias]])]
    [quantum.core.logic :as logic :refer
      #?@(:clj  [[splice-or fn-and fn-or fn-not ifn if*n whenc whenf whenf*n whencf*n
                  condf condfc condf*n nnil? nempty? fn= fn-eq? any?]]
          :cljs [[splice-or fn-and fn-or fn-not nnil? nempty? fn= fn-eq? any?]
                 :refer-macros
                 [ifn if*n whenc whenf whenf*n whencf*n condf condfc condf*n]])]
    [quantum.core.type     :as type :refer
      [#?(:clj bigint?) #?(:cljs class) instance+? array-list? boolean? double? map-entry?
       sorted-map? queue? lseq? coll+? pattern? regex? editable?
       transient? #?(:clj should-transientize?) name-from-class #?(:clj arr-types)]
      #?@(:cljs [:refer-macros [should-transientize?]])]
    [quantum.core.numeric          :as num   :refer [greatest least]               ]
    [quantum.core.data.vector      :as vec   :refer [vector+? subvec+ catvec]]
    [quantum.core.data.map         :as map   :refer [#?(:clj ordered-map) map-entry]]
    [quantum.core.data.set         :as set   :refer [#?(:clj ordered-set)]          ]
    [quantum.core.collections.core :as coll                                        ]
    [quantum.core.log              :as log                                         ]
    [quantum.core.error            :as err   #?@(:clj [:refer [try+ throw+]])      ]
    [quantum.core.function :as fn :refer
      #?@(:clj  [[compr *fn f*n fn* unary zeroid fn->> fn-> <- with->>]]
          :cljs [[compr *fn f*n fn* unary zeroid]
                 :refer-macros
                 [fn->> fn-> <- with->> mfn]])]
    [quantum.core.reducers :as red]
    [quantum.core.string   :as str]
    [quantum.core.loops    :as loops]
    #?(:clj [clojure.pprint :refer [pprint]])
    [clojure.walk :as walk]
    [#?(:clj clojure.core.async :cljs cljs.core.async) :as async :refer
      [#?@(:clj [>!! <!! thread]) close! chan]]
    #?(:clj [clj-time.core]))
  #?(:cljs (:require-macros [quantum.core.loops :as loops :refer [for reducei]]))
  #?@(:clj
      [(:import
        clojure.core.Vec
        java.util.ArrayList
        (clojure.lang Keyword MapEntry Delay)
        (quantum.core.ns
          Nil Bool Num ExactNum Int Decimal Key Set
          Fn ArrList TreeMap LSeq Regex Editable Transient Queue Map))
       (:gen-class)]))

(defalias vec         red/vec+       )    
(defalias into        red/into+      )    
(defalias reduce      red/reduce     )
#?(:clj (defalias reducei loops/reducei  ))
(defalias redv        red/fold+      )
(defalias redm        red/reducem+   )
(defalias fold        red/fold+      ) ; only certain arities
(defalias foldv       red/foldp+     ) ; only certain arities
(defalias foldm       red/foldm+     ) 
(defalias map+        red/map+       )
(defalias filter+     red/filter+    )
(defalias lfilter     filter         )
(defalias remove+     red/remove+    )
(defalias lremove     remove         )
(defalias take+       red/take+      )
(defalias take-while+ red/take-while+)
(defalias drop+       red/drop+      )
(defalias group-by+   red/group-by+  )
(defalias flatten+    red/flatten+   )

; ; ====== LOOPS ======
;(def cljs-for+ (var red/for+))
; (defalias for+   #?(:clj red/for+         :cljs red/for+))
; (alter-meta! (var for+) assoc :macro true)

; (def cljs-for (var loops/for)) ; doesn't work because not a var
; (def cljs-for (mfn loops/for)) ; doesn't work because no |eval|
#?(:clj (defalias for loops/for))
#?(:clj (alter-meta! (var for) assoc :macro true))

;(def cljs-lfor (var clojure.core/for))
;(defalias lfor   #?(:clj clojure.core/for :cljs cljs-lfor))
;#?(:clj (defalias lfor clojure.core/for))
#?(:clj (defmacro lfor [& args] `(clojure.core/for ~@args)))

;(def cljs-doseq (var loops/doseq))
;(defalias doseq  #?(:clj loops/doseq      :cljs cljs-doseq))
#?(:clj (defmacro doseq [& args] `(loops/doseq ~@args)))

;(def cljs-doseqi (var loops/doseqi))
;(defalias doseqi #?(:clj loops/doseqi     :cljs cljs-doseqi))
#?(:clj (defmacro doseqi [& args] `(loops/doseqi ~@args)))

#?(:cljs
  (defn kv+
    "For some reason ClojureScript reducers have an issue and it's terrible... so use it like so:
     (map+ (compr kv+ <myfunc>) _)
     |reduce| doesn't have this problem."
    {:todo ["Eliminate the need for this."]}
    ([obj] obj)
    ([k v] k)))

; ; ====== COLLECTIONS ======

; ; TODO Don't redefine these vars
; #?(:cljs (defn map+    [f coll] (red/map+    (compr kv+ f) coll)))
; #?(:cljs (defn filter+ [f coll] (red/filter+ (compr kv+ f) coll)))
; #?(:cljs (defn remove+ [f coll] (red/remove+ (compr kv+ f) coll)))


(def      lasti         coll/lasti         )
(def      index-of      coll/index-of+     )
(def      last-index-of coll/last-index-of+)
(def      count         coll/count+        )
(def      getr          coll/getr+         )
(def      get           coll/get+          )
(def      gets          coll/gets+         )
(def      getf          coll/getf+         )

; If not |defalias|ed, "ArityException Wrong number of args (2) passed to: core/eval36441/fn--36457/G--36432--36466"
(defalias conjl         coll/conjl         )
(defalias conjr         coll/conjr         )
(def      pop           coll/pop+          )
(def      popr          coll/popr+         )
(def      popl          coll/popl+         )
(def      peek          coll/peek+         )
(def      first         coll/first+        )
(def      second        coll/second+       )
(def      third         coll/third         )
(def      rest          coll/rest+         )
(defalias lrest        #?(:clj  clojure.core/rest
                          :cljs cljs.core.rest    ))
(def      butlast       coll/butlast+      )
(def      last          coll/last+         )

(defalias merge map/merge+)

(defn merge-meta [sym-0 sym-f]
  (with-meta sym-0 (meta sym-f)))

(def frest (fn-> rest first))

; ===== REPEATEDLY =====

#?(:clj
(defmacro repeatedly-into
  [coll n & body]
  `(let [coll# ~coll
         n#    ~n]
     (if (should-transientize? coll#)
         (loop [v# (transient coll#) idx# 0]
           (if (>= idx# n#)
               (persistent! v#)
               (recur (conj! v# ~@body)
                      (inc idx#))))
         (loop [v#   coll# idx# 0]
           (if (>= idx# n#)
               v#
               (recur (conj v# ~@body)
                      (inc idx#))))))))

(def lrepeatedly clojure.core/repeatedly)

#?(:clj
(defmacro repeatedly
  "Like |clojure.core/.repeatedly| but (significantly) faster and returns a vector."
  ; ([n f]
  ;   `(repeatedly-into* [] ~n ~arg1 ~@body))
  ([n arg1 & body]
    `(repeatedly-into* [] ~n ~arg1 ~@body))))

; ===== RANGE =====

(#?(:clj defalias :cljs def) range+ red/range+)

(defalias lrange clojure.core/range)

(defn range
  ([]    (lrange))
  ([a]   (-> (range+ a)   redv))
  ([a b] (-> (range+ a b) redv)))

; ===== REPEAT =====

(defn repeat
  ([obj]   (clojure.core/repeat obj))
  ([n obj] (for [i (range n)] obj)))

; ===== ....

(defn ^Set abs-difference 
  "Returns the absolute difference between a and b.
   That is, (a diff b) union (b diff a)."
  {:todo ["Probably a better name for this."]}
  [a b]
  (set/union
    (set/difference a b)
    (set/difference b a)))

; ; a better merge?
; ; a better merge-with?
#?(:clj
  (defn get-map-constructor
    "Gets a record's map-constructor function via its class name."
    [rec]
    (let [^String class-name-0
            (if (class? rec)
                (-> rec str)
                (-> rec class str))
          ^String class-name
            (getr class-name-0
              (-> class-name-0 (last-index-of ".") inc)
              (-> class-name-0 count))
          ^Fn map-constructor-fn
            (->> class-name (str "map->") symbol eval)]
      map-constructor-fn)))

; ================================================ REDUCE ================================================

(defn reduce-2
  "Like |reduce|, but reduces over two items in a collection at a time.

   Its function @func must take three arguments:
   1) The accumulated return value of the reduction function
   2) The                next item in the collection being reduced over
   3) The item after the next item in the collection being reduced over"
  {:attribution "Alex Gunnarson"}
  [func init coll] ; not actually implementing of CollReduce... so not as fast...
  (loop [ret init coll-n coll]
    (if (empty? coll-n)
        ret
        (recur (func ret (first coll-n) (second coll-n))
               (-> coll-n rest rest)))))

; ================================================ FILTER ================================================

(defn ffilter
  "Returns the first result of a |filter| operation.
   Uses lazy |filter| so as to do it in the fastest possible way."
   [^Fn filter-fn coll]
   (->> coll (filter filter-fn) first))

(defn ffilter+
  {:todo ["Use a delayed reduction as the base!"]}
  [^Fn pred coll]
  (reduce
    (fn [ret elem-n]
      (when (pred elem-n)
        (reduced elem-n)))
    nil
    coll))

(defn ^MapEntry ffilteri+
  {:todo ["Use a delayed reduction as the base!" "Allow parallelization"]
   :in   ['(ffilteri+ fn-eq? "4") '["a" "d" "t" "4" "10"]]
   :out  ["4" "3"]}
  [^Fn pred coll]
  (reducei
    (fn [ret elem-n index-n]
      (if (pred elem-n)
          (reduced (map-entry index-n elem-n))
          (if (= index-n (lasti coll)) ; If it's looked through all elements and they don't match,
              (map-entry -1 nil)
              (map-entry (inc index-n) nil))))
    (map-entry 0 nil)
    coll))

(defn filteri+
  {:todo ["Use reducers"]}
  [pred coll]
  (if (should-transientize? coll)
      (persistent!
        (reducei
          (fn [ret elem-n n]
            (if (pred elem-n)
                (conj! ret (map-entry n elem-n))
                ret))
          (transient [])
          coll))
      (reducei
        (fn [ret elem-n n]
          (if (pred elem-n)
              (conj ret (map-entry n elem-n))
              ret))
        []
        coll)))

; ================================================ INDEX-OF ================================================

(defn indices-of+
  {:todo ["Make parallizeable"]}
  [coll elem-0]
  (if (should-transientize? coll)
      (persistent!
        (reducei
          (fn [ret elem-n n]
            (if (= elem-0 elem-n)
                (conj! ret n)
                ret))
          (transient [])
          coll))
      (reducei
        (fn [ret elem-n n]
          (if (= elem-0 elem-n)
              (conj ret n)
              ret))
        []
        coll)))

; ================================================ TAKE ================================================

; ============ TAKE-LEFT ============

(defn takel+ [coll n]
  (getr coll 0 n))

(defn take-from+
  "Take starting at and including index n."
  {:todo ["Use reducers"]}
  [obj ^Int n]
  (getr obj n (count obj)))

(defn take-fromi+
  {:todo ["Use reducers"]
   :in  ["asdbsd" "db"]
   :out "dbsd"}
  [obj sub-obj]
  (take-from+ obj (index-of obj sub-obj)))

(defn take-afteri+
  {:todo ["Use reducers"]
   :in  ["asdbsd" "db"]
   :out "dbsd"}
  [obj sub-obj]
  (take-from+
    obj
    (+ (index-of obj sub-obj)
       (count sub-obj))))

(defn take-untili+ [obj sub-obj]
  (getr obj 0 (index-of obj sub-obj)))

; ============ TAKE-RIGHT ============

(defn takeri+
  "Take up to and including right index of."
  {:todo "Combine code with /taker-untili+/"
   :in  "(untilri+ 'abcdefg' 'c')"
   :out "'defg'"}
  [super sub]
  (let [index-r-0 (last-index-of super sub)
        index-r
          ; (whenc (last-index-of super sub) (fn= -1) ; Throws a strange undefined error in ClojureScript... ugh...
          ;   (throw (str "Index of" (squote sub) "not found.")))
          (if (= -1 index-r-0)
              (throw (str "Index of" (str/squote sub) "not found."))
              index-r-0)]
    (getr super
      index-r
      (-> super lasti))))

(defn taker-untili+
  "Until right index of."
  {:todo "Combine code with /takeri/"
   :in  ["abcdefg" "c"]
   :out "'defg'"}
  [super sub]
  (let [index-r
          (whenc (last-index-of super sub) (fn= -1)
            (throw (str "Index of" (str/squote sub) "not found.")))])
  (getr super
    (inc (last-index-of super sub))
    (-> super lasti)))

#?(:clj
  (defn take-while-not
    {:attribution "Alex Gunnarson"
     :todo ["Rewrite this"]}
    [^String s ^String elem]
    (getr s 0
      (whenc (index-of s elem) (fn-eq? -1)
        (count s)))))

; ================================================ DROP ================================================

(defn dropl+
  {:attribution "Alex Gunnarson"}
  [obj ^Int n]
  (getr obj n (count obj)))

(defn dropr+
  {:attribution "Alex Gunnarson"}
  [obj n]
  (getr obj 0 (- (lasti obj) n)))

; ================================================ MERGE ================================================

(defn merge-keep-left [a b] (merge b a))
              
(defn split-remove+
  {:todo ["Slightly inefficient  two /index-of/ implicit."]}
  [coll split-at-obj]
  [(take-untili+ coll split-at-obj)
   (take-afteri+ coll split-at-obj)])

#?(:clj
(defmacro kmap [& ks]
 `(zipmap (map keyword (quote ~ks)) (list ~@ks))))

(defn select
  "Applies a list of functions, @fns, separately to an object, @coll.
   A good use case is returning values from an associative structure with keys as @fns.
   Returns a vector of the results."
  ^{:attribution "Alex Gunnarson"
    :usage "(select {:a 1 :b [3]} :a (compr :b 0)) => [1 3]"}
  [coll & fns]
  ((apply juxt fns) coll))

(defn comparator-extreme-of
  "For compare-fns that don't have enough arity to do, say,
   |(apply time/latest [date1 date2 date3])|.

   Gets the most \"extreme\" element in collection @coll,
   \"extreme\" being defined on the @compare-fn.

   In the case of |time/latest|, it would return the latest
   DateTime in a collection.

   In the case of |>| (greater than), it would return the
   greatest element in the collection:

   (comparator-extreme-of [1 2 3] (fn [a b] (if (> a b) a b)) )
   :: 3

   |(fn [a b] (if (> a b) a b))| is the same thing as
   |(choice-comparator >)|."
  {:todo ["Rename this function."
          "HOW DOES THIS HAVE ANY RELEVANCE?"
          "Possibly belongs in a different namespace"]}
  [coll ^Fn compare-fn]
  (reducei
    (fn [ret elem n]
      (if (= n 0)
          elem
          (compare-fn ret elem)))
    nil
    coll))

(defn coll-if [obj]
  (whenf obj (fn-not coll?) vector))

(defn seq-if [obj]
  (condf obj
    (fn-or seq? nil?) identity
    coll?             seq
    :else             list))
;___________________________________________________________________________________________________________________________________
;=================================================={         LAZY SEQS        }=====================================================
;=================================================={                          }=====================================================
#?(:clj (defalias lseq lazy-seq))

#?(:clj
  (def lseq+
    (condf*n
      (fn-or seq? nil? coll?) #(lseq %) ; not |partial|, because can't take value of a macro
      :else (fn-> list lseq first))))

(defn unchunk
  "Takes a seqable and returns a lazy sequence that
   is maximally lazy and doesn't realize elements due to either
   chunking or apply.

   Useful when you don't want chunking, for instance,
   (first awesome-website? (map slurp <a-bunch-of-urls>))
   may slurp up to 31 unneed webpages, whereas
   (first awesome-website? (map slurp (unchunk <a-bunch-of-urls>)))
   is guaranteed to stop slurping after the first awesome website.

  Taken from http://stackoverflow.com/questions/3407876/how-do-i-avoid-clojures-chunking-behavior-for-lazy-seqs-that-i-want-to-short-ci"
  {:attribution "prismatic.plumbing"}
  [s]
  (when (seq s)
    (cons (first s)
          (lseq (s rest unchunk)))))
;___________________________________________________________________________________________________________________________________
;=================================================={  POSITION IN COLLECTION  }=====================================================
;=================================================={ first, rest, nth, get ...}=====================================================
; (defn- nth-red
;   "|nth| implemented in terms of |reduce|."
;   {:deprecated  true
;    :attribution "Alex Gunnarson"
;    :performance "Twice as slow as |nth|"}
;   [coll n]
;   (let [nn (volatile! 0)]
;     (->> coll
;          (reduce
;            (fn
;              ([ret elem]
;               (if (= n @nn)
;                   (reduced elem)
;                   (do (vswap! nn inc) ret)))
;              ([ret k v]
;                (if (= n @nn)
;                    (reduced [k v])
;                    (do (vswap! nn inc) ret))))
;            []))))

(defn key+
  "Like |key| but more robust."
  ^{:attribution "Alex Gunnarson"
    :todo ["Determine which objects are |key| able, 
            i.e., are associative."]}
  ([obj] 
    (#?(:clj try+ :cljs try)
      (ifn obj vector? first key)
      (catch #?(:clj Object :cljs js/Error) _
        (println "Error in key+ with obj:" (class obj)) nil)))
  ([k v] k)) ; For use with kv-reduce

(defn val+
  "Like |val| but more robust."
  ^{:attribution "Alex Gunnarson"}
  ([obj]
    (#?(:clj try+ :cljs try)
      (ifn obj vector? second key)
      (catch #?(:clj Object :cljs js/Error) _ nil)))
  ([k v] v)) ; For use with kv-reduce

(defn fkey+ [m]
  (-> m first key+))
(defn fval+ [m]
  (-> m first val+))

(defn up-val
  {:in '[{:a "ABC" :b 123} :a]
   :out '{"ABC" {:b 123}}
   :todo ["hash-map creation inefficient ATM"]}
  [^Map m k]
  (hash-map
    (get m k)
    (-> m (dissoc k))))

#?(:cljs
  (defn rename-keys [m-0 rename-m]
    (reduce
      (fn [ret k-0 k-f]
        (-> ret
            (assoc  k-f (get ret k-0))
            (dissoc k-0)))
      m-0
      rename-m)))

; ; for /subseq/, the coll must be a sorted collection (e.g., not a [], but rather a sorted-map or sorted-set)
; ; test(s) one of <, <=, > or >=

; ; /nthrest/
; ; (nthrest (range 10) 4) => (4 5 6 7 8 9)

; ; TODO: get-in from clojure, make it better
(defn get-in+ [coll [iden :as keys-0]] ; implement recursively
  (if (= iden identity)
      coll
      (get-in coll keys-0)))
(defn reverse+ [coll] ; what about arrays? some transient loop or something
  (ifn coll reversible? rseq reverse))
(def single?
  "Does coll have only one element?"
  (fn-and seq (fn-not next)))
;___________________________________________________________________________________________________________________________________
;=================================================={   ADDITIVE OPERATIONS    }=====================================================
;=================================================={    conj, cons, assoc     }=====================================================

;___________________________________________________________________________________________________________________________________
;=================================================={           MERGE          }=====================================================
;=================================================={      zipmap, zipvec      }=====================================================
; A better zipvec...
;(defn zipvec+ [& colls-0] ; (map vector [] [] [] []) ; 1.487238 ms for zipvec+ vs. 1.628670 ms for doall + map-vector.
;   (let [colls (->> colls-0 (map+ fold+) fold+)]
;     (for+ [n (range 0 (count (get colls 0)))] ; should be easy, because count will be O(1) with folded colls
;       (->> colls
;            (map (f*n get+ n)))))) ; get+ doesn't take long at all; also, apparently can't use map+ within for+...
;                                   ; 234.462665 ms if you realize them
; (defn zipfor- [& colls-0] ;  [[1 2 3] [4 5 6] [7 8 9]]
;   (let [colls (->> colls-0 (map+ fold+) fold+) ; nested /for/s, no
;         rng   (range 0 (-> colls count dec))]
;     (for   [n  rng] ; [[1 2 3] [4 5 6] [7 8 9]]
;       (for [cn rng] ; ((1 4 7) (4 5 6) ...)
;         (-> colls (get cn) (get n))))))
;; (zipvec-- [[1 2 3] [4 5 6] [7 8 9]])
;(defn zipvec-- [& colls-0] ; nested /map/s, no
;  (let [colls (vec+ colls-0)]
;    (map+
;      (fn [n]
;        (map+ (getf+ n) colls))
;      (range 0 (inc 2)))))

(declare contains?)

(defn merge-with+
  "Like merge-with, but the merging function takes the key being merged
   as the first argument"
   {:attribution  "prismatic.plumbing"
    :todo ["Make it not output HashMaps but preserve records"]
    :contributors ["Alex Gunnarson"]}
  [f & maps]
  (when (any? identity maps)
    (let [merge-entry
           (fn [m e]
             (let [k (key e) v (val e)]
               (if (contains? m k)
                 (assoc m k (f k (get m k) v))
                 (assoc m k v))))
          merge2
            (fn ([] {})
                ([m1 m2]
                 (reduce merge-entry (or m1 {}) (seq m2))))]
      (reduce merge2 maps))))

(defn ^Map merge-vals-left
  "Merges into the left map all elements of the right map whose
   keys are found in the left map.

   Combines using @f, a |merge-with| function."
  {:todo "Make a reducer, not just implement using |reduce| function."
   :in ['{:a {:aa 1}
          :b {:aa 3}}
         {:a {:aa 5}
          :c {:bb 4}}
         (fn [k v1 v2] (+ v1 v2))]
   :out '{:a {:aa 6}
          :b {:aa 3}}}
  [^Map left ^Map right ^Fn f]
  (persistent!
    (reduce
      (fn [left-f ^Key k-right ^Map v-right]
       ;(if ((fn-not contains?) left-f k-right) ; can't call |contains?| on a transient, apparently...
       ;    left-f)
       (let [^Map v-left
               (get left k-right)]
         (if (nil? v-left)
             left-f
             (let [^Map merged-vs
                   (merge-with+ f v-left v-right)]
               (assoc! left-f k-right merged-vs)))))
      (transient left)
      right)))
;___________________________________________________________________________________________________________________________________
;=================================================={      CONCATENATION       }=====================================================
;=================================================={ cat, fold, (map|con)cat  }=====================================================
(defn- concat++
  {:todo ["Needs optimization"]}
  ([coll]
    (try (reduce catvec coll)
      (catch Exception e (reduce (zeroid into []) coll))))
  ([coll & colls]
    (try (apply catvec coll colls)
      (catch Exception e (into [] coll colls)))))
;  Use original vectors until they are split. Subvec-orig below a certain range? Before the inflection point of log-n
;___________________________________________________________________________________________________________________________________
;=================================================={  FINDING IN COLLECTION   }=====================================================
;=================================================={  in?, index-of, find ... }=====================================================
(defprotocol Contains?
  (contains? [coll elem]))
(extend-protocol Contains?
  #?(:clj String :cljs string)
    (contains? [coll elem]
     #?(:clj  (.contains ^String coll ^String elem)
        :cljs (not= -1 (.indexOf coll elem))))
  Regex
    (contains? [coll elem]
      (nnil? (str/re-find+ elem coll)))
  #?(:clj Object :cljs default)
    (contains? [coll elem]
      (any? (fn-eq? elem) coll)))

(doseq [type (:map type/types)]
  (extend type Contains?
    {:contains? (fn [coll k] (clojure.core/contains? coll k))}))

(defn in?
  "The inverse of |contains?|"
  {:todo ["|definline| this?"]}
  [elem coll] (contains? coll elem))

; TODO limit it to only strings
(def subs? in?)

; ;-----------------------{       SELECT-KEYS       }-----------------------
(defn- ^Map select-keys-large
  "A transient and reducing version of clojure.core's |select-keys|."
  {:performance
    "45.3 ms vs. core's 60.29 ms on:
     (dotimes [_ 100000]
       (select-keys
         {:a 1 :b 2 :c 3 :d 4 :e 5 :f 6 :g 7}
         [:b :c :e]))).
     Performs much better on large set of keys."} 
  [keyseq m]
    (-> (transient {})
        (reduce
          (fn [ret k]
            (let [entry (. clojure.lang.RT (find m k))]
              (if entry
                  (conj! ret entry)
                  ret)))
          (seq keyseq))
        persistent!
        (with-meta (meta m))))

(defn- ^Map select-keys-small
  "A transient version of clojure.core's |select-keys|.

   Note: using a reducer here incurs the overhead of creating a
   function on the fly (can't extern it because of a closure).
   This is better for small set of keys."
  {:performance
    "39.09 ms vs. core's 60.29 ms on:
     (dotimes [_ 100000]
       (select-keys
         {:a 1 :b 2 :c 3 :d 4 :e 5 :f 6 :g 7}
         [:b :c :e])))"} 
  [keyseq m]
    (loop [ret (transient {}) keys (seq keyseq)]
      (if keys
        (let [entry (. clojure.lang.RT (find m (first keys)))]
          (recur
           (if entry
             (conj! ret entry)
             ret)
           (next keys)))
        (with-meta (persistent! ret) (meta m)))))

(defn- ^Delay select-keys-delay
  "Not as fast as select-keys with transients."
  {:todo ["FIX THIS"]}
  [ks m]
  (let [ks-set (into #{} ks)]
    (->> m
         (filter+
           (compr key+ (f*n in? ks-set))))))

(defn ^Map select-keys+
  {:todo
    ["Determine actual inflection point at which select-keys-large
      should be used over select-keys-small."]}
  [m ks]
  (if (-> ks count (> 10))
      (select-keys-small m ks)
      (select-keys-large m ks)))

; ;-----------------------{       CONTAINMENT       }-----------------------

; ; index-of-from [o val index-from] - index-of, starting at index-from
; (defn contains-or? [coll elems]
;   (apply-or (map (partial contains? coll) elems)))
(defn get-keys
  {:attribution "Alex Gunnarson"}
  [m obj]
  (persistent!
    (reduce
      (fn [ret k v]
        (if (identical? obj v)
            (conj! ret k)
            ret))
      (transient [])
      m)))
(defn get-key [m obj] (-> m (get-keys obj) first))
; ; /find/ Returns the map entry for key, or nil if key not present
; ; (find {:b 2 :a 1 :c 3} :a) => [:a 1]
; ; (select-keys {:a 1 :b 2} [:a :c]) =>  {:a 1}
; ; /frequencies/
; ; (frequencies ['a 'b 'a 'a])
; ; {a 3, b 1}
; ; /partition-by/
; ; splits the coll each time f returns a new value
; ; (partition-by odd? [1 1 1 2 2 3 3])
; ; => ((1 1 1) (2 2) (3 3)) /lseq/
;___________________________________________________________________________________________________________________________________
;=================================================={  FILTER + REMOVE + KEEP  }=====================================================
;=================================================={                          }=====================================================
(defn filter-keys+ [pred coll] (->> coll (filter+ (compr key+ pred))))
(defn remove-keys+ [pred coll] (->> coll (remove+ (compr key+ pred))))
(defn filter-vals+ [pred coll] (->> coll (filter+ (compr val+ pred))))
(defn remove-vals+ [pred coll] (->> coll (remove+ (compr key+ pred))))

(defn vals+
  {:attribution "Alex Gunnarson"
   :todo ["Compare performance with core functions"]}
  [m]
  (->> m (map+ val+) redv))
(defn keys+
  {:attribution "Alex Gunnarson"
   :todo ["Compare performance with core functions"]}
  [m]
  (->> m (map+ key+) redv))
;___________________________________________________________________________________________________________________________________
;=================================================={     PARTITION, GROUP     }=====================================================
;=================================================={       incl. slice        }=====================================================
; slice-from [o start] - like slice, but until the end of o
; slice-to [o end] - like slice, but from the beginning of o
(defn slice
  "Divide coll into n approximately equal slices.
   Like partition."
  {:attribution "flatland.useful.seq"
   :todo ["Optimize" "Use transients"]}
  [n-0 coll]
  (loop [n-n n-0 slices [] items (vec coll)]
    (if (empty? items)
      slices
      (let [size (num/ceil (/ (count items) n-n))]
        (recur (dec n-n)
               (conj slices (subvec+ items 0 size))
               (subvec+ items size))))))
; /partition/
; (partition 4 (range 20))
; => ((0 1 2 3) (4 5 6 7) (8 9 10 11) (12 13 14 15) (16 17 18 19))
; (partition 4 6 ["a" "b" "c" "d"] (range 20))
; => ((0 1 2 3) (6 7 8 9) (12 13 14 15) (18 19 "a" "b"))
; /partition-all/
; Returns a lazy sequence of lists like partition, but may include
; partitions with fewer than n items at the end.
; (partition-all 4 [0 1 2 3 4 5 6 7 8 9])
; => ((0 1 2 3) (4 5 6 7) (8 9))
;___________________________________________________________________________________________________________________________________
;=================================================={  DIFFERENTIAL OPERATIONS }=====================================================
;=================================================={     take, drop, split    }=====================================================
; /take-nth/
; (take-nth 2 (range 10))
; => (0 2 4 6 8)
; /cycle/
; (take 5 (cycle ["a" "b"]))
; => ("a" "b" "a" "b" "a")
; /take-last/ ; turn this into a subvec
; (take-last 2 [1 2 3 4]) => (3 4)
; /last/    is a limiting case (1) of take-last
; /drop-last/ ; (drop-last 2 [1 2 3 4]) => (1 2)
; /butlast/ is a limiting case (1) of drop-last

; splice [o index n val] - fast remove and insert in one go
; splice-arr [o index n val-arr] - fast remove and insert in one go
; insert-before [o index val] - insert one item inside coll
; insert-before-arr [o index val] - insert array of items inside coll
; remove-at [o index] - remove one item from index pos
; remove-n [o index n] - remove n items starting at index pos
; triml [o n] - trims n items from left
; trimr [o n] - trims n items from right
; trim [o nl nr] - trims nl items from left and nr items from right
; rip [o index] - rips coll and returns [pre-coll item-at suf-coll]
; sew [pre-coll item-arr suf-coll] - opposite of rip, but with arr
(defn split [ind coll-0]
  (if (vector? coll-0)
      [(subvec+ coll-0 0   ind)
       (subvec+ coll-0 ind (count coll-0))]
      (split-at coll-0 ind)))
(defn split-with-v+ [pred coll-0] ; IMPROVE
  (->> coll-0
       (split-with pred)
       (map+ vec)))
;_._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._
;=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*{        ASSOCIATIVE       }=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=
;=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*{                          }=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=
;___________________________________________________________________________________________________________________________________
;=================================================={          ASSOC           }=====================================================
;=================================================={ update(-in), assoc(-in)  }=====================================================
(defn- extend-coll-to
  "Extends an associative structure (for now, only vector) to a given index."
  {:attribution "Alex Gunnarson"
   :usage "USAGE: (extend-coll-to [1 2 3] 5) => [1 2 3 nil nil]"}
  [coll-0 k]
  (if (and (vector? coll-0)
           (number? k)
           (-> coll-0 count dec (< k)))
      (let [trans?   (transient? coll-0)
            trans-fn (if trans? identity transient)
            pers-fn  (if trans? identity persistent!)]
        (pers-fn
          (reduce
            (fn [coll-n _] (conj! coll-n nil)) ; extend-vec part
            (trans-fn coll-0)
            (range (count coll-0) (inc k)))))
      coll-0))
(defn assoc+
  {:todo ["Protocolize on IEditableCollection"
          "Probably has performance issues"]}
  ([coll-0 k v]
    (assoc (extend-coll-to coll-0 k) k v))
    ; once probably gives no performance benefit from transience
  ([coll-0 k v & kvs-0]
    (let [edit?    (editable? coll-0)
          trans-fn (if edit? transient   identity)
          pers-fn  (if edit? persistent! identity)
          assoc-fn (if edit? assoc!      assoc)]
      (loop [kvs-n  kvs-0
             coll-f (-> coll-0 trans-fn
                        (extend-coll-to k)
                        (assoc-fn k v))]
        (if (empty? kvs-n)
            (pers-fn coll-f)
            (recur (-> kvs-n rest rest)
                   (let [k-n (first kvs-n)]
                     (-> coll-f (extend-coll-to k-n)
                         (assoc-fn k-n (second kvs-n))))))))))
(defn update+
  "Updates the value in an associative data structure @coll associated with key @k
   by applying the function @f to the existing value."
  ^{:attribution "weavejester.medley"
    :contributors ["Alex Gunnarson"]}
  ([coll k f]      (assoc+ coll k       (f (get coll k))))
  ([coll k f args] (assoc+ coll k (apply f (get coll k) args))))

(defn updates+
  "For each key-function pair in @kfs,
   updates value in an associative data structure @coll associated with key
   by applying the function @f to the existing value."
  ^{:attribution "Alex Gunnarson"
    :todo ["Probably updates and update are redundant"]}
  ([coll & kfs]
    (reduce-2 ; This is inefficient
      (fn [ret k f] (update+ ret k f))
      coll
      kfs)))

(defn update-key+
  {:attribution "Alex Gunnarson"
   :usage '(->> {:a 4 :b 12}
                (map+ (update-key+ str)))}
  ([f]
    (fn
      ([kv]
        (assoc+ kv 0 (f (get kv 0))))
      ([k v]
        (map-entry (f k) v)))))

(defn update-val+
  {:attribution "Alex Gunnarson"
   :usage '(->> {:a 4 :b 12}
                (map+ (update-val+ (f*n / 2))))}
  ([f]
    (fn
      ([kv]
        (assoc+ kv 1 (f (get kv 1))))
      ([k v]
        (map-entry k (f v))))))

(defn mapmux
  ([kv]  kv)
  ([k v] (map-entry k v)))
(defn record->map [rec]
  (into {} rec))

;--------------------------------------------------{        UPDATE-IN         }-----------------------------------------------------
(defn update-in!
  "'Updates' a value in a nested associative structure, where ks is a sequence of keys and
  f is a function that will take the old value and any supplied args and return the new
  value, and returns a new nested structure. The associative structure can have transients
  in it, but if any levels do not exist, non-transient hash-maps will be created."
  {:attribution "flatland.useful"}
  [m [k & ks] f & args]
  (let [assoc-fn (if (transient? m) assoc! assoc)
        val (get m k)]
    (assoc-fn m k
      (if ks
          (apply update-in! val ks f args)
          (apply f val args)))))
; perhaps make a version of update-in : update :: assoc-in : assoc ?

(defn update-in+
  "Created so vectors would also automatically be grown like maps,
   given indices not present in the vector."
  {:attribution "Alex Gunnarson"
   :todo ["optimize via transients"
          "allow to use :last on vectors"
          "allow |identity| function for unity's sake"]}
  [coll-0 [k0 & keys-0] v0]
  (let [value (get coll-0 k0 (when (-> keys-0 first number?) []))
        coll-f (extend-coll-to coll-0 k0)
        val-f (if keys-0
                  (update-in+ value keys-0 v0) ; make a non-stack-consuming version, possibly via trampoline? 
                  v0)]
    (assoc coll-f k0 (whenf val-f fn? (*fn (get coll-f k0))))))
;--------------------------------------------------{         ASSOC-IN         }-----------------------------------------------------
(defn assoc-in+
  [coll ks v]
  (update-in+ coll ks (constantly v)))

(defn assoc-in!
  "Associates a value in a nested associative structure, where ks is a sequence of keys
  and v is the new value and returns a new nested structure. The associative structure
  can have transients in it, but if any levels do not exist, non-transient hash-maps will
  be created."
  ^{:attribution "flatland.useful"}
  [m ks v]
  (update-in! m ks (constantly v)))

(defn assocs-in+
  {:usage "(assocs-in ['file0' 'file1' 'file2']
             [0] 'file10'
             [1] 'file11'
             [2] 'file12')"}
  [coll & kvs]
  (reduce-2 ; this is inefficient
    (fn [ret k v] (assoc-in+ ret k v))
    coll
    kvs))
;___________________________________________________________________________________________________________________________________
;=================================================={          DISSOC          }=====================================================
;=================================================={                          }=====================================================
(defn dissoc+
  {:todo ["Protocolize"]}
  ([coll key-0]
    (try
      (cond ; probably use tricks to see which subvec is longer to into is less consumptive
        (vector? coll)
          (catvec (subvec+ coll 0 key-0)
                  (subvec+ coll (inc key-0) (count coll)))
        (editable? coll)
          (-> coll transient (dissoc! coll key-0) persistent!)
        :else
          (dissoc coll key-0))
      (catch ClassCastException e (dissoc coll key-0)))) ; Probably because of transients...
  ([coll key-0 & keys-0]
    (reduce dissoc+ coll (cons key-0 keys-0))))

(defn dissocs+ [coll & ks]
  (reduce
    (fn [ret k]
      (dissoc+ ret k))
    coll
    ks))

(defn dissoc-if+ [coll pred k] ; make dissoc-ifs+
  (whenf coll (fn-> (get k) pred)
    (f*n dissoc+ k)))

(defn dissoc-in+
  "Dissociate a value in a nested assocative structure, identified by a sequence
  of keys. Any collections left empty by the operation will be dissociated from
  their containing structures.
  This implementation was adapted from clojure.core.contrib"
  {:attribution "weavejester.medley"
   :todo ["Transientize"]}
  [m ks]
  (if-let [[k & ks] (seq ks)]
    (if (seq ks)
      (let [new-n (dissoc-in+ (get m k) ks)] ; this is terrible
        (if (empty? new-n) ; dissoc's empty ones
            (dissoc m k)
            (assoc m k new-n)))
      (dissoc m k))
    m))

(defn updates-in+
  [coll & kfs]
  (reduce-2 ; Inefficient
    (fn [ret k-n f-n] (update-in+ ret k-n f-n))
    coll
    kfs))

(defn re-assoc+ [coll k-0 k-f]
  (if (contains? coll k-0)
      (-> coll
         (assoc+  k-f (get coll k-0))
         (dissoc+ k-0))
      coll))

(defn re-assocs+ [coll & kfs]
  (reduce-2 ; Inefficient
    (fn [ret k-n f-n] (re-assoc+ ret k-n f-n))
    coll
    kfs))

(defn ^Map select-as+
  {:todo ["Name this function more appropriately"]
   :attribution "Alex Gunnarson"}
  ([coll kfs]
    (->> (reduce
           (fn [ret k f]
             (assoc+ ret k (f coll)))
           {}
           kfs)))
  ([coll k1 f1 & {:as kfs}]
    (select-as+ coll (assoc+ kfs k1 f1))))
;___________________________________________________________________________________________________________________________________
;=================================================={   DISTINCT, INTERLEAVE   }=====================================================
;=================================================={  interpose, frequencies  }=====================================================
#?(:clj
  (defn distinct-by-java
    "Returns elements of coll which return unique
     values according to f. If multiple elements of coll return the same
     value under f, the first is returned"
    {:attribution "prismatic.plumbing"
     :performance "Faster than |core/distinct-by|"}
    [f coll]
    (let [s (java.util.HashSet.)] ; instead of #{}
      (lfor [x coll
             :let [id (f x)]
             :when (not (.contains s id))]
       (do (.add s id)
           x)))))

; (defn plicates
;   {:attribution "Alex Gunnarson"}
;   [oper n]
;   (fn [coll]
;      (-> (fn [elem]
;            (-> (filter+ (fn-eq? elem) coll)
;                count
;                (oper n))) ; duplicates? keep them
;          (filter+ coll)
;          distinct+
;          redv)))

(defprotocol Interpose
  (interpose+- [coll elem]))

; TODO: make a reducers version of coll/elem
(extend-protocol Interpose
  #?(:clj String :cljs string)
    (interpose+- [coll elem]
      (str/join elem coll))
  #?(:clj Object :cljs default)
    (interpose+- [coll elem]
      (interpose elem coll)))

(defn interpose+
  {:todo ["|definline| this"]}
  [elem coll] (interpose+- coll elem))

(defn linterleave-all
  "Analogy: partition:partition-all :: interleave:interleave-all"
  {:attribution "prismatic/plumbing"}
  [& colls]
  (lazy-seq
   ((fn helper [seqs]
      (when (seq seqs)
        (concat (map first seqs)
                (lazy-seq (helper (keep next seqs))))))
    (keep seq colls))))

; (defn interleave+ [& args] ; 4.307220 ms vs. 1.424329 ms normal interleave :/ because of zipvec...
;   (reduce
;     (fn ([]      [])
;         ([a]     (conj [] a))
;         ([a b]   (conj    a b)) 
;         ([a b c] (conj    a b c)))
;     (apply zipvec+ args)))

#?(:clj
  (defn frequencies+
    "Like clojure.core/frequencies, but faster.
     Uses Java's equal/hash, so may produce incorrect results if
     given values that are = but not .equal"
    {:attribution "prismatic.plumbing"
     :performance "4.048617 ms vs. |frequencies| 6.341091 ms"}
    [xs]
    (let [res (java.util.HashMap.)]
      (doseq [x xs]
        (->> (.get res x)
             (or 0)
             int
             unchecked-inc)
             (.put res x))
      (into {} res))))
;___________________________________________________________________________________________________________________________________
;=================================================={         GROUPING         }=====================================================
;=================================================={     group, aggregate     }=====================================================
(defn ^Delay group-merge-with+
  {:attribution "Alex Gunnarson"
   :todo ["Can probably make the |merge| process parallel."]
   :in [":a"
        "(fn [k v1 v2] v1)"
        "[{:a 1 :b 2} {:a 1 :b 5} {:a 5 :b 65}]"]
   :out "[{:b 65, :a 5} {:a 1, :b 2}]"}
  [group-by-f merge-with-f coll]
  (let [merge-like-elems 
         (fn [grouped-elems]
           (if (single? grouped-elems)
               grouped-elems
               (reduce
                 (fn [ret elem]
                   (merge-with+ merge-with-f ret elem))
                 (first grouped-elems)
                 (rest  grouped-elems))))]
    (->> coll
         (group-by+ group-by-f)
         (map+ val+) ; [[{}] [{}{}{}]]
         (map+ merge-like-elems)
         flatten+)))

(defn merge-left 
  ([^Key alert-level]
    (fn [k v1 v2]
      (when (not= v1 v2)
        (log/pr alert-level
          "Values do not match for merge key"
          (str (str/squote k) ":")
          (str/squote v1) "|" (str/squote v2)))
      v1))
  ([k v1 v2] v1))

(defn merge-right
  ([^Key alert-level]
    (fn [k v1 v2]
      (when (not= v1 v2)
        (log/pr alert-level
          "Values do not match for merge key"
          (str (str/squote k) ":")
          (str/squote v1) "|" (str/squote v2)))
      v1))
  ([k v1 v2] v2))

(defn ^Delay first-uniques-by+ [k coll]
  (->> coll
       (group-by+ k)
       (map+ (update-val+ first))))
;___________________________________________________________________________________________________________________________________
;=================================================={     TREE STRUCTURES      }=====================================================
;=================================================={                          }=====================================================
; Stuart Sierra: "In my tests, clojure.walk2 is about 2 times faster than clojure.walk."

(defprotocol ^{:added "1.6"} Walkable
  (^{:added "1.6"
     :attribution "Stuart Sierra, stuartsierra/clojure.walk2"}
     walk2 [coll f]
    "If coll is a collection, applies f to each element of the collection
     and returns a collection of the results, of the same type and order
     as coll. If coll is not a collection, returns it unchanged. \"Same
     type\" means a type with the same behavior. For example, a hash-map
     may be returned as an array-map, but a a sorted-map will be returned
     as a sorted-map with the same comparator."))

#?(:clj
  (extend-protocol Walkable
    nil
      (walk2 [coll f] nil)
    java.lang.Object  ; default: not a collection
      (walk2 [x f] x)
    clojure.lang.IMapEntry
      (walk2 [coll f]
        (clojure.lang.MapEntry. (f (.key coll)) (f (.val coll))))
    clojure.lang.ISeq  ; generic sequence fallback
      (walk2 [coll f]
        (map f coll))
    clojure.lang.PersistentList  ; special case to preserve type
      (walk2 [coll f]
        (apply list (map f coll)))
    clojure.lang.PersistentList$EmptyList  ; special case to preserve type
      (walk2 [coll f] '())
    clojure.lang.IRecord  ; any defrecord
      (walk2 [coll f]
        (reduce (fn [r x] (conj r (f x))) coll coll))))

(defn- walk2-transient [coll f]
  ;; `transient` discards metadata as of Clojure 1.6.0
  (persistent!
    (reduce
      (fn [r x] (conj! r (f x)))
      (transient (empty coll)) coll)))

;; Persistent collections that support transients
#?(:clj
  (doseq [type [clojure.lang.PersistentArrayMap
                clojure.lang.PersistentHashMap
                clojure.lang.PersistentHashSet
                clojure.lang.PersistentVector]]
    (extend type Walkable {:walk2 walk2-transient})))

(defn- walk2-default [coll f]
  (reduce
    (fn [r x] (conj r (f x)))
    (empty coll) coll))

;; Persistent collections that don't support transients
#?(:clj
  (doseq [type [clojure.lang.PersistentQueue
                clojure.lang.PersistentStructMap
                clojure.lang.PersistentTreeMap
                clojure.lang.PersistentTreeSet]]
    (extend type Walkable {:walk2 walk2-default})))

(defn walk
  "Traverses form, an arbitrary data structure.  inner and outer are
  functions.  Applies inner to each element of form, building up a
  data structure of the same type, then applies outer to the result.
  Recognizes all Clojure data structures. Consumes seqs as with doall."
  {:attribution "Stuart Sierra, stuartsierra/clojure.walk2"}
  [inner outer form]
  (outer (walk2 form inner)))

(defn postwalk
  "Performs a depth-first, post-order traversal of form.  Calls f on
  each sub-form, uses f's return value in place of the original.
  Recognizes all Clojure data structures. Consumes seqs as with doall."
  {:attribution "Stuart Sierra, stuartsierra/clojure.walk2"}
  [f form]
  (walk (partial postwalk f) f form))

(defn prewalk
  "Like postwalk, but does pre-order traversal."
  {:attribution "Stuart Sierra, stuartsierra/clojure.walk2"}
  [f form]
  (walk (partial prewalk f) identity (f form)))

; COMBINE THESE TWO
(defn keywordify-keys
  "Recursively transforms all map keys from keywords to strings."
  {:attribution "Stuart Sierra, stuartsierra/clojure.walk2"
   :contributors #{"Alex Gunnarson"}}
  [^Map m]
  (let [stringify-key
         (fn [[k v]]
           (if (string? k)
               (map-entry (keyword? k) v)
               (map-entry k v)))]
    ; only apply to maps
    (postwalk
      (whenf*n map? (fn->> (map+ stringify-key) redm))
      m)))

; COMBINE THESE TWO
(defn stringify-keys
  "Recursively transforms all map keys from keywords to strings."
  {:attribution "Stuart Sierra, stuartsierra/clojure.walk2"
   :contributors #{"Alex Gunnarson"}}
  [^Map m]
  (let [stringify-key
         (fn [[k v]]
           (if (keyword? k)
               (map-entry (name k) v)
               (map-entry k v)))]
    ; only apply to maps
    (postwalk
      (whenf*n map? (fn->> (map+ stringify-key) redm))
      m)))

(defn prewalk-replace
  "Recursively transforms form by replacing keys in smap with their
  values.  Like clojure/replace but works on any data structure.  Does
  replacement at the root of the tree first."
  {:attribution "Stuart Sierra, stuartsierra/clojure.walk2"}
  [smap form]
  (prewalk (whenf*n (f*n in? smap) smap) form))

(defn postwalk-replace
  "Recursively transforms form by replacing keys in smap with their
  values.  Like clojure/replace but works on any data structure.  Does
  replacement at the leaves of the tree first."
  {:attribution "Stuart Sierra, stuartsierra/clojure.walk2"}
  [smap form]
  (postwalk (whenf*n (f*n in? smap) smap) form))

(defn tree-filter
  "Like |filter|, but performs a |postwalk| on a treelike structure @tree, putting in a new vector
   only the elements for which @pred is true."
  {:attribution "Alex Gunnarson"}
  [^Fn pred tree]
  (let [results (transient [])]
    (postwalk
      (whenf*n pred
        (fn->> (with->> conj! results))) ; keep it the same
      tree)
    (persistent! results)))

(defn- sort-parts
  "Lazy, tail-recursive, incremental quicksort. Works against
   and creates partitions based on the pivot, defined as 'work'."
  {:attribution "The Joy of Clojure, 2nd ed."}
  [work]
  (lazy-seq
    (loop [[part & parts] work]
      (if-let [[pivot & xs] (seq part)]
        (let [smaller? #(< % pivot)]
          (recur (list*
                  (filter smaller? xs)
                  pivot
                  (remove smaller? xs)
                  parts)))
        (when-let [[x & parts] parts]
          (cons x (sort-parts parts)))))))

(defn lsort
  "Lazy 'quick'-sorting"
  {:attribution "The Joy of Clojure, 2nd ed."}
  [elems]
  (sort-parts (list elems))) 
;___________________________________________________________________________________________________________________________________
;=================================================={   COLLECTIONS CREATION   }=====================================================
;=================================================={                          }=====================================================
; ; DEPRECATED; Created while learning Scheme, in which a loop-recur kind of form is the norm 
; (defn coll-struct
;   "Usage:
;   (lib/coll-struct :size 5 :in [] :element {})
;   => [{} {} {} {} {}]
;   (lib/coll-struct :size 5 :in {} :elem-func #(hash-map (keyword (str %)) %))
;   => {:4 4, :3 3, :2 2, :1 1, :0 0}"
;   [& {:keys [in size element elem-func]
;       :or   [elem-func identity]
;       :as   args}]
;   (let [elem-func-f
;          (cond (nnil? element)   (fn [n] element)
;                (nnil? elem-func) elem-func)]
;     (loop [n 0 coll-n in]
;       (if (= n size)
;           coll-n
;           (recur (inc n) (conj coll-n (elem-func-f n)))))))
; ; DEPRECATED; Created while learning Scheme, in which a loop-recur kind of form is the norm 
; (defn accumulate
;   ^{:usage "(accumulate :decum [1 2 3] :accum () :func #(conj %1 (inc %2)))
;             => (4 3 2)"}
;   [& {:keys [decum accum func]
;       :as args}]
;   (loop [[list-n-0 & list-r :as list-n] decum
;          list-f accum]
;     (if (empty? list-n)
;         list-f
;         (recur list-r
;                (func list-f list-n-0)))))

nil
quantum.core.collections=> quantum.core.collections=> nil
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/vec
quantum.core.collections=> #'quantum.core.collections/into
quantum.core.collections=> #'quantum.core.collections/reduce
quantum.core.collections=> #'quantum.core.collections/reducei
quantum.core.collections=> #'quantum.core.collections/redv
quantum.core.collections=> #'quantum.core.collections/redm
quantum.core.collections=> #'quantum.core.collections/fold
quantum.core.collections=> #'quantum.core.collections/foldv
quantum.core.collections=> #'quantum.core.collections/foldm
quantum.core.collections=> #'quantum.core.collections/map+
quantum.core.collections=> #'quantum.core.collections/filter+
quantum.core.collections=> #'quantum.core.collections/lfilter
quantum.core.collections=> #'quantum.core.collections/remove+
quantum.core.collections=> #'quantum.core.collections/lremove
quantum.core.collections=> #'quantum.core.collections/take+
quantum.core.collections=> #'quantum.core.collections/take-while+
quantum.core.collections=> #'quantum.core.collections/drop+
quantum.core.collections=> #'quantum.core.collections/group-by+
quantum.core.collections=> #'quantum.core.collections/flatten+
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/for
quantum.core.collections=> {:line 6912, :column 9, :file "/private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj", :name for, :ns #object[clojure.lang.Namespace 0x4c475d7d "quantum.core.collections"], :macro true}
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/lfor
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/doseq
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/doseqi
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/lasti
quantum.core.collections=> #'quantum.core.collections/index-of
quantum.core.collections=> #'quantum.core.collections/last-index-of
quantum.core.collections=> #'quantum.core.collections/count
quantum.core.collections=> #'quantum.core.collections/getr
quantum.core.collections=> #'quantum.core.collections/get
quantum.core.collections=> #'quantum.core.collections/gets
quantum.core.collections=> #'quantum.core.collections/getf
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/conjl
quantum.core.collections=> CompilerException java.lang.RuntimeException: Unable to resolve var: coll/conjr in this context, compiling:(/private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:6956:1) 
quantum.core.collections=> #'quantum.core.collections/pop
quantum.core.collections=> #'quantum.core.collections/popr
quantum.core.collections=> #'quantum.core.collections/popl
quantum.core.collections=> #'quantum.core.collections/peek
quantum.core.collections=> #'quantum.core.collections/first
quantum.core.collections=> #'quantum.core.collections/second
quantum.core.collections=> #'quantum.core.collections/third
quantum.core.collections=> #'quantum.core.collections/rest
quantum.core.collections=> #'quantum.core.collections/lrest
quantum.core.collections=> #'quantum.core.collections/butlast
quantum.core.collections=> #'quantum.core.collections/last
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/merge
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/merge-meta
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/frest
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/repeatedly-into
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/lrepeatedly
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/repeatedly
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/range+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/lrange
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/range
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/repeat
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/abs-difference
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:7046:15 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
#'quantum.core.collections/get-map-constructor
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/reduce-2
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/ffilter
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/ffilter+
quantum.core.collections=> quantum.core.collections=> Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:7092:3 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:7098:26 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
#'quantum.core.collections/ffilteri+
quantum.core.collections=> quantum.core.collections=> Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:7105:7 - call: public static boolean clojure.lang.Numbers.gt(long,java.lang.Object).
Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:7107:9 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:7114:7 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
#'quantum.core.collections/filteri+
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:7127:7 - call: public static boolean clojure.lang.Numbers.gt(long,java.lang.Object).
Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:7129:9 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:7136:7 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
#'quantum.core.collections/indices-of+
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/takel+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/take-from+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/take-fromi+
quantum.core.collections=> quantum.core.collections=> Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:7171:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(java.lang.Object,java.lang.Object).
#'quantum.core.collections/take-afteri+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/take-untili+
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/takeri+
quantum.core.collections=> quantum.core.collections=> Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:7206:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
#'quantum.core.collections/taker-untili+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/take-while-not
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/dropl+
quantum.core.collections=> quantum.core.collections=> Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:7228:15 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_minus(java.lang.Object,java.lang.Object).
#'quantum.core.collections/dropr+
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/merge-keep-left
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/split-remove+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/kmap
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/select
quantum.core.collections=> quantum.core.collections=> Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:7275:3 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
#'quantum.core.collections/comparator-extreme-of
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/coll-if
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/seq-if
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/lseq
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/lseq+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/unchunk
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/key+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/val+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/fkey+
quantum.core.collections=> #'quantum.core.collections/fval+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/up-val
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/get-in+
quantum.core.collections=> #'quantum.core.collections/reverse+
quantum.core.collections=> #'quantum.core.collections/single?
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/contains?
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/merge-with+
quantum.core.collections=> quantum.core.collections=> Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:7463:24 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(java.lang.Object,java.lang.Object).
#'quantum.core.collections/merge-vals-left
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/concat++
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> Contains?
quantum.core.collections=> nil
quantum.core.collections=> quantum.core.collections=> nil
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/in?
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/subs?
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/select-keys-large
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/select-keys-small
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/select-keys-delay
quantum.core.collections=> quantum.core.collections=> Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:7581:20 - call: public static boolean clojure.lang.Numbers.gt(java.lang.Object,long).
#'quantum.core.collections/select-keys+
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/get-keys
quantum.core.collections=> #'quantum.core.collections/get-key
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/filter-keys+
quantum.core.collections=> #'quantum.core.collections/remove-keys+
quantum.core.collections=> #'quantum.core.collections/filter-vals+
quantum.core.collections=> #'quantum.core.collections/remove-vals+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/vals+
quantum.core.collections=> #'quantum.core.collections/keys+
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:7644:28 - call: public static java.lang.Number clojure.lang.Numbers.divide(java.lang.Object,java.lang.Object).
Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:7645:16 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
#'quantum.core.collections/slice
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/split
quantum.core.collections=> #'quantum.core.collections/split-with-v+
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:7706:33 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:7706:33 - call: public static boolean clojure.lang.Numbers.lt(java.lang.Object,java.lang.Object).
Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:7714:35 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
#'quantum.core.collections/extend-coll-to
quantum.core.collections=> #'quantum.core.collections/assoc+
quantum.core.collections=> #'quantum.core.collections/update+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/updates+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/update-key+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/update-val+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/mapmux
quantum.core.collections=> #'quantum.core.collections/record->map
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/update-in!
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/update-in+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/assoc-in+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/assoc-in!
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/assocs-in+
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:7849:33 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
#'quantum.core.collections/dissoc+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/dissocs+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/dissoc-if+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/dissoc-in+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/updates-in+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/re-assoc+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/re-assocs+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/select-as+
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/distinct-by-java
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> Interpose
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> nil
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/interpose+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/linterleave-all
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> Reflection warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:7996:14 - call to method put on java.util.HashMap can't be resolved (no such method).
#'quantum.core.collections/frequencies+
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/group-merge-with+
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/merge-left
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/merge-right
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/first-uniques-by+
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> Walkable
quantum.core.collections=> quantum.core.collections=> nil
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/walk2-transient
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> nil
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/walk2-default
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> nil
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/walk
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/postwalk
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/prewalk
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/keywordify-keys
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/stringify-keys
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/prewalk-replace
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/postwalk-replace
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/tree-filter
quantum.core.collections=> quantum.core.collections=> Boxed math warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:8206:25 - call: public static boolean clojure.lang.Numbers.lt(java.lang.Object,java.lang.Object).
#'quantum.core.collections/sort-parts
quantum.core.collections=> quantum.core.collections=> #'quantum.core.collections/lsort
quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> quantum.core.collections=> 
quantum.core.collections=> 
quantum.core.collections=> (ns test
  (:require
    [clojure.tools.namespace.repl :refer [refresh refresh-all set-refresh-dirs]]
    [quantum.core.ns :as ns]))

;(ns/require :clj :lib)
(ns/require-all *ns* :clj :lib)

(defn init! [] (println "Hey :)"))
; (refresh-all :after 'test/init!)

; (in-ns 'clojure.tools.namespace.parse)
; (defn read-ns-decl
;   "Attempts to read a (ns ...) declaration from a
;   java.io.PushbackReader, and returns the unevaluated form. Returns
;   the first top-level ns form found. Returns nil if read fails or if a
;   ns declaration cannot be found. Note that read can execute code
;   (controlled by *read-eval*), and as such should be used only with
;   trusted sources."
;   [rdr]
;   {:pre [(instance? java.io.PushbackReader rdr)]}
;   (try
;    (loop []
;      (let [form (doto (read {:read-cond :allow} rdr) str)]  ; str forces errors, see TNS-1
;        (if (ns-decl? form)
;          form
;          (recur))))
;    (catch Exception e nil)))
; (in-ns 'test)
nil
test=> test=> test=> IllegalStateException Alias coll already exists in namespace test, aliasing quantum.core.collections  clojure.lang.Namespace.addAlias (Namespace.java:224)
test=> test=> #'test/init!
test=> test=> test=> test=> test=> test=> test=> test=> test=> test=> test=> test=> test=> test=> test=> test=> test=> test=> test=> test=> test=> 
test=> 
test=> (ns test
  (:require
    [clojure.tools.namespace.repl :refer [refresh refresh-all set-refresh-dirs]]
    [quantum.core.ns :as ns]))

;(ns/require :clj :lib)
(ns/require-all *ns* :clj :lib)
nil
test=> test=> test=> IllegalStateException Alias coll already exists in namespace test, aliasing quantum.core.collections  clojure.lang.Namespace.addAlias (Namespace.java:224)
test=> 
test=> 
test=> (clojure.tools.namespace.repl/clear)
{}
test=> (ns test
  (:require
    [clojure.tools.namespace.repl :refer [refresh refresh-all set-refresh-dirs]]
    [quantum.core.ns :as ns]))

;(ns/require :clj :lib)
(ns/require-all *ns* :clj :lib)
nil
test=> test=> test=> IllegalStateException Alias coll already exists in namespace test, aliasing quantum.core.collections  clojure.lang.Namespace.addAlias (Namespace.java:224)
test=> (refresh-all)
:reloading (quantum.core.ns quantum.auth.core quantum.web.core quantum.google.core quantum.google.drive.auth quantum.core.data.json quantum.http.core quantum.google.drive.core quantum.http.url quantum.core.network.deploy quantum.auth.oauth test quantum.core.collections quantum.ui.core quantum.core.time.core quantum.core.time.local quantum.core.data.binary quantum.core.thread quantum.core.network.core quantum.core.system quantum.core.macros quantum.ui.component quantum.datagrid.core quantum.core.type quantum.core.data.bytes quantum.core.io.core quantum.core.cryptography quantum.datagrid.excel quantum.core.time.coerce quantum.core.numeric quantum.core.data.xml quantum.core.collections.core quantum.core.log quantum.core.data.ftree quantum.core.io.serialization quantum.core.data.vector quantum.core.logic quantum.core.util.test quantum.core.loops quantum.core.data.hex quantum.core.reducers quantum.core.data.set quantum.core.print quantum.core.io.compress quantum.core.data.array quantum.core.data.queue quantum.ui.fonts quantum.core.nondeterministic quantum.core.string quantum.core.util.sh quantum.core.error quantum.core.util.bench quantum.core.java quantum.ui.init quantum.core.data.map quantum.core.function quantum.core.util.debug quantum.core.time.format quantum.ui.aux-fn)
Reflection warning, quantum/core/ns.cljc:116:11 - reference to field hasRoot can't be resolved.
Reflection warning, quantum/core/type.cljc:63:26 - reference to field isArray can't be resolved.
Boxed math warning, quantum/core/numeric.cljc:32:21 - call: public static boolean clojure.lang.Numbers.isNeg(java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:37:17 - call: public static boolean clojure.lang.Numbers.isNeg(java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:58:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:60:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:60:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:67:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_multiply(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:69:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_multiply(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:69:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_multiply(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:76:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_minus(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:78:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_minus(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:78:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_minus(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:83:5 - call: public static java.lang.Number clojure.lang.Numbers.divide(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:85:5 - call: public static java.lang.Number clojure.lang.Numbers.divide(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:85:5 - call: public static java.lang.Number clojure.lang.Numbers.divide(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:120:18 - call: public static boolean clojure.lang.Numbers.isPos(java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:126:18 - call: public static boolean clojure.lang.Numbers.isNeg(java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:128:9 - call: public static boolean clojure.lang.Numbers.gt(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:129:9 - call: public static boolean clojure.lang.Numbers.gt(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:132:9 - call: public static boolean clojure.lang.Numbers.lt(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:133:9 - call: public static boolean clojure.lang.Numbers.lt(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:136:7 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_minus(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:136:39 - call: public static boolean clojure.lang.Numbers.lt(java.lang.Object,java.lang.Object).
WARNING: reduce already refers to: #'clojure.core/reduce in namespace: quantum.core.reducers, being replaced by: #'quantum.core.reducers/reduce
Boxed math warning, quantum/core/reducers.cljc:480:7 - call: public static boolean clojure.lang.Numbers.lte(long,java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:506:27 - call: public static java.lang.Number clojure.lang.Numbers.quotient(java.lang.Object,long).
Boxed math warning, quantum/core/reducers.cljc:518:27 - call: public static java.lang.Number clojure.lang.Numbers.quotient(java.lang.Object,long).
Boxed math warning, quantum/core/reducers.cljc:813:16 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:964:25 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_minus(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:964:22 - call: public static java.lang.Number clojure.lang.Numbers.divide(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:974:21 - call: public static boolean clojure.lang.Numbers.isPos(java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:979:33 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:985:29 - call: public static java.lang.Number clojure.lang.Numbers.quotient(java.lang.Object,long).
Boxed math warning, quantum/core/reducers.cljc:986:29 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_multiply(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:987:29 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:1017:9 - call: public static boolean clojure.lang.Numbers.isNeg(java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:1020:18 - call: public static boolean clojure.lang.Numbers.isNeg(java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:1076:9 - call: public static boolean clojure.lang.Numbers.isNeg(java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:1079:18 - call: public static boolean clojure.lang.Numbers.isNeg(java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:1203:9 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:1203:9 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:1209:37 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:1209:64 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/string.cljc:136:24 - call: public static boolean clojure.lang.Numbers.gte(java.lang.Object,long).
Boxed math warning, quantum/core/string.cljc:137:22 - call: public static java.lang.Object clojure.lang.Numbers.min(java.lang.Object,long).
Boxed math warning, quantum/core/string.cljc:138:34 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(long,java.lang.Object).
Boxed math warning, quantum/core/string.cljc:138:29 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/string.cljc:138:22 - call: public static java.lang.Object clojure.lang.Numbers.max(long,java.lang.Object).
Boxed math warning, quantum/core/string.cljc:140:27 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/string.cljc:140:22 - call: public static java.lang.Object clojure.lang.Numbers.min(java.lang.Object,long).
Boxed math warning, quantum/core/string.cljc:256:3 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/string.cljc:266:3 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/string.cljc:298:15 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(long,java.lang.Object).
Boxed math warning, quantum/core/string.cljc:298:15 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(long,java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:148:55 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:166:35 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:167:35 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:168:49 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_minus(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:168:44 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:270:7 - call: public static boolean clojure.lang.Numbers.gt(long,java.lang.Object).
Reflection warning, quantum/core/collections/core.cljc:305:40 - call to method indexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
Reflection warning, quantum/core/collections/core.cljc:306:40 - call to method lastIndexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
Reflection warning, quantum/core/collections/core.cljc:305:40 - call to method indexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
Reflection warning, quantum/core/collections/core.cljc:306:40 - call to method lastIndexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
Reflection warning, quantum/core/time/core.cljc:76:40 - reference to field getTime can't be resolved.
Reflection warning, quantum/core/time/core.cljc:82:5 - call to method write can't be resolved (target class is unknown).
Reflection warning, quantum/core/time/core.cljc:83:5 - call to method write can't be resolved (target class is unknown).
Reflection warning, quantum/core/time/core.cljc:84:5 - call to method write can't be resolved (target class is unknown).
Boxed math warning, quantum/core/time/core.cljc:93:20 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
:error-while-loading quantum.auth.core
#error {
 :cause "Unable to resolve var: coll/conjr in this context"
 :via
 [{:type clojure.lang.Compiler$CompilerException
   :message "java.lang.RuntimeException: Unable to resolve var: coll/conjr in this context, compiling:(quantum/core/collections.cljc:152:1)"
   :at [clojure.lang.Compiler analyzeSeq "Compiler.java" 6740]}
  {:type java.lang.RuntimeException
   :message "Unable to resolve var: coll/conjr in this context"
   :at [clojure.lang.Util runtimeException "Util.java" 221]}]
 :trace
 [[clojure.lang.Util runtimeException "Util.java" 221]
  [clojure.lang.Compiler$TheVarExpr$Parser parse "Compiler.java" 698]
  [clojure.lang.Compiler analyzeSeq "Compiler.java" 6733]
  [clojure.lang.Compiler analyze "Compiler.java" 6524]
  [clojure.lang.Compiler access$300 "Compiler.java" 38]
  [clojure.lang.Compiler$LetExpr$Parser parse "Compiler.java" 6129]
  [clojure.lang.Compiler analyzeSeq "Compiler.java" 6733]
  [clojure.lang.Compiler analyze "Compiler.java" 6524]
  [clojure.lang.Compiler analyze "Compiler.java" 6485]
  [clojure.lang.Compiler$BodyExpr$Parser parse "Compiler.java" 5861]
  [clojure.lang.Compiler$FnMethod parse "Compiler.java" 5296]
  [clojure.lang.Compiler$FnExpr parse "Compiler.java" 3925]
  [clojure.lang.Compiler analyzeSeq "Compiler.java" 6731]
  [clojure.lang.Compiler analyze "Compiler.java" 6524]
  [clojure.lang.Compiler eval "Compiler.java" 6789]
  [clojure.lang.Compiler eval "Compiler.java" 6781]
  [clojure.lang.Compiler load "Compiler.java" 7237]
  [clojure.lang.RT loadResourceScript "RT.java" 371]
  [clojure.lang.RT loadResourceScript "RT.java" 362]
  [clojure.lang.RT load "RT.java" 446]
  [clojure.lang.RT load "RT.java" 412]
  [clojure.core$load$fn__5446 invoke "core.clj" 5862]
  [clojure.core$load doInvoke "core.clj" 5861]
  [clojure.lang.RestFn invoke "RestFn.java" 408]
  [clojure.core$load_one invoke "core.clj" 5667]
  [clojure.core$load_lib$fn__5395 invoke "core.clj" 5707]
  [clojure.core$load_lib doInvoke "core.clj" 5706]
  [clojure.lang.RestFn applyTo "RestFn.java" 142]
  [clojure.core$apply invoke "core.clj" 630]
  [clojure.core$load_libs doInvoke "core.clj" 5745]
  [clojure.lang.RestFn applyTo "RestFn.java" 137]
  [clojure.core$apply invoke "core.clj" 630]
  [clojure.core$require doInvoke "core.clj" 5828]
  [clojure.lang.RestFn invoke "RestFn.java" 3894]
  [quantum.core.ns$require_lib invoke "ns.cljc" 362]
  [quantum.core.ns$require_all invoke "ns.cljc" 463]
  [quantum.core.ns$require_all doInvoke "ns.cljc" 480]
  [clojure.lang.RestFn invoke "RestFn.java" 442]
  [quantum.auth.core$eval51495 invoke "core.clj" 10]
  [clojure.lang.Compiler eval "Compiler.java" 6792]
  [clojure.lang.Compiler load "Compiler.java" 7237]
  [clojure.lang.RT loadResourceScript "RT.java" 371]
  [clojure.lang.RT loadResourceScript "RT.java" 362]
  [clojure.lang.RT load "RT.java" 446]
  [clojure.lang.RT load "RT.java" 412]
  [clojure.core$load$fn__5446 invoke "core.clj" 5862]
  [clojure.core$load doInvoke "core.clj" 5861]
  [clojure.lang.RestFn invoke "RestFn.java" 408]
  [clojure.core$load_one invoke "core.clj" 5667]
  [clojure.core$load_lib$fn__5395 invoke "core.clj" 5707]
  [clojure.core$load_lib doInvoke "core.clj" 5706]
  [clojure.lang.RestFn applyTo "RestFn.java" 142]
  [clojure.core$apply invoke "core.clj" 630]
  [clojure.core$load_libs doInvoke "core.clj" 5745]
  [clojure.lang.RestFn applyTo "RestFn.java" 137]
  [clojure.core$apply invoke "core.clj" 630]
  [clojure.core$require doInvoke "core.clj" 5828]
  [clojure.lang.RestFn invoke "RestFn.java" 421]
  [clojure.tools.namespace.reload$track_reload_one invoke "reload.clj" 35]
  [clojure.tools.namespace.reload$track_reload invoke "reload.clj" 52]
  [clojure.lang.AFn applyToHelper "AFn.java" 154]
  [clojure.lang.AFn applyTo "AFn.java" 144]
  [clojure.lang.Var alterRoot "Var.java" 303]
  [clojure.core$alter_var_root doInvoke "core.clj" 5273]
  [clojure.lang.RestFn invoke "RestFn.java" 425]
  [clojure.tools.namespace.repl$do_refresh invoke "repl.clj" 94]
  [clojure.tools.namespace.repl$refresh_all doInvoke "repl.clj" 162]
  [clojure.lang.RestFn invoke "RestFn.java" 397]
  [test$eval51056 invoke "form-init3623728042651227831.clj" 8303]
  [clojure.lang.Compiler eval "Compiler.java" 6792]
  [clojure.lang.Compiler eval "Compiler.java" 6755]
  [clojure.core$eval invoke "core.clj" 3079]
  [clojure.main$repl$read_eval_print__7095$fn__7098 invoke "main.clj" 240]
  [clojure.main$repl$read_eval_print__7095 invoke "main.clj" 240]
  [clojure.main$repl$fn__7104 invoke "main.clj" 258]
  [clojure.main$repl doInvoke "main.clj" 258]
  [clojure.lang.RestFn invoke "RestFn.java" 421]
  [clojure.main$repl_opt invoke "main.clj" 324]
  [clojure.main$main doInvoke "main.clj" 422]
  [clojure.lang.RestFn invoke "RestFn.java" 397]
  [clojure.lang.Var invoke "Var.java" 375]
  [clojure.lang.AFn applyToHelper "AFn.java" 152]
  [clojure.lang.Var applyTo "Var.java" 700]
  [clojure.main main "main.java" 37]
  [sun.reflect.NativeMethodAccessorImpl invoke0 "NativeMethodAccessorImpl.java" -2]
  [sun.reflect.NativeMethodAccessorImpl invoke "NativeMethodAccessorImpl.java" 62]
  [sun.reflect.DelegatingMethodAccessorImpl invoke "DelegatingMethodAccessorImpl.java" 43]
  [java.lang.reflect.Method invoke "Method.java" 483]
  [clojure.lang.Reflector invokeMatchingMethod "Reflector.java" 93]
  [clojure.lang.Reflector invokeStaticMethod "Reflector.java" 207]
  [sun.reflect.NativeMethodAccessorImpl invoke0 "NativeMethodAccessorImpl.java" -2]
  [sun.reflect.NativeMethodAccessorImpl invoke "NativeMethodAccessorImpl.java" 62]
  [sun.reflect.DelegatingMethodAccessorImpl invoke "DelegatingMethodAccessorImpl.java" 43]
  [java.lang.reflect.Method invoke "Method.java" 483]
  [clojure.lang.Reflector invokeMatchingMethod "Reflector.java" 93]
  [clojure.lang.Reflector invokeStaticMethod "Reflector.java" 207]
  [user$eval5 invoke "form-init3623728042651227831.clj" 1]
  [clojure.lang.Compiler eval "Compiler.java" 6792]
  [clojure.lang.Compiler eval "Compiler.java" 6782]
  [clojure.lang.Compiler load "Compiler.java" 7237]
  [clojure.lang.Compiler loadFile "Compiler.java" 7175]
  [clojure.main$load_script invoke "main.clj" 275]
  [clojure.main$init_opt invoke "main.clj" 280]
  [clojure.main$initialize invoke "main.clj" 308]
  [clojure.main$null_opt invoke "main.clj" 343]
  [clojure.main$main doInvoke "main.clj" 421]
  [clojure.lang.RestFn invoke "RestFn.java" 421]
  [clojure.lang.Var invoke "Var.java" 383]
  [clojure.lang.AFn applyToHelper "AFn.java" 156]
  [clojure.lang.Var applyTo "Var.java" 700]
  [clojure.main main "main.java" 37]]}
test=> (refresh-all)
:reloading (quantum.core.ns quantum.auth.core quantum.web.core quantum.google.core quantum.google.drive.auth quantum.core.data.json quantum.http.core quantum.google.drive.core quantum.http.url quantum.core.network.deploy quantum.auth.oauth test quantum.core.collections quantum.ui.core quantum.core.time.core quantum.core.time.local quantum.core.data.binary quantum.core.thread quantum.core.network.core quantum.core.system quantum.core.macros quantum.ui.component quantum.datagrid.core quantum.core.type quantum.core.data.bytes quantum.core.io.core quantum.core.cryptography quantum.datagrid.excel quantum.core.time.coerce quantum.core.numeric quantum.core.data.xml quantum.core.collections.core quantum.core.log quantum.core.data.ftree quantum.core.io.serialization quantum.core.data.vector quantum.core.logic quantum.core.util.test quantum.core.loops quantum.core.data.hex quantum.core.reducers quantum.core.data.set quantum.core.print quantum.core.io.compress quantum.core.data.array quantum.core.data.queue quantum.ui.fonts quantum.core.nondeterministic quantum.core.string quantum.core.util.sh quantum.core.error quantum.core.util.bench quantum.core.java quantum.ui.init quantum.core.data.map quantum.core.function quantum.core.util.debug quantum.core.time.format quantum.ui.aux-fn)
Reflection warning, quantum/core/ns.cljc:116:11 - reference to field hasRoot can't be resolved.
Reflection warning, quantum/core/type.cljc:63:26 - reference to field isArray can't be resolved.
Boxed math warning, quantum/core/numeric.cljc:32:21 - call: public static boolean clojure.lang.Numbers.isNeg(java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:37:17 - call: public static boolean clojure.lang.Numbers.isNeg(java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:58:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:60:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:60:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:67:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_multiply(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:69:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_multiply(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:69:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_multiply(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:76:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_minus(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:78:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_minus(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:78:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_minus(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:83:5 - call: public static java.lang.Number clojure.lang.Numbers.divide(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:85:5 - call: public static java.lang.Number clojure.lang.Numbers.divide(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:85:5 - call: public static java.lang.Number clojure.lang.Numbers.divide(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:120:18 - call: public static boolean clojure.lang.Numbers.isPos(java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:126:18 - call: public static boolean clojure.lang.Numbers.isNeg(java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:128:9 - call: public static boolean clojure.lang.Numbers.gt(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:129:9 - call: public static boolean clojure.lang.Numbers.gt(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:132:9 - call: public static boolean clojure.lang.Numbers.lt(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:133:9 - call: public static boolean clojure.lang.Numbers.lt(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:136:7 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_minus(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:136:39 - call: public static boolean clojure.lang.Numbers.lt(java.lang.Object,java.lang.Object).
WARNING: reduce already refers to: #'clojure.core/reduce in namespace: quantum.core.reducers, being replaced by: #'quantum.core.reducers/reduce
Boxed math warning, quantum/core/reducers.cljc:480:7 - call: public static boolean clojure.lang.Numbers.lte(long,java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:506:27 - call: public static java.lang.Number clojure.lang.Numbers.quotient(java.lang.Object,long).
Boxed math warning, quantum/core/reducers.cljc:518:27 - call: public static java.lang.Number clojure.lang.Numbers.quotient(java.lang.Object,long).
Boxed math warning, quantum/core/reducers.cljc:813:16 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:964:25 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_minus(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:964:22 - call: public static java.lang.Number clojure.lang.Numbers.divide(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:974:21 - call: public static boolean clojure.lang.Numbers.isPos(java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:979:33 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:985:29 - call: public static java.lang.Number clojure.lang.Numbers.quotient(java.lang.Object,long).
Boxed math warning, quantum/core/reducers.cljc:986:29 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_multiply(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:987:29 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:1017:9 - call: public static boolean clojure.lang.Numbers.isNeg(java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:1020:18 - call: public static boolean clojure.lang.Numbers.isNeg(java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:1076:9 - call: public static boolean clojure.lang.Numbers.isNeg(java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:1079:18 - call: public static boolean clojure.lang.Numbers.isNeg(java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:1203:9 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:1203:9 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:1209:37 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:1209:64 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/string.cljc:136:24 - call: public static boolean clojure.lang.Numbers.gte(java.lang.Object,long).
Boxed math warning, quantum/core/string.cljc:137:22 - call: public static java.lang.Object clojure.lang.Numbers.min(java.lang.Object,long).
Boxed math warning, quantum/core/string.cljc:138:34 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(long,java.lang.Object).
Boxed math warning, quantum/core/string.cljc:138:29 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/string.cljc:138:22 - call: public static java.lang.Object clojure.lang.Numbers.max(long,java.lang.Object).
Boxed math warning, quantum/core/string.cljc:140:27 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/string.cljc:140:22 - call: public static java.lang.Object clojure.lang.Numbers.min(java.lang.Object,long).
Boxed math warning, quantum/core/string.cljc:256:3 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/string.cljc:266:3 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/string.cljc:298:15 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(long,java.lang.Object).
Boxed math warning, quantum/core/string.cljc:298:15 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(long,java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:148:55 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:166:35 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:167:35 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:168:49 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_minus(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:168:44 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:270:7 - call: public static boolean clojure.lang.Numbers.gt(long,java.lang.Object).
Reflection warning, quantum/core/collections/core.cljc:305:40 - call to method indexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
Reflection warning, quantum/core/collections/core.cljc:306:40 - call to method lastIndexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
Reflection warning, quantum/core/collections/core.cljc:305:40 - call to method indexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
Reflection warning, quantum/core/collections/core.cljc:306:40 - call to method lastIndexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
Reflection warning, quantum/core/time/core.cljc:76:40 - reference to field getTime can't be resolved.
Reflection warning, quantum/core/time/core.cljc:82:5 - call to method write can't be resolved (target class is unknown).
Reflection warning, quantum/core/time/core.cljc:83:5 - call to method write can't be resolved (target class is unknown).
Reflection warning, quantum/core/time/core.cljc:84:5 - call to method write can't be resolved (target class is unknown).
Boxed math warning, quantum/core/time/core.cljc:93:20 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
:error-while-loading quantum.auth.core
#error {
 :cause "Unable to resolve var: coll/conjl in this context"
 :via
 [{:type clojure.lang.Compiler$CompilerException
   :message "java.lang.RuntimeException: Unable to resolve var: coll/conjl in this context, compiling:(quantum/core/collections.cljc:151:1)"
   :at [clojure.lang.Compiler analyzeSeq "Compiler.java" 6740]}
  {:type java.lang.RuntimeException
   :message "Unable to resolve var: coll/conjl in this context"
   :at [clojure.lang.Util runtimeException "Util.java" 221]}]
 :trace
 [[clojure.lang.Util runtimeException "Util.java" 221]
  [clojure.lang.Compiler$TheVarExpr$Parser parse "Compiler.java" 698]
  [clojure.lang.Compiler analyzeSeq "Compiler.java" 6733]
  [clojure.lang.Compiler analyze "Compiler.java" 6524]
  [clojure.lang.Compiler access$300 "Compiler.java" 38]
  [clojure.lang.Compiler$LetExpr$Parser parse "Compiler.java" 6129]
  [clojure.lang.Compiler analyzeSeq "Compiler.java" 6733]
  [clojure.lang.Compiler analyze "Compiler.java" 6524]
  [clojure.lang.Compiler analyze "Compiler.java" 6485]
  [clojure.lang.Compiler$BodyExpr$Parser parse "Compiler.java" 5861]
  [clojure.lang.Compiler$FnMethod parse "Compiler.java" 5296]
  [clojure.lang.Compiler$FnExpr parse "Compiler.java" 3925]
  [clojure.lang.Compiler analyzeSeq "Compiler.java" 6731]
  [clojure.lang.Compiler analyze "Compiler.java" 6524]
  [clojure.lang.Compiler eval "Compiler.java" 6789]
  [clojure.lang.Compiler eval "Compiler.java" 6781]
  [clojure.lang.Compiler load "Compiler.java" 7237]
  [clojure.lang.RT loadResourceScript "RT.java" 371]
  [clojure.lang.RT loadResourceScript "RT.java" 362]
  [clojure.lang.RT load "RT.java" 446]
  [clojure.lang.RT load "RT.java" 412]
  [clojure.core$load$fn__5446 invoke "core.clj" 5862]
  [clojure.core$load doInvoke "core.clj" 5861]
  [clojure.lang.RestFn invoke "RestFn.java" 408]
  [clojure.core$load_one invoke "core.clj" 5667]
  [clojure.core$load_lib$fn__5395 invoke "core.clj" 5707]
  [clojure.core$load_lib doInvoke "core.clj" 5706]
  [clojure.lang.RestFn applyTo "RestFn.java" 142]
  [clojure.core$apply invoke "core.clj" 630]
  [clojure.core$load_libs doInvoke "core.clj" 5745]
  [clojure.lang.RestFn applyTo "RestFn.java" 137]
  [clojure.core$apply invoke "core.clj" 630]
  [clojure.core$require doInvoke "core.clj" 5828]
  [clojure.lang.RestFn invoke "RestFn.java" 3894]
  [quantum.core.ns$require_lib invoke "ns.cljc" 362]
  [quantum.core.ns$require_all invoke "ns.cljc" 463]
  [quantum.core.ns$require_all doInvoke "ns.cljc" 480]
  [clojure.lang.RestFn invoke "RestFn.java" 442]
  [quantum.auth.core$eval54348 invoke "core.clj" 10]
  [clojure.lang.Compiler eval "Compiler.java" 6792]
  [clojure.lang.Compiler load "Compiler.java" 7237]
  [clojure.lang.RT loadResourceScript "RT.java" 371]
  [clojure.lang.RT loadResourceScript "RT.java" 362]
  [clojure.lang.RT load "RT.java" 446]
  [clojure.lang.RT load "RT.java" 412]
  [clojure.core$load$fn__5446 invoke "core.clj" 5862]
  [clojure.core$load doInvoke "core.clj" 5861]
  [clojure.lang.RestFn invoke "RestFn.java" 408]
  [clojure.core$load_one invoke "core.clj" 5667]
  [clojure.core$load_lib$fn__5395 invoke "core.clj" 5707]
  [clojure.core$load_lib doInvoke "core.clj" 5706]
  [clojure.lang.RestFn applyTo "RestFn.java" 142]
  [clojure.core$apply invoke "core.clj" 630]
  [clojure.core$load_libs doInvoke "core.clj" 5745]
  [clojure.lang.RestFn applyTo "RestFn.java" 137]
  [clojure.core$apply invoke "core.clj" 630]
  [clojure.core$require doInvoke "core.clj" 5828]
  [clojure.lang.RestFn invoke "RestFn.java" 421]
  [clojure.tools.namespace.reload$track_reload_one invoke "reload.clj" 35]
  [clojure.tools.namespace.reload$track_reload invoke "reload.clj" 52]
  [clojure.lang.AFn applyToHelper "AFn.java" 154]
  [clojure.lang.AFn applyTo "AFn.java" 144]
  [clojure.lang.Var alterRoot "Var.java" 303]
  [clojure.core$alter_var_root doInvoke "core.clj" 5273]
  [clojure.lang.RestFn invoke "RestFn.java" 425]
  [clojure.tools.namespace.repl$do_refresh invoke "repl.clj" 94]
  [clojure.tools.namespace.repl$refresh_all doInvoke "repl.clj" 162]
  [clojure.lang.RestFn invoke "RestFn.java" 397(refresh-all)
]
  [test$eval53909 invoke "form-init3623728042651227831.clj" 8304]
  [clojure.lang.Compiler eval "Compiler.java" 6792]
  [clojure.lang.Compiler eval "Compiler.java" 6755]
  [clojure.core$eval invoke "core.clj" 3079]
  [clojure.main$repl$read_eval_print__7095$fn__7098 invoke "main.clj" 240]
  [clojure.main$repl$read_eval_print__7095 invoke "main.clj" 240]
  [clojure.main$repl$fn__7104 invoke "main.clj" 258]
  [clojure.main$repl doInvoke "main.clj" 258]
  [clojure.lang.RestFn invoke "RestFn.java" 421]
  [clojure.main$repl_opt invoke "main.clj" 324]
  [clojure.main$main doInvoke "main.clj" 422]
  [clojure.lang.RestFn invoke "RestFn.java" 397]
  [clojure.lang.Var invoke "Var.java" 375]
  [clojure.lang.AFn applyToHelper "AFn.java" 152]
  [clojure.lang.Var applyTo "Var.java" 700]
  [clojure.main main "main.java" 37]
  [sun.reflect.NativeMethodAccessorImpl invoke0 "NativeMethodAccessorImpl.java" -2]
  [sun.reflect.NativeMethodAccessorImpl invoke "NativeMethodAccessorImpl.java" 62]
  [sun.reflect.DelegatingMethodAccessorImpl invoke "DelegatingMethodAccessorImpl.java" 43]
  [java.lang.reflect.Method invoke "Method.java" 483]
  [clojure.lang.Reflector invokeMatchingMethod "Reflector.java" 93]
  [clojure.lang.Reflector invokeStaticMethod "Reflector.java" 207]
  [sun.reflect.NativeMethodAccessorImpl invoke0 "NativeMethodAccessorImpl.java" -2]
  [sun.reflect.NativeMethodAccessorImpl invoke "NativeMethodAccessorImpl.java" 62]
  [sun.reflect.DelegatingMethodAccessorImpl invoke "DelegatingMethodAccessorImpl.java" 43]
  [java.lang.reflect.Method invoke "Method.java" 483]
  [clojure.lang.Reflector invokeMatchingMethod "Reflector.java" 93]
  [clojure.lang.Reflector invokeStaticMethod "Reflector.java" 207]
  [user$eval5 invoke "form-init3623728042651227831.clj" 1]
  [clojure.lang.Compiler eval "Compiler.java" 6792]
  [clojure.lang.Compiler eval "Compiler.java" 6782]
  [clojure.lang.Compiler load "Compiler.java" 7237]
  [clojure.lang.Compiler loadFile "Compiler.java" 7175]
  [clojure.main$load_script invoke "main.clj" 275]
  [clojure.main$init_opt invoke "main.clj" 280]
  [clojure.main$initialize invoke "main.clj" 308]
  [clojure.main$null_opt invoke "main.clj" 343]
  [clojure.main$main doInvoke "main.clj" 421]
  [clojure.lang.RestFn invoke "RestFn.java" 421]
  [clojure.lang.Var invoke "Var.java" 383]
  [clojure.lang.AFn applyToHelper "AFn.java" 156]
  [clojure.lang.Var applyTo "Var.java" 700]
  [clojure.main main "main.java" 37]]}
test=> :reloading (quantum.core.ns quantum.auth.core quantum.web.core quantum.google.core quantum.google.drive.auth quantum.core.data.json quantum.http.core quantum.google.drive.core quantum.http.url quantum.core.network.deploy quantum.auth.oauth test quantum.core.collections quantum.ui.core quantum.core.time.core quantum.core.time.local quantum.core.data.binary quantum.core.thread quantum.core.network.core quantum.core.system quantum.core.macros quantum.ui.component quantum.datagrid.core quantum.core.type quantum.core.data.bytes quantum.core.io.core quantum.core.cryptography quantum.datagrid.excel quantum.core.time.coerce quantum.core.numeric quantum.core.data.xml quantum.core.collections.core quantum.core.log quantum.core.data.ftree quantum.core.io.serialization quantum.core.data.vector quantum.core.logic quantum.core.util.test quantum.core.loops quantum.core.data.hex quantum.core.reducers quantum.core.data.set quantum.core.print quantum.core.io.compress quantum.core.data.array quantum.core.data.queue quantum.ui.fonts quantum.core.nondeterministic quantum.core.string quantum.core.util.sh quantum.core.error quantum.core.util.bench quantum.core.java quantum.ui.init quantum.core.data.map quantum.core.function quantum.core.util.debug quantum.core.time.format quantum.ui.aux-fn)
Reflection warning, quantum/core/ns.cljc:116:11 - reference to field hasRoot can't be resolved.
Reflection warning, quantum/core/type.cljc:63:26 - reference to field isArray can't be resolved.
Boxed math warning, quantum/core/numeric.cljc:32:21 - call: public static boolean clojure.lang.Numbers.isNeg(java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:37:17 - call: public static boolean clojure.lang.Numbers.isNeg(java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:58:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:60:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:60:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:67:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_multiply(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:69:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_multiply(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:69:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_multiply(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:76:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_minus(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:78:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_minus(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:78:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_minus(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:83:5 - call: public static java.lang.Number clojure.lang.Numbers.divide(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:85:5 - call: public static java.lang.Number clojure.lang.Numbers.divide(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:85:5 - call: public static java.lang.Number clojure.lang.Numbers.divide(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:120:18 - call: public static boolean clojure.lang.Numbers.isPos(java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:126:18 - call: public static boolean clojure.lang.Numbers.isNeg(java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:128:9 - call: public static boolean clojure.lang.Numbers.gt(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:129:9 - call: public static boolean clojure.lang.Numbers.gt(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:132:9 - call: public static boolean clojure.lang.Numbers.lt(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:133:9 - call: public static boolean clojure.lang.Numbers.lt(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:136:7 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_minus(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:136:39 - call: public static boolean clojure.lang.Numbers.lt(java.lang.Object,java.lang.Object).
WARNING: reduce already refers to: #'clojure.core/reduce in namespace: quantum.core.reducers, being replaced by: #'quantum.core.reducers/reduce
Boxed math warning, quantum/core/reducers.cljc:480:7 - call: public static boolean clojure.lang.Numbers.lte(long,java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:506:27 - call: public static java.lang.Number clojure.lang.Numbers.quotient(java.lang.Object,long).
Boxed math warning, quantum/core/reducers.cljc:518:27 - call: public static java.lang.Number clojure.lang.Numbers.quotient(java.lang.Object,long).
Boxed math warning, quantum/core/reducers.cljc:813:16 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:964:25 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_minus(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:964:22 - call: public static java.lang.Number clojure.lang.Numbers.divide(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:974:21 - call: public static boolean clojure.lang.Numbers.isPos(java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:979:33 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:985:29 - call: public static java.lang.Number clojure.lang.Numbers.quotient(java.lang.Object,long).
Boxed math warning, quantum/core/reducers.cljc:986:29 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_multiply(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:987:29 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:1017:9 - call: public static boolean clojure.lang.Numbers.isNeg(java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:1020:18 - call: public static boolean clojure.lang.Numbers.isNeg(java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:1076:9 - call: public static boolean clojure.lang.Numbers.isNeg(java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:1079:18 - call: public static boolean clojure.lang.Numbers.isNeg(java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:1203:9 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:1203:9 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:1209:37 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:1209:64 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/string.cljc:136:24 - call: public static boolean clojure.lang.Numbers.gte(java.lang.Object,long).
Boxed math warning, quantum/core/string.cljc:137:22 - call: public static java.lang.Object clojure.lang.Numbers.min(java.lang.Object,long).
Boxed math warning, quantum/core/string.cljc:138:34 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(long,java.lang.Object).
Boxed math warning, quantum/core/string.cljc:138:29 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/string.cljc:138:22 - call: public static java.lang.Object clojure.lang.Numbers.max(long,java.lang.Object).
Boxed math warning, quantum/core/string.cljc:140:27 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/string.cljc:140:22 - call: public static java.lang.Object clojure.lang.Numbers.min(java.lang.Object,long).
Boxed math warning, quantum/core/string.cljc:256:3 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/string.cljc:266:3 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/string.cljc:298:15 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(long,java.lang.Object).
Boxed math warning, quantum/core/string.cljc:298:15 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(long,java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:148:55 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:166:35 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:167:35 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:168:49 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_minus(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:168:44 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:270:7 - call: public static boolean clojure.lang.Numbers.gt(long,java.lang.Object).
Reflection warning, quantum/core/collections/core.cljc:305:40 - call to method indexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
Reflection warning, quantum/core/collections/core.cljc:306:40 - call to method lastIndexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
Reflection warning, quantum/core/collections/core.cljc:305:40 - call to method indexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
Reflection warning, quantum/core/collections/core.cljc:306:40 - call to method lastIndexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
Reflection warning, quantum/core/time/core.cljc:76:40 - reference to field getTime can't be resolved.
Reflection warning, quantum/core/time/core.cljc:82:5 - call to method write can't be resolved (target class is unknown).
Reflection warning, quantum/core/time/core.cljc:83:5 - call to method write can't be resolved (target class is unknown).
Reflection warning, quantum/core/time/core.cljc:84:5 - call to method write can't be resolved (target class is unknown).
Boxed math warning, quantum/core/time/core.cljc:93:20 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:242:15 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:288:3 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:294:26 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:301:7 - call: public static boolean clojure.lang.Numbers.gt(long,java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:303:9 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:310:7 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:323:7 - call: public static boolean clojure.lang.Numbers.gt(long,java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:325:9 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:332:7 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:367:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:402:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:424:15 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_minus(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:471:3 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:659:24 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:777:20 - call: public static boolean clojure.lang.Numbers.gt(java.lang.Object,long).
Boxed math warning, quantum/core/collections.cljc:840:28 - call: public static java.lang.Number clojure.lang.Numbers.divide(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:841:16 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:902:33 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:902:33 - call: public static boolean clojure.lang.Numbers.lt(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:910:35 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:1045:33 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Reflection warning, quantum/core/collections.cljc:1192:14 - call to method put on java.util.HashMap can't be resolved (no such method).
Boxed math warning, quantum/core/collections.cljc:1402:25 - call: public static boolean clojure.lang.Numbers.lt(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/data/binary.cljc:12:18 - call: public static long clojure.lang.Numbers.and(long,java.lang.Object).
Boxed math warning, quantum/core/data/binary.cljc:12:30 - call: public static long clojure.lang.Numbers.shiftRight(long,java.lang.Object).
Boxed math warning, quantum/core/data/array.cljc:31:9 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/data/array.cljc:54:9 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/data/array.cljc:54:39 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(long,java.lang.Object).
Boxed math warning, quantum/core/data/array.cljc:76:9 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/data/array.cljc:76:39 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(long,java.lang.Object).
Boxed math warning, quantum/core/data/array.cljc:97:9 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/data/array.cljc:110:9 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Reflection warning, quantum/core/data/bytes.cljc:108:19 - call to static method aset on clojure.lang.RT can't be resolved (argument types: [C, int, unknown).
Reflection warning, quantum/core/data/bytes.cljc:109:19 - call to static method aset on clojure.lang.RT can't be resolved (argument types: [C, int, unknown).
Boxed math warning, quantum/core/io/serialization.cljc:75:34 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_multiply(java.lang.Object,long).
Boxed math warning, quantum/core/io/serialization.cljc:75:15 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Reflection warning, quantum/core/io/core.cljc:77:11 - call to java.lang.String ctor can't be resolved.
Boxed math warning, quantum/core/io/core.cljc:110:9 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/io/core.cljc:120:11 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_minus(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/io/core.cljc:123:24 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_minus(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/io/core.cljc:128:9 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/io/core.cljc:214:7 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Reflection warning, quantum/core/io/core.cljc:259:13 - call to method write on java.io.FileOutputStream can't be resolved (argument types: unknown).
Reflection warning, quantum/core/io/core.cljc:264:13 - call to method write can't be resolved (target class is unknown).
Reflection warning, quantum/core/io/core.cljc:266:13 - call to method write can't be resolved (target class is unknown).
Boxed math warning, quantum/core/io/core.cljc:290:9 - call: public static boolean clojure.lang.Numbers.gt(java.lang.Object,long).
Boxed math warning, quantum/core/io/core.cljc:304:23 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/io/core.cljc:308:25 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/thread.cljc:134:28 - call: public static java.lang.Number clojure.lang.Numbers.divide(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/thread.cljc:159:28 - call: public static java.lang.Number clojure.lang.Numbers.divide(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/thread.cljc:170:17 - call: public static boolean clojure.lang.Numbers.lt(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/thread.cljc:170:17 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Reflection warning, quantum/core/data/queue.cljc:70:19 - call to java.util.concurrent.LinkedBlockingQueue ctor can't be resolved.
Boxed math warning, quantum/core/util/bench.cljc:27:5 - call: public static java.lang.Number clojure.lang.Numbers.divide(java.lang.Object,java.lang.Object).
Reflection warning, quantum/core/util/debug.cljc:154:13 - reference to field getMessage can't be resolved.
Boxed math warning, quantum/core/util/debug.cljc:162:13 - call: public static boolean clojure.lang.Numbers.gt(long,java.lang.Object).
Boxed math warning, quantum/google/drive/core.clj:285:47 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(long,java.lang.Object).
Boxed math warning, quantum/google/drive/core.clj:287:47 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(long,java.lang.Object).
Boxed math warning, quantum/google/drive/core.clj:296:15 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/network/deploy.clj:63:11 - call: public static boolean clojure.lang.Numbers.lt(java.lang.Object,long).
Boxed math warning, quantum/core/collections.cljc:242:15 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:288:3 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:294:26 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:301:7 - call: public static boolean clojure.lang.Numbers.gt(long,java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:303:9 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:310:7 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:323:7 - call: public static boolean clojure.lang.Numbers.gt(long,java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:325:9 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:332:7 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:367:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:402:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:424:15 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_minus(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:471:3 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:659:24 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(java.lang.Object,java.lang.Object).
Warning: protocol #'quantum.core.collections/Contains? is overwriting function contains?
Boxed math warning, quantum/core/collections.cljc:777:20 - call: public static boolean clojure.lang.Numbers.gt(java.lang.Object,long).
Boxed math warning, quantum/core/collections.cljc:840:28 - call: public static java.lang.Number clojure.lang.Numbers.divide(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:841:16 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:902:33 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:902:33 - call: public static boolean clojure.lang.Numbers.lt(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:910:35 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/collections.cljc:1045:33 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Reflection warning, quantum/core/collections.cljc:1192:14 - call to method put on java.util.HashMap can't be resolved (no such method).
Boxed math warning, quantum/core/collections.cljc:1402:25 - call: public static boolean clojure.lang.Numbers.lt(java.lang.Object,java.lang.Object).
Reflection warning, quantum/core/time/core.cljc:76:40 - reference to field getTime can't be resolved.
Reflection warning, quantum/core/time/core.cljc:82:5 - call to method write can't be resolved (target class is unknown).
Reflection warning, quantum/core/time/core.cljc:83:5 - call to method write can't be resolved (target class is unknown).
Reflection warning, quantum/core/time/core.cljc:84:5 - call to method write can't be resolved (target class is unknown).
Boxed math warning, quantum/core/time/core.cljc:93:20 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/data/binary.cljc:12:18 - call: public static long clojure.lang.Numbers.and(long,java.lang.Object).
Boxed math warning, quantum/core/data/binary.cljc:12:30 - call: public static long clojure.lang.Numbers.shiftRight(long,java.lang.Object).
Boxed math warning, quantum/core/thread.cljc:134:28 - call: public static java.lang.Number clojure.lang.Numbers.divide(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/thread.cljc:159:28 - call: public static java.lang.Number clojure.lang.Numbers.divide(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/thread.cljc:170:17 - call: public static boolean clojure.lang.Numbers.lt(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/thread.cljc:170:17 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Reflection warning, quantum/datagrid/excel.clj:100:49 - reference to field getCreationHelper on java.lang.String can't be resolved.
Reflection warning, quantum/datagrid/excel.clj:100:49 - reference to field createDataFormat can't be resolved.
Reflection warning, quantum/datagrid/excel.clj:100:49 - call to method getFormat can't be resolved (target class is unknown).
Reflection warning, quantum/datagrid/excel.clj:211:28 - reference to field getCellComment can't be resolved.
Reflection warning, quantum/datagrid/excel.clj:212:28 - reference to field getString can't be resolved.
Reflection warning, quantum/datagrid/excel.clj:213:28 - reference to field getString can't be resolved.
Reflection warning, quantum/datagrid/excel.clj:219:12 - call to static method create on org.apache.poi.ss.usermodel.WorkbookFactory can't be resolved (argument types: unknown).
Reflection warning, quantum/datagrid/excel.clj:224:12 - call to static method create on org.apache.poi.ss.usermodel.WorkbookFactory can't be resolved (argument types: unknown).
Boxed math warning, quantum/datagrid/excel.clj:282:33 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/datagrid/excel.clj:283:60 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/datagrid/excel.clj:283:89 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Reflection warning, quantum/datagrid/excel.clj:288:3 - reference to field getSheet can't be resolved.
Reflection warning, quantum/datagrid/excel.clj:288:3 - reference to field getWorkbook can't be resolved.
Reflection warning, quantum/datagrid/excel.clj:288:3 - reference to field getCreationHelper can't be resolved.
Reflection warning, quantum/datagrid/excel.clj:295:19 - call to method createHyperlink can't be resolved (target class is unknown).
Reflection warning, quantum/datagrid/excel.clj:296:5 - call to method setAddress can't be resolved (target class is unknown).
Reflection warning, quantum/datagrid/excel.clj:300:3 - call to method createRichTextString can't be resolved (target class is unknown).
Reflection warning, quantum/datagrid/excel.clj:304:22 - reference to field createClientAnchor can't be resolved.
Reflection warning, quantum/datagrid/excel.clj:305:28 - reference to field getColumnIndex can't be resolved.
Reflection warning, quantum/datagrid/excel.clj:304:16 - call to method setCol1 can't be resolved (target class is unknown).
Reflection warning, quantum/datagrid/excel.clj:306:31 - reference to field getColumnIndex can't be resolved.
Boxed math warning, quantum/datagrid/excel.clj:306:28 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(java.lang.Object,java.lang.Object).
Reflection warning, quantum/datagrid/excel.clj:304:16 - call to method setCol2 can't be resolved (target class is unknown).
Reflection warning, quantum/datagrid/excel.clj:307:28 - reference to field getRowIndex can't be resolved.
Reflection warning, quantum/datagrid/excel.clj:304:16 - call to method setRow1 can't be resolved (target class is unknown).
Reflection warning, quantum/datagrid/excel.clj:308:31 - reference to field getRowIndex can't be resolved.
Boxed math warning, quantum/datagrid/excel.clj:308:28 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(java.lang.Object,java.lang.Object).
Reflection warning, quantum/datagrid/excel.clj:304:16 - call to method setRow2 can't be resolved (target class is unknown).
Reflection warning, quantum/datagrid/excel.clj:310:68 - reference to field getSheet can't be resolved.
Reflection warning, quantum/datagrid/excel.clj:310:43 - reference to field createDrawingPatriarch can't be resolved.
Reflection warning, quantum/datagrid/excel.clj:310:23 - call to method createCellComment can't be resolved (target class is unknown).
Reflection warning, quantum/datagrid/excel.clj:310:17 - call to method setString can't be resolved (target class is unknown).
Boxed math warning, quantum/datagrid/excel.clj:337:60 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/datagrid/excel.clj:339:43 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/datagrid/excel.clj:339:72 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/datagrid/excel.clj:345:22 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/datagrid/core.clj:21:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/datagrid/core.clj:24:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Reflection warning, quantum/datagrid/core.clj:39:14 - reference to field getCellStyle can't be resolved.
Reflection warning, quantum/datagrid/core.clj:40:14 - reference to field getFillForegroundColorColor can't be resolved.
Reflection warning, quantum/datagrid/core.clj:41:36 - reference to field getRgb can't be resolved.
Reflection warning, quantum/core/type.cljc:63:26 - reference to field isArray can't be resolved.
Reflection warning, quantum/core/data/bytes.cljc:108:19 - call to static method aset on clojure.lang.RT can't be resolved (argument types: [C, int, unknown).
Reflection warning, quantum/core/data/bytes.cljc:109:19 - call to static method aset on clojure.lang.RT can't be resolved (argument types: [C, int, unknown).
Reflection warning, quantum/core/io/core.cljc:77:11 - call to java.lang.String ctor can't be resolved.
Boxed math warning, quantum/core/io/core.cljc:110:9 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/io/core.cljc:120:11 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_minus(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/io/core.cljc:123:24 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_minus(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/io/core.cljc:128:9 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/io/core.cljc:214:7 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Reflection warning, quantum/core/io/core.cljc:259:13 - call to method write on java.io.FileOutputStream can't be resolved (argument types: unknown).
Reflection warning, quantum/core/io/core.cljc:264:13 - call to method write can't be resolved (target class is unknown).
Reflection warning, quantum/core/io/core.cljc:266:13 - call to method write can't be resolved (target class is unknown).
Boxed math warning, quantum/core/io/core.cljc:290:9 - call: public static boolean clojure.lang.Numbers.gt(java.lang.Object,long).
Boxed math warning, quantum/core/io/core.cljc:304:23 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/io/core.cljc:308:25 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Reflection warning, quantum/datagrid/excel.clj:100:49 - reference to field getCreationHelper on java.lang.String can't be resolved.
Reflection warning, quantum/datagrid/excel.clj:100:49 - reference to field createDataFormat can't be resolved.
Reflection warning, quantum/datagrid/excel.clj:100:49 - call to method getFormat can't be resolved (target class is unknown).
Reflection warning, quantum/datagrid/excel.clj:211:28 - reference to field getCellComment can't be resolved.
Reflection warning, quantum/datagrid/excel.clj:212:28 - reference to field getString can't be resolved.
Reflection warning, quantum/datagrid/excel.clj:213:28 - reference to field getString can't be resolved.
Reflection warning, quantum/datagrid/excel.clj:219:12 - call to static method create on org.apache.poi.ss.usermodel.WorkbookFactory can't be resolved (argument types: unknown).
Reflection warning, quantum/datagrid/excel.clj:224:12 - call to static method create on org.apache.poi.ss.usermodel.WorkbookFactory can't be resolved (argument types: unknown).
Boxed math warning, quantum/datagrid/excel.clj:282:33 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/datagrid/excel.clj:283:60 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/datagrid/excel.clj:283:89 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Reflection warning, quantum/datagrid/excel.clj:288:3 - reference to field getSheet can't be resolved.
Reflection warning, quantum/datagrid/excel.clj:288:3 - reference to field getWorkbook can't be resolved.
Reflection warning, quantum/datagrid/excel.clj:288:3 - reference to field getCreationHelper can't be resolved.
Reflection warning, quantum/datagrid/excel.clj:295:19 - call to method createHyperlink can't be resolved (target class is unknown).
Reflection warning, quantum/datagrid/excel.clj:296:5 - call to method setAddress can't be resolved (target class is unknown).
Reflection warning, quantum/datagrid/excel.clj:300:3 - call to method createRichTextString can't be resolved (target class is unknown).
Reflection warning, quantum/datagrid/excel.clj:304:22 - reference to field createClientAnchor can't be resolved.
Reflection warning, quantum/datagrid/excel.clj:305:28 - reference to field getColumnIndex can't be resolved.
Reflection warning, quantum/datagrid/excel.clj:304:16 - call to method setCol1 can't be resolved (target class is unknown).
Reflection warning, quantum/datagrid/excel.clj:306:31 - reference to field getColumnIndex can't be resolved.
Boxed math warning, quantum/datagrid/excel.clj:306:28 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(java.lang.Object,java.lang.Object).
Reflection warning, quantum/datagrid/excel.clj:304:16 - call to method setCol2 can't be resolved (target class is unknown).
Reflection warning, quantum/datagrid/excel.clj:307:28 - reference to field getRowIndex can't be resolved.
Reflection warning, quantum/datagrid/excel.clj:304:16 - call to method setRow1 can't be resolved (target class is unknown).
Reflection warning, quantum/datagrid/excel.clj:308:31 - reference to field getRowIndex can't be resolved.
Boxed math warning, quantum/datagrid/excel.clj:308:28 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(java.lang.Object,java.lang.Object).
Reflection warning, quantum/datagrid/excel.clj:304:16 - call to method setRow2 can't be resolved (target class is unknown).
Reflection warning, quantum/datagrid/excel.clj:310:68 - reference to field getSheet can't be resolved.
Reflection warning, quantum/datagrid/excel.clj:310:43 - reference to field createDrawingPatriarch can't be resolved.
Reflection warning, quantum/datagrid/excel.clj:310:23 - call to method createCellComment can't be resolved (target class is unknown).
Reflection warning, quantum/datagrid/excel.clj:310:17 - call to method setString can't be resolved (target class is unknown).
Boxed math warning, quantum/datagrid/excel.clj:337:60 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/datagrid/excel.clj:339:43 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/datagrid/excel.clj:339:72 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/datagrid/excel.clj:345:22 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:32:21 - call: public static boolean clojure.lang.Numbers.isNeg(java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:37:17 - call: public static boolean clojure.lang.Numbers.isNeg(java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:58:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:60:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:60:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:67:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_multiply(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:69:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_multiply(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:69:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_multiply(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:76:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_minus(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:78:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_minus(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:78:5 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_minus(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:83:5 - call: public static java.lang.Number clojure.lang.Numbers.divide(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:85:5 - call: public static java.lang.Number clojure.lang.Numbers.divide(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:85:5 - call: public static java.lang.Number clojure.lang.Numbers.divide(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:120:18 - call: public static boolean clojure.lang.Numbers.isPos(java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:126:18 - call: public static boolean clojure.lang.Numbers.isNeg(java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:128:9 - call: public static boolean clojure.lang.Numbers.gt(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:129:9 - call: public static boolean clojure.lang.Numbers.gt(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:132:9 - call: public static boolean clojure.lang.Numbers.lt(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:133:9 - call: public static boolean clojure.lang.Numbers.lt(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:136:7 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_minus(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/numeric.cljc:136:39 - call: public static boolean clojure.lang.Numbers.lt(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:148:55 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:166:35 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:167:35 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:168:49 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_minus(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:168:44 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/collections/core.cljc:270:7 - call: public static boolean clojure.lang.Numbers.gt(long,java.lang.Object).
Reflection warning, quantum/core/collections/core.cljc:305:40 - call to method indexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
Reflection warning, quantum/core/collections/core.cljc:306:40 - call to method lastIndexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
Reflection warning, quantum/core/collections/core.cljc:305:40 - call to method indexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
Reflection warning, quantum/core/collections/core.cljc:306:40 - call to method lastIndexOf on clojure.lang.IPersistentVector can't be resolved (no such method).
Boxed math warning, quantum/core/io/serialization.cljc:75:34 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_multiply(java.lang.Object,long).
Boxed math warning, quantum/core/io/serialization.cljc:75:15 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
WARNING: reduce already refers to: #'clojure.core/reduce in namespace: quantum.core.reducers, being replaced by: #'quantum.core.reducers/reduce
Boxed math warning, quantum/core/reducers.cljc:480:7 - call: public static boolean clojure.lang.Numbers.lte(long,java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:506:27 - call: public static java.lang.Number clojure.lang.Numbers.quotient(java.lang.Object,long).
Boxed math warning, quantum/core/reducers.cljc:518:27 - call: public static java.lang.Number clojure.lang.Numbers.quotient(java.lang.Object,long).
Boxed math warning, quantum/core/reducers.cljc:813:16 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:964:25 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_minus(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:964:22 - call: public static java.lang.Number clojure.lang.Numbers.divide(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:974:21 - call: public static boolean clojure.lang.Numbers.isPos(java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:979:33 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:985:29 - call: public static java.lang.Number clojure.lang.Numbers.quotient(java.lang.Object,long).
Boxed math warning, quantum/core/reducers.cljc:986:29 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_multiply(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:987:29 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:1017:9 - call: public static boolean clojure.lang.Numbers.isNeg(java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:1020:18 - call: public static boolean clojure.lang.Numbers.isNeg(java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:1076:9 - call: public static boolean clojure.lang.Numbers.isNeg(java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:1079:18 - call: public static boolean clojure.lang.Numbers.isNeg(java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:1203:9 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:1203:9 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:1209:37 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/reducers.cljc:1209:64 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/data/array.cljc:31:9 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/data/array.cljc:54:9 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/data/array.cljc:54:39 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(long,java.lang.Object).
Boxed math warning, quantum/core/data/array.cljc:76:9 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/data/array.cljc:76:39 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(long,java.lang.Object).
Boxed math warning, quantum/core/data/array.cljc:97:9 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/data/array.cljc:110:9 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Reflection warning, quantum/core/data/queue.cljc:70:19 - call to java.util.concurrent.LinkedBlockingQueue ctor can't be resolved.
 Loading fonts from /Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/Fonts...
Boxed math warning, quantum/core/nondeterministic.cljc:29:50 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/nondeterministic.cljc:37:9 - call: public static boolean clojure.lang.Numbers.equiv(java.lang.Object,long).
Boxed math warning, quantum/core/nondeterministic.cljc:65:24 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_multiply(java.lang.Object,long).
Boxed math warning, quantum/core/nondeterministic.cljc:70:39 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/nondeterministic.cljc:74:9 - call: public static boolean clojure.lang.Numbers.equiv(java.lang.Object,long).
Boxed math warning, quantum/core/nondeterministic.cljc:76:25 - call: public static boolean clojure.lang.Numbers.lt(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/string.cljc:136:24 - call: public static boolean clojure.lang.Numbers.gte(java.lang.Object,long).
Boxed math warning, quantum/core/string.cljc:137:22 - call: public static java.lang.Object clojure.lang.Numbers.min(java.lang.Object,long).
Boxed math warning, quantum/core/string.cljc:138:34 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(long,java.lang.Object).
Boxed math warning, quantum/core/string.cljc:138:29 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_dec(java.lang.Object).
Boxed math warning, quantum/core/string.cljc:138:22 - call: public static java.lang.Object clojure.lang.Numbers.max(long,java.lang.Object).
Boxed math warning, quantum/core/string.cljc:140:27 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(java.lang.Object,java.lang.Object).
Boxed math warning, quantum/core/string.cljc:140:22 - call: public static java.lang.Object clojure.lang.Numbers.min(java.lang.Object,long).
Boxed math warning, quantum/core/string.cljc:256:3 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/string.cljc:266:3 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).
Boxed math warning, quantum/core/string.cljc:298:15 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(long,java.lang.Object).
Boxed math warning, quantum/core/string.cljc:298:15 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_add(long,java.lang.Object).
Boxed math warning, quantum/core/util/bench.cljc:27:5 - call: public static java.lang.Number clojure.lang.Numbers.divide(java.lang.Object,java.lang.Object).
Reflection warning, quantum/core/util/debug.cljc:154:13 - reference to field getMessage can't be resolved.
Boxed math warning, quantum/core/util/debug.cljc:162:13 - call: public static boolean clojure.lang.Numbers.gt(long,java.lang.Object).
:ok
test=> (conjl (list 1 2 3) 4 5 6 7 )
IllegalArgumentException No implementation of method: :conjl of protocol: #'quantum.core.collections.core/CollMod found for class: clojure.lang.PersistentList  clojure.core/-cache-protocol-fn (core_deftype.clj:554)
test=> (clojure.core.collections.core/conjl (list 1 2 3) 4 5 6 7 )
ClassNotFoundException clojure.core.collections.core  java.net.URLClassLoader$1.run (URLClassLoader.java:372)
test=> (quantum.core.collections.core/conjl (list 1 2 3) 4 5 6 7 )
IllegalArgumentException No implementation of method: :conjl of protocol: #'quantum.core.collections.core/CollMod found for class: clojure.lang.PersistentList  clojure.core/-cache-protocol-fn (core_deftype.clj:554)
test=> (quantum.core.collections.core/conjl (list 1 2 3) 4 )
IllegalArgumentException No implementation of method: :conjl of protocol: #'quantum.core.collections.core/CollMod found for class: clojure.lang.PersistentList  clojure.core/-cache-protocol-fn (core_deftype.clj:554)
test=> 
test=> #?(:clj
(doseq [type (:vec type/types)]
  (extend type CollMod
    {:conjr-
     #?(:clj  conj
        :cljs (fn [coll args] (apply conj coll args)))})))
CompilerException java.lang.RuntimeException: Unable to resolve symbol: CollMod in this context, compiling:(/private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:8313:3) 
test=> (o)
CompilerException java.lang.RuntimeException: Unable to resolve symbol: o in this context, compiling:(/private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:8317:1) 
test=> (in-ns 'quantum.core.collections.core)
#object[clojure.lang.Namespace 0x2de2cd72 "quantum.core.collections.core"]
quantum.core.collections.core=> 
quantum.core.collections.core=> (defprotocol CollMod
  (conjl
    #?@(:clj ([coll a]
              [coll a b]
              [coll a b c]
              [coll a b c d] 
              [coll a b c d e])
       :cljs ([coll args])))
  (conjr-
    #?@(:clj  ([coll arg] [coll arg & args])
       :cljs ([coll args]))))
CollMod
quantum.core.collections.core=> 
quantum.core.collections.core=> (extend-protocol-for-all CollMod
  [java.util.List clojure.lang.IPersistentList
   clojure.lang.PersistentList] ; java.util.List isn't enough; clojure.lang.IPersistentList isn't enough
  (conjl
    ([coll a]           (->> coll (cons a)                                             ))
    ([coll a b]         (->> coll (cons b) (cons a)                                    ))
    ([coll a b c]       (->> coll (cons c) (cons b) (cons a)                           ))
    ([coll a b c d]     (->> coll (cons d) (cons c) (cons b) (cons a)                  ))
    ([coll a b c d e]   (->> coll (cons e) (cons d) (cons c) (cons b) (cons a)         ))
    ([coll a b c d e f] (->> coll (cons f) (cons e) (cons d) (cons c) (cons b) (cons a)))))
nil
quantum.core.collections.core=> (conjl (list 1 2 3) 4 )
(4 1 2 3)
quantum.core.collections.core=> 
quantum.core.collections.core=> (extend-protocol-for-all CollMod
  [clojure.lang.IPersistentVector]
  (conjl
    ([coll a]                  (catvec (vector+ a          ) coll))
    ([coll a b]                (catvec (vector+ a b        ) coll))
    ([coll a b c]              (catvec (vector+ a b c      ) coll))
    ([coll a b c d]            (catvec (vector+ a b c d    ) coll))
    ([coll a b c d e]          (catvec (vector+ a b c d e  ) coll))
    ([coll a b c d e f]        (catvec (vector+ a b c d e f) coll))
    ([coll a b c d e f & args] (catvec (apply vector+ args ) coll)))
  ; (conjl-
  ;   ([coll args] (apply conjl-vec coll args)))
  )
nil
quantum.core.collections.core=> 
quantum.core.collections.core=> #?(:clj
(doseq [type (:vec type/types)]
  (extend type CollMod
    {:conjr-
     #?(:clj  conj
        :cljs (fn [coll args] (apply conj coll args)))})))

; TODO CLJS compatible
#?(:clj
(doseq [type (:iseq type/types)]
  (extend type CollMod
    {:conjr-
      #?(:clj
           (fn ([coll arg]        (concat coll (list arg)))
               ([coll arg & args] (concat coll (cons arg args))))
         :cljs
           (fn [coll args] (concat coll args)))})))

; TODO: conjl with cons or conj, etc.


; TODO add arity
;(def conjl #?(:clj conjl- :cljs (fn [coll & args] (conjr- coll args))))
(def conjr #?(:clj conjr- :cljs (fn [coll & args] (conjl- coll args))))

(def doto! swap!)
nil
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> nil
quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> quantum.core.collections.core=> #'quantum.core.collections.core/conjr
quantum.core.collections.core=> quantum.core.collections.core=> #'quantum.core.collections.core/doto!
quantum.core.collections.core=> (conjl (list 1 2 3) 4 1 2 3)
IllegalArgumentException No implementation of method: :conjl of protocol: #'quantum.core.collections.core/CollMod found for class: clojure.lang.PersistentList  clojure.core/-cache-protocol-fn (core_deftype.clj:554)
quantum.core.collections.core=> (conjl (list 1 2 3) 4 1 )
IllegalArgumentException No implementation of method: :conjl of protocol: #'quantum.core.collections.core/CollMod found for class: clojure.lang.PersistentList  clojure.core/-cache-protocol-fn (core_deftype.clj:554)
quantum.core.collections.core=> (conjl (list 1 2 3) 4 )
IllegalArgumentException No implementation of method: :conjl of protocol: #'quantum.core.collections.core/CollMod found for class: clojure.lang.PersistentList  clojure.core/-cache-protocol-fn (core_deftype.clj:554)
quantum.core.collections.core=> 
quantum.core.collections.core=> 
quantum.core.collections.core=> (drop 2 [1 2 3 4 ])
(3 4)
quantum.core.collections.core=> 
quantum.core.collections.core=> (take-while (fn-not vector?) [1 2 3 4 ])
(1 2 3 4)
quantum.core.collections.core=> (take-while (fn-not vector?) [1 2 3 [4] ])
(1 2 3)
quantum.core.collections.core=> 
quantum.core.collections.core=> 
quantum.core.collections.core=> #?(:clj 
(defmacro extend-protocol-for-all+ [prot & body]
 `(loop [body-n# ~body]
    (when (nempty? body-n#)
      (let [classes#   (first body-n#)
            fns#       (-> body-n# rest (take-while (fn-not vector?)))
            rest-body# (-> body-n# rest (drop (count fns#)))]
        (doseq [class-n# ~classes]
          (apply (mfn extend-protocol) ~prot (eval class-n#) fns#))
        (recur rest-body#))))))
CompilerException java.lang.RuntimeException: Unable to resolve symbol: classes in this context, compiling:(/private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:8396:1) 
quantum.core.collections.core=> #?(:clj 
(defmacro extend-protocol-for-all+ [prot & body]
 `(loop [body-n# ~body]
    (when (nempty? body-n#)
      (let [classes#   (first body-n#)
            fns#       (-> body-n# rest (take-while (fn-not vector?)))
            rest-body# (-> body-n# rest (drop (count fns#)))]
        (doseq [class-n# classes#]
          (apply (mfn extend-protocol) ~prot (eval class-n#) fns#))
        (recur rest-body#))))))
#'quantum.core.collections.core/extend-protocol-for-all+
quantum.core.collections.core=> 
quantum.core.collections.core=> 
quantum.core.collections.core=> (extend-protocol-for-all+ CollMod
  [java.util.List clojure.lang.IPersistentList
   clojure.lang.PersistentList] ; java.util.List isn't enough; clojure.lang.IPersistentList isn't enough
    (conjl
      ([coll a]           (->> coll (cons a)                                             ))
      ([coll a b]         (->> coll (cons b) (cons a)                                    ))
      ([coll a b c]       (->> coll (cons c) (cons b) (cons a)                           ))
      ([coll a b c d]     (->> coll (cons d) (cons c) (cons b) (cons a)                  ))
      ([coll a b c d e]   (->> coll (cons e) (cons d) (cons c) (cons b) (cons a)         ))
      ([coll a b c d e f] (->> coll (cons f) (cons e) (cons d) (cons c) (cons b) (cons a))))
  [clojure.lang.IPersistentVector]
    (conjl
      ([coll a]                  (catvec (vector+ a          ) coll))
      ([coll a b]                (catvec (vector+ a b        ) coll))
      ([coll a b c]              (catvec (vector+ a b c      ) coll))
      ([coll a b c d]            (catvec (vector+ a b c d    ) coll))
      ([coll a b c d e]          (catvec (vector+ a b c d e  ) coll))
      ([coll a b c d e f]        (catvec (vector+ a b c d e f) coll))
      ([coll a b c d e f & args] (catvec (apply vector+ args ) coll))))
CompilerException java.lang.RuntimeException: Unable to resolve symbol: coll in this context, compiling:(/private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:8421:7) 
quantum.core.collections.core=> 
quantum.core.collections.core=> #?(:clj 
(defmacro extend-protocol-for-all+ [prot & body]
 `(loop [body-n# ~body]
    (when (nempty? body-n#)
      (let [classes#   (first body-n#)
            _ (println "classes#" classes#)
            fns#       (-> body-n# rest (take-while (fn-not vector?)))
            rest-body# (-> body-n# rest (drop (count fns#)))]
        (doseq [class-n# classes#]
          (apply (mfn extend-protocol) ~prot (eval class-n#) fns#))
        (recur rest-body#))))))

#'quantum.core.collections.core/extend-protocol-for-all+
quantum.core.collections.core=> quantum.core.collections.core=> (extend-protocol-for-all+ CollMod
  [java.util.List clojure.lang.IPersistentList
   clojure.lang.PersistentList] ; java.util.List isn't enough; clojure.lang.IPersistentList isn't enough
    (conjl
      ([coll a]           (->> coll (cons a)                                             ))
      ([coll a b]         (->> coll (cons b) (cons a)                                    ))
      ([coll a b c]       (->> coll (cons c) (cons b) (cons a)                           ))
      ([coll a b c d]     (->> coll (cons d) (cons c) (cons b) (cons a)                  ))
      ([coll a b c d e]   (->> coll (cons e) (cons d) (cons c) (cons b) (cons a)         ))
      ([coll a b c d e f] (->> coll (cons f) (cons e) (cons d) (cons c) (cons b) (cons a))))
  [clojure.lang.IPersistentVector]
    (conjl
      ([coll a]                  (catvec (vector+ a          ) coll))
      ([coll a b]                (catvec (vector+ a b        ) coll))
      ([coll a b c]              (catvec (vector+ a b c      ) coll))
      ([coll a b c d]            (catvec (vector+ a b c d    ) coll))
      ([coll a b c d e]          (catvec (vector+ a b c d e  ) coll))
      ([coll a b c d e f]        (catvec (vector+ a b c d e f) coll))
      ([coll a b c d e f & args] (catvec (apply vector+ args ) coll))))
CompilerException java.lang.RuntimeException: Unable to resolve symbol: coll in this context, compiling:(/private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:8453:7) 
quantum.core.collections.core=> (def (list 'CollMod 'clojure.lang.IPersistentList '(conjl  ([coll a]           (->> coll (cons a))) )))
CompilerException java.lang.RuntimeException: First argument to def must be a Symbol, compiling:(/private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:8468:1) 
quantum.core.collections.core=> (def temp (list 'CollMod 'clojure.lang.IPersistentList '(conjl  ([coll a]           (->> coll (cons a))) )))
#'quantum.core.collections.core/temp
quantum.core.collections.core=> temp 
(CollMod clojure.lang.IPersistentList (conjl ([coll a] (->> coll (cons a)))))
quantum.core.collections.core=> (apply (mfn extend-protocol) temp)
CompilerException java.lang.RuntimeException: Unable to resolve symbol: mfn in this context, compiling:(/private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:8471:8) 
quantum.core.collections.core=> (apply (memfn extend-protocol) temp)
Reflection warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:8472:8 - call to method extend_protocol can't be resolved (target class is unknown).
ArityException Wrong number of args (3) passed to: core/eval67090/fn--67092  clojure.lang.AFn.throwArity (AFn.java:429)
quantum.core.collections.core=> (memfn extend-protocol)
Reflection warning, /private/var/folders/04/271b9vcn1xsd36k6x1893d000000gn/T/form-init3623728042651227831.clj:8473:1 - call to method extend_protocol can't be resolved (target class is unknown).
#object[quantum.core.collections.core$eval67096$fn__67097 0x768ea1fa "quantum.core.collections.core$eval67096$fn__67097@768ea1fa"]
quantum.core.collections.core=> `(extend-protocol ~@temp)
(clojure.core/extend-protocol CollMod clojure.lang.IPersistentList (conjl ([coll a] (->> coll (cons a)))))
quantum.core.collections.core=> (eval `(extend-protocol ~@temp))
nil
quantum.core.collections.core=> #?(:clj 
(defmacro extend-protocol-for-all+ [prot & body]
 `(loop [body-n# ~body] (println ~body)
    ;(when (nempty? body-n#)
    ;  (let [classes#   (first body-n#)
    ;        _ (println "classes#" classes#)
    ;        fns#       (-> body-n# rest (take-while (fn-not vector?)))
    ;        rest-body# (-> body-n# rest (drop (count fns#)))]
    ;    (doseq [class-n# classes#]
    ;      (apply (mfn extend-protocol) ~prot (eval class-n#) fns#))
    ;    (recur rest-body#))) 
)))