(ns quantum.core.data.vector
  (:require
    [quantum.core.ns :as ns :refer
            [alias-ns defalias]
                                                
                                                           
                                                                      ]
    [quantum.core.type       :as type :refer [instance+?]]
    [clojure.core.rrb-vector :as vec+]
                                         )
       
  (:import
    clojure.core.Vec
    (clojure.core.rrb_vector.rrbt Vector)
    (quantum.core.ns
      Nil Bool Num ExactNum Int Decimal Key Set
             ArrList TreeMap LSeq Regex Editable Transient Queue Map))
        (:gen-class))

; slice
(def catvec  vec+/catvec)
(def vec+    vec+/vec)
(def vector+ vec+/vector)

(defn subvec+ [coll a b]
  ; produces a new vector containing the appropriate subrange of the input vector in logarithmic time
  ; (in contrast to clojure.core/subvec, which returns a reference to the input vector)
  ; clojure.core/subvec is a constant-time operation that prevents the underlying vector
  ; from becoming eligible for garbage collection
  (try (vec+/subvec coll a b)
    (catch
             IllegalArgumentException
                     
      _
      (subvec coll a b))))

(defn vector+? [obj]
  (instance+?
           clojure.core.rrb_vector.rrbt.Vector
                                               obj))

(defn conjl
  {:todo ["Add support for conjl with other data structures."]}
  ([vec-0 elem]
    (-> elem vector+ (catvec vec-0)))
  ([vec-0 elem & elems]
    (reduce conjl elem elems)))
;;;;;;;;;;;; This file autogenerated from src/cljx/quantum/core/data/vector.cljx
