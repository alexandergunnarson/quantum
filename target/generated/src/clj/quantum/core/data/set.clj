(ns quantum.core.data.set
  (:require
    [quantum.core.ns :as ns :refer
            [alias-ns defalias]
                                                
                                                           
                                                                      ]
          [clojure.set              :as set]
          [clojure.data.avl         :as avl]
          [clojure.data.finger-tree :as ftree]
          [flatland.ordered.set     :as oset])
       
  (:import
    clojure.core.Vec
    (quantum.core.ns
      Nil Bool Num ExactNum Int Decimal Key Set
             ArrList TreeMap LSeq Regex Editable Transient Queue Map))
        (:gen-class))

(def union          set/union)
(def intersection   set/intersection)
(def difference     set/difference)
      (def ordered-set    oset/ordered-set)
      (def c-sorted-set   ftree/counted-sorted-set) ; sorted set that provides log-n nth
(def sorted-set+    avl/sorted-set)
(def sorted-set-by+ avl/sorted-set-by)

(defn xset?
  {:attribution "Alex Gunnarson"
   :todo ["Improve performance"]}
  [fn-key set1 set2]
  (let [funcs 
         (case fn-key
           :sub          {:eq <= :fn #(vector (fn [s] (contains? %2 s)) %1)}
           :super        {:eq >= :fn #(vector (fn [s] (contains? %1 s)) %2)}
           :proper-sub   {:eq <  :fn #(vector %2 %1)}
           :proper-super {:eq >  :fn #(vector %1 %2)})]
    (and ((:eq funcs) (count set1) (count set2))
         (apply every? ((:fn funcs) set1 set2)))))
; probably a way to make this more terse, like a "define-vars" macro with intern or something
(def subset?          #(xset? :sub          %1 %2))
(def superset?        #(xset? :super        %1 %2))
(def proper-subset?   #(xset? :proper-sub   %1 %2))
(def proper-superset? #(xset? :proper-super %1 %2))

;;;;;;;;;;;; This file autogenerated from src/cljx/quantum/core/data/set.cljx
