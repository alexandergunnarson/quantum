;; Analyzed by ClojureScript 0.0-3269
{:use-macros nil, :excludes #{range sorted-set split-at sorted-set-by sorted-map-by sorted-map}, :name clojure.data.avl, :imports nil, :requires nil, :uses nil, :defs {split-key {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/public/js/compiled/out/clojure/data/avl.cljs", :line 1164, :column 7, :end-line 1164, :end-column 16, :arglists (quote ([k coll])), :doc "(alpha)\n\n  Returns [left e? right], where left and right are collections of\n  the same type as coll and containing, respectively, the keys below\n  and above k in the ordering determined by coll's comparator, while\n  e? is the entry at key k for maps, the stored copy of the key k for\n  sets, nil if coll does not contain k."}, :name clojure.data.avl/split-key, :variadic false, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 16, :method-params ([k coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1164, :end-line 1164, :max-fixed-arity 2, :fn-var true, :arglists (quote ([k coll])), :doc "(alpha)\n\n  Returns [left e? right], where left and right are collections of\n  the same type as coll and containing, respectively, the keys below\n  and above k in the ordering determined by coll's comparator, while\n  e? is the entry at key k for maps, the stored copy of the key k for\n  sets, nil if coll does not contain k."}, AVLMap {:num-fields 5, :protocols #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection clojure.data.avl/Object cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name clojure.data.avl/AVLMap, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 16, :type true, :column 10, :line 762, :record false, :end-line 762, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, maybe-rebalance {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/public/js/compiled/out/clojure/data/avl.cljs", :line 230, :column 17, :end-line 230, :end-column 32, :private true, :arglists (quote ([node]))}, :private true, :name clojure.data.avl/maybe-rebalance, :variadic false, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 32, :method-params ([node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 230, :end-line 230, :max-fixed-arity 1, :fn-var true, :arglists (quote ([node]))}, seq-push {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/public/js/compiled/out/clojure/data/avl.cljs", :line 669, :column 17, :end-line 669, :end-column 25, :private true, :arglists (quote ([node stack ascending?]))}, :private true, :name clojure.data.avl/seq-push, :variadic false, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 25, :method-params ([node stack ascending?]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 669, :end-line 669, :max-fixed-arity 3, :fn-var true, :arglists (quote ([node stack ascending?]))}, ensure-editable {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/public/js/compiled/out/clojure/data/avl.cljs", :line 75, :column 17, :end-line 75, :end-column 32, :private true, :arglists (quote ([edit] [edit node])), :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([edit] [edit node]), :arglists ([edit] [edit node]), :arglists-meta (nil nil)}}, :private true, :name clojure.data.avl/ensure-editable, :variadic false, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 32, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([edit] [edit node]), :arglists ([edit] [edit node]), :arglists-meta (nil nil)}, :method-params ([edit] [edit node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 75, :end-line 75, :max-fixed-arity 2, :fn-var true, :arglists ([edit] [edit node])}, rotate-right! {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/public/js/compiled/out/clojure/data/avl.cljs", :line 160, :column 17, :end-line 160, :end-column 30, :private true, :arglists (quote ([edit node]))}, :private true, :name clojure.data.avl/rotate-right!, :variadic false, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 30, :method-params ([edit node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 160, :end-line 160, :max-fixed-arity 2, :fn-var true, :arglists (quote ([edit node]))}, rank-of {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/public/js/compiled/out/clojure/data/avl.cljs", :line 1150, :column 7, :end-line 1150, :end-column 14, :arglists (quote ([coll x])), :doc "Returns the rank of x in coll or -1 if not present."}, :name clojure.data.avl/rank-of, :variadic false, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 14, :method-params ([coll x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1150, :end-line 1150, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll x])), :doc "Returns the rank of x in coll or -1 if not present."}, AVLMapSeq {:num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection clojure.data.avl/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name clojure.data.avl/AVLMapSeq, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 19, :type true, :column 10, :line 695, :record false, :end-line 695, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, join {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/public/js/compiled/out/clojure/data/avl.cljs", :line 527, :column 17, :end-line 527, :end-column 21, :private true, :arglists (quote ([comp left-count left right]))}, :private true, :name clojure.data.avl/join, :variadic false, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 21, :method-params ([comp left-count left right]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 527, :end-line 527, :max-fixed-arity 4, :fn-var true, :arglists (quote ([comp left-count left right]))}, height {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/public/js/compiled/out/clojure/data/avl.cljs", :line 89, :column 17, :end-line 89, :end-column 23, :private true, :arglists (quote ([node]))}, :private true, :name clojure.data.avl/height, :variadic false, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 23, :method-params ([node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 89, :end-line 89, :max-fixed-arity 1, :fn-var true, :arglists (quote ([node]))}, range {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/public/js/compiled/out/clojure/data/avl.cljs", :line 656, :column 17, :end-line 656, :end-column 22, :private true, :arglists (quote ([comp node low high]))}, :private true, :name clojure.data.avl/range, :variadic false, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 22, :method-params ([comp node low high]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 656, :end-line 656, :max-fixed-arity 4, :fn-var true, :arglists (quote ([comp node low high]))}, rotate-left {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/public/js/compiled/out/clojure/data/avl.cljs", :line 94, :column 17, :end-line 94, :end-column 28, :private true, :arglists (quote ([node]))}, :private true, :name clojure.data.avl/rotate-left, :variadic false, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 28, :method-params ([node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 94, :end-line 94, :max-fixed-arity 1, :fn-var true, :arglists (quote ([node]))}, select {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/public/js/compiled/out/clojure/data/avl.cljs", :line 209, :column 17, :end-line 209, :end-column 23, :private true, :arglists (quote ([node rank]))}, :private true, :name clojure.data.avl/select, :variadic false, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 23, :method-params ([node rank]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 209, :end-line 209, :max-fixed-arity 2, :fn-var true, :arglists (quote ([node rank]))}, ->AVLTransientSet {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/public/js/compiled/out/clojure/data/avl.cljs", :line 1060, :column 10, :end-line 1060, :end-column 25, :protocols #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :factory :positional, :arglists (quote ([transient-avl-map]))}, :protocols #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :name clojure.data.avl/->AVLTransientSet, :variadic false, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 25, :method-params ([transient-avl-map]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 1060, :end-line 1060, :max-fixed-arity 1, :fn-var true, :arglists (quote ([transient-avl-map])), :skip-protocol-flag #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}}, rotate-left! {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/public/js/compiled/out/clojure/data/avl.cljs", :line 118, :column 17, :end-line 118, :end-column 29, :private true, :arglists (quote ([edit node]))}, :private true, :name clojure.data.avl/rotate-left!, :variadic false, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 29, :method-params ([edit node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 118, :end-line 118, :max-fixed-arity 2, :fn-var true, :arglists (quote ([edit node]))}, nearest {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/public/js/compiled/out/clojure/data/avl.cljs", :line 1155, :column 7, :end-line 1155, :end-column 14, :arglists (quote ([coll test x])), :doc "(alpha)\n\n  Equivalent to, but more efficient than, (first (subseq* coll test x)),\n  where subseq* is clojure.core/subseq for test in #{>, >=} and\n  clojure.core/rsubseq for test in #{<, <=}."}, :name clojure.data.avl/nearest, :variadic false, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 14, :method-params ([coll test x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1155, :end-line 1155, :max-fixed-arity 3, :fn-var true, :arglists (quote ([coll test x])), :doc "(alpha)\n\n  Equivalent to, but more efficient than, (first (subseq* coll test x)),\n  where subseq* is clojure.core/subseq for test in #{>, >=} and\n  clojure.core/rsubseq for test in #{<, <=}."}, insert {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/public/js/compiled/out/clojure/data/avl.cljs", :line 314, :column 17, :end-line 314, :end-column 23, :private true, :arglists (quote ([comp node k v found?]))}, :private true, :name clojure.data.avl/insert, :variadic false, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 23, :method-params ([comp node k v found?]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 314, :end-line 314, :max-fixed-arity 5, :fn-var true, :arglists (quote ([comp node k v found?]))}, AVLSet {:num-fields 3, :protocols #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection clojure.data.avl/Object cljs.core/IEditableCollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/ILookup}, :name clojure.data.avl/AVLSet, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 16, :type true, :column 10, :line 960, :record false, :end-line 960, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/ILookup}}, AVLTransientMap {:num-fields 4, :protocols #{cljs.core/IFn cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :name clojure.data.avl/AVLTransientMap, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 25, :type true, :column 10, :line 905, :record false, :end-line 905, :skip-protocol-flag #{cljs.core/IFn cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}}, maybe-rebalance! {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/public/js/compiled/out/clojure/data/avl.cljs", :line 274, :column 17, :end-line 274, :end-column 33, :private true, :arglists (quote ([edit node]))}, :private true, :name clojure.data.avl/maybe-rebalance!, :variadic false, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 33, :method-params ([edit node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 274, :end-line 274, :max-fixed-arity 2, :fn-var true, :arglists (quote ([edit node]))}, rotate-right {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/public/js/compiled/out/clojure/data/avl.cljs", :line 136, :column 17, :end-line 136, :end-column 29, :private true, :arglists (quote ([node]))}, :private true, :name clojure.data.avl/rotate-right, :variadic false, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 29, :method-params ([node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 136, :end-line 136, :max-fixed-arity 1, :fn-var true, :arglists (quote ([node]))}, AVLTransientSet {:num-fields 1, :protocols #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :name clojure.data.avl/AVLTransientSet, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 25, :type true, :column 10, :line 1060, :record false, :end-line 1060, :skip-protocol-flag #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}}, lookup-nearest {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/public/js/compiled/out/clojure/data/avl.cljs", :line 187, :column 17, :end-line 187, :end-column 31, :private true, :arglists (quote ([comp node test k]))}, :private true, :name clojure.data.avl/lookup-nearest, :variadic false, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 31, :method-params ([comp node test k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 187, :end-line 187, :max-fixed-arity 4, :fn-var true, :arglists (quote ([comp node test k]))}, ->AVLSet {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/public/js/compiled/out/clojure/data/avl.cljs", :line 960, :column 10, :end-line 960, :end-column 16, :protocols #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection clojure.data.avl/Object cljs.core/IEditableCollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/ILookup}, :factory :positional, :arglists (quote ([_meta avl-map _hash]))}, :protocols #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection clojure.data.avl/Object cljs.core/IEditableCollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/ILookup}, :name clojure.data.avl/->AVLSet, :variadic false, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 16, :method-params ([_meta avl-map _hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 960, :end-line 960, :max-fixed-arity 3, :fn-var true, :arglists (quote ([_meta avl-map _hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/ILookup}}, ->AVLNode {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/public/js/compiled/out/clojure/data/avl.cljs", :line 20, :column 10, :end-line 20, :end-column 17, :protocols #{clojure.data.avl/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([edit key val left right height rank]))}, :protocols #{clojure.data.avl/Object}, :name clojure.data.avl/->AVLNode, :variadic false, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 17, :method-params ([edit key val left right height rank]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 20, :end-line 20, :max-fixed-arity 7, :fn-var true, :arglists (quote ([edit key val left right height rank])), :skip-protocol-flag nil}, lookup {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/public/js/compiled/out/clojure/data/avl.cljs", :line 178, :column 17, :end-line 178, :end-column 23, :private true, :arglists (quote ([comp node k]))}, :private true, :name clojure.data.avl/lookup, :variadic false, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 23, :method-params ([comp node k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 178, :end-line 178, :max-fixed-arity 3, :fn-var true, :arglists (quote ([comp node k]))}, sorted-set {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/public/js/compiled/out/clojure/data/avl.cljs", :line 1136, :column 7, :end-line 1136, :end-column 17, :arglists (quote ([& keys])), :doc "Returns a new sorted set with supplied keys.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keys)], :arglists ([& keys]), :arglists-meta (nil)}}, :name clojure.data.avl/sorted-set, :variadic true, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keys)], :arglists ([& keys]), :arglists-meta (nil)}, :method-params [(keys)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 1136, :end-line 1136, :max-fixed-arity 0, :fn-var true, :arglists ([& keys]), :doc "Returns a new sorted set with supplied keys."}, rank {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/public/js/compiled/out/clojure/data/avl.cljs", :line 218, :column 17, :end-line 218, :end-column 21, :private true, :arglists (quote ([comp node k]))}, :private true, :name clojure.data.avl/rank, :variadic false, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 21, :method-params ([comp node k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 218, :end-line 218, :max-fixed-arity 3, :fn-var true, :arglists (quote ([comp node k]))}, avl-map-kv-reduce {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/public/js/compiled/out/clojure/data/avl.cljs", :line 681, :column 17, :end-line 681, :end-column 34, :private true, :arglists (quote ([node f init]))}, :private true, :name clojure.data.avl/avl-map-kv-reduce, :variadic false, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 34, :method-params ([node f init]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 681, :end-line 681, :max-fixed-arity 3, :fn-var true, :arglists (quote ([node f init]))}, get-rightmost {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/public/js/compiled/out/clojure/data/avl.cljs", :line 386, :column 17, :end-line 386, :end-column 30, :private true, :arglists (quote ([node]))}, :private true, :name clojure.data.avl/get-rightmost, :variadic false, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 30, :method-params ([node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 386, :end-line 386, :max-fixed-arity 1, :fn-var true, :arglists (quote ([node]))}, split-at {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/public/js/compiled/out/clojure/data/avl.cljs", :line 1193, :column 7, :end-line 1193, :end-column 15, :arglists (quote ([n coll])), :doc "(alpha)\n\n  Equivalent to, but more efficient than,\n  [(into (empty coll) (take n coll))\n   (into (empty coll) (drop n coll))]."}, :name clojure.data.avl/split-at, :variadic false, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 15, :method-params ([n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1193, :end-line 1193, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n coll])), :doc "(alpha)\n\n  Equivalent to, but more efficient than,\n  [(into (empty coll) (take n coll))\n   (into (empty coll) (drop n coll))]."}, delete {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/public/js/compiled/out/clojure/data/avl.cljs", :line 428, :column 17, :end-line 428, :end-column 23, :private true, :arglists (quote ([comp node k found?]))}, :private true, :name clojure.data.avl/delete, :variadic false, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 23, :method-params ([comp node k found?]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 428, :end-line 428, :max-fixed-arity 4, :fn-var true, :arglists (quote ([comp node k found?]))}, AVLNode {:num-fields 7, :protocols #{clojure.data.avl/Object}, :name clojure.data.avl/AVLNode, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 17, :type true, :column 10, :line 20, :record false, :end-line 20, :skip-protocol-flag nil}, insert! {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/public/js/compiled/out/clojure/data/avl.cljs", :line 354, :column 17, :end-line 354, :end-column 24, :private true, :arglists (quote ([edit comp node k v found?]))}, :private true, :name clojure.data.avl/insert!, :variadic false, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 24, :method-params ([edit comp node k v found?]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 354, :end-line 354, :max-fixed-arity 6, :fn-var true, :arglists (quote ([edit comp node k v found?]))}, sorted-set-by {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/public/js/compiled/out/clojure/data/avl.cljs", :line 1141, :column 7, :end-line 1141, :end-column 20, :arglists (quote ([comparator & keys])), :doc "Returns a new sorted set with supplied keys, using the supplied comparator.", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(comparator keys)], :arglists ([comparator & keys]), :arglists-meta (nil)}}, :name clojure.data.avl/sorted-set-by, :variadic true, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 20, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(comparator keys)], :arglists ([comparator & keys]), :arglists-meta (nil)}, :method-params [(comparator keys)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 1141, :end-line 1141, :max-fixed-arity 1, :fn-var true, :arglists ([comparator & keys]), :doc "Returns a new sorted set with supplied keys, using the supplied comparator."}, empty-set {:name clojure.data.avl/empty-set, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :line 1099, :column 1, :end-line 1099, :end-column 25, :private true, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/public/js/compiled/out/clojure/data/avl.cljs", :line 1099, :column 16, :end-line 1099, :end-column 25, :private true}}, create-seq {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/public/js/compiled/out/clojure/data/avl.cljs", :line 678, :column 17, :end-line 678, :end-column 27, :private true, :arglists (quote ([node ascending? cnt]))}, :private true, :name clojure.data.avl/create-seq, :variadic false, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 27, :method-params ([node ascending? cnt]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 678, :end-line 678, :max-fixed-arity 3, :fn-var true, :arglists (quote ([node ascending? cnt]))}, empty-map {:name clojure.data.avl/empty-map, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :line 1097, :column 1, :end-line 1097, :end-column 25, :private true, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/public/js/compiled/out/clojure/data/avl.cljs", :line 1097, :column 16, :end-line 1097, :end-column 25, :private true}}, split {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/public/js/compiled/out/clojure/data/avl.cljs", :line 605, :column 17, :end-line 605, :end-column 22, :private true, :arglists (quote ([comp node k]))}, :private true, :name clojure.data.avl/split, :variadic false, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 22, :method-params ([comp node k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 605, :end-line 605, :max-fixed-arity 3, :fn-var true, :arglists (quote ([comp node k]))}, delete-rightmost {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/public/js/compiled/out/clojure/data/avl.cljs", :line 391, :column 17, :end-line 391, :end-column 33, :private true, :arglists (quote ([node]))}, :private true, :name clojure.data.avl/delete-rightmost, :variadic false, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 33, :method-params ([node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 391, :end-line 391, :max-fixed-arity 1, :fn-var true, :arglists (quote ([node]))}, delete-rightmost! {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/public/js/compiled/out/clojure/data/avl.cljs", :line 403, :column 17, :end-line 403, :end-column 34, :private true, :arglists (quote ([edit node]))}, :private true, :name clojure.data.avl/delete-rightmost!, :variadic false, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 34, :method-params ([edit node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 403, :end-line 403, :max-fixed-arity 2, :fn-var true, :arglists (quote ([edit node]))}, ->AVLMap {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/public/js/compiled/out/clojure/data/avl.cljs", :line 762, :column 10, :end-line 762, :end-column 16, :protocols #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection clojure.data.avl/Object cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :factory :positional, :arglists (quote ([comp tree cnt _meta _hash]))}, :protocols #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection clojure.data.avl/Object cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name clojure.data.avl/->AVLMap, :variadic false, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 16, :method-params ([comp tree cnt _meta _hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 762, :end-line 762, :max-fixed-arity 5, :fn-var true, :arglists (quote ([comp tree cnt _meta _hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, delete! {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/public/js/compiled/out/clojure/data/avl.cljs", :line 477, :column 17, :end-line 477, :end-column 24, :private true, :arglists (quote ([edit comp node k found?]))}, :private true, :name clojure.data.avl/delete!, :variadic false, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 24, :method-params ([edit comp node k found?]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 477, :end-line 477, :max-fixed-arity 5, :fn-var true, :arglists (quote ([edit comp node k found?]))}, sorted-map-by {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/public/js/compiled/out/clojure/data/avl.cljs", :line 1125, :column 7, :end-line 1125, :end-column 20, :arglists (quote ([comparator & keyvals])), :doc "keyval => key val\n  Returns a new sorted map with supplied mappings, using the supplied\n  comparator.", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(comparator keyvals)], :arglists ([comparator & keyvals]), :arglists-meta (nil)}}, :name clojure.data.avl/sorted-map-by, :variadic true, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 20, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(comparator keyvals)], :arglists ([comparator & keyvals]), :arglists-meta (nil)}, :method-params [(comparator keyvals)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 1125, :end-line 1125, :max-fixed-arity 1, :fn-var true, :arglists ([comparator & keyvals]), :doc "keyval => key val\n  Returns a new sorted map with supplied mappings, using the supplied\n  comparator."}, ->AVLMapSeq {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/public/js/compiled/out/clojure/data/avl.cljs", :line 695, :column 10, :end-line 695, :end-column 19, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection clojure.data.avl/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([_meta stack ascending? cnt _hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection clojure.data.avl/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name clojure.data.avl/->AVLMapSeq, :variadic false, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 19, :method-params ([_meta stack ascending? cnt _hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 695, :end-line 695, :max-fixed-arity 5, :fn-var true, :arglists (quote ([_meta stack ascending? cnt _hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, subrange {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/public/js/compiled/out/clojure/data/avl.cljs", :line 1207, :column 7, :end-line 1207, :end-column 15, :arglists (quote ([coll test limit] [coll start-test start end-test end])), :doc "(alpha)\n\n  Returns an AVL collection comprising the entries of coll between\n  start and end (in the sense determined by coll's comparator) in\n  logarithmic time. Whether the endpoints are themselves included in\n  the returned collection depends on the provided tests; start-test\n  must be either > or >=, end-test must be either < or <=.\n\n  When passed a single test and limit, subrange infers the other end\n  of the range from the test: > / >= mean to include items up to the\n  end of coll, < / <= mean to include items taken from the beginning\n  of coll.\n\n  (subrange >= start <= end) is equivalent to, but more efficient\n  than, (into (empty coll) (subseq coll >= start <= end).", :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([coll test limit] [coll start-test start end-test end]), :arglists ([coll test limit] [coll start-test start end-test end]), :arglists-meta (nil nil)}}, :name clojure.data.avl/subrange, :variadic false, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 15, :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([coll test limit] [coll start-test start end-test end]), :arglists ([coll test limit] [coll start-test start end-test end]), :arglists-meta (nil nil)}, :method-params ([coll test limit] [coll start-test start end-test end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1207, :end-line 1207, :max-fixed-arity 5, :fn-var true, :arglists ([coll test limit] [coll start-test start end-test end]), :doc "(alpha)\n\n  Returns an AVL collection comprising the entries of coll between\n  start and end (in the sense determined by coll's comparator) in\n  logarithmic time. Whether the endpoints are themselves included in\n  the returned collection depends on the provided tests; start-test\n  must be either > or >=, end-test must be either < or <=.\n\n  When passed a single test and limit, subrange infers the other end\n  of the range from the test: > / >= mean to include items up to the\n  end of coll, < / <= mean to include items taken from the beginning\n  of coll.\n\n  (subrange >= start <= end) is equivalent to, but more efficient\n  than, (into (empty coll) (subseq coll >= start <= end)."}, sorted-map {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/public/js/compiled/out/clojure/data/avl.cljs", :line 1116, :column 7, :end-line 1116, :end-column 17, :arglists (quote ([& keyvals])), :doc "keyval => key val\n  Returns a new AVL map with supplied mappings.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}}, :name clojure.data.avl/sorted-map, :variadic true, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}, :method-params [(keyvals)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 1116, :end-line 1116, :max-fixed-arity 0, :fn-var true, :arglists ([& keyvals]), :doc "keyval => key val\n  Returns a new AVL map with supplied mappings."}, ->AVLTransientMap {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/resources/public/js/compiled/out/clojure/data/avl.cljs", :line 905, :column 10, :end-line 905, :end-column 25, :protocols #{cljs.core/IFn cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/IFn cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :factory :positional, :arglists (quote ([edit comp tree cnt]))}, :protocols #{cljs.core/IFn cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :name clojure.data.avl/->AVLTransientMap, :variadic false, :file "resources/public/js/compiled/out/clojure/data/avl.cljs", :end-column 25, :method-params ([edit comp tree cnt]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 905, :end-line 905, :max-fixed-arity 4, :fn-var true, :arglists (quote ([edit comp tree cnt])), :skip-protocol-flag #{cljs.core/IFn cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}}}, :require-macros nil, :cljs.analyzer/constants {:seen #{:else}, :order [:else]}, :doc "An implementation of persistent sorted maps and sets based on AVL\n  trees which can be used as drop-in replacements for Clojure's\n  built-in sorted maps and sets based on red-black trees. Apart from\n  the standard sorted collection API, the provided map and set types\n  support the transients API and several additional logarithmic time\n  operations: rank queries via clojure.core/nth (select element by\n  rank) and clojure.data.avl/rank-of (discover rank of element),\n  \"nearest key\" lookups via clojure.data.avl/nearest, splits by key\n  and index via clojure.data.avl/split-key and\n  clojure.data.avl/split-at, respectively, and subsets/submaps using\n  clojure.data.avl/subrange."}