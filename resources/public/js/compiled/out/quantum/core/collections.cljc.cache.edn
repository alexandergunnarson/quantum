;; Analyzed by ClojureScript 0.0-3269
{:use-macros {whenf*n quantum.core.logic, condfc quantum.core.logic, ifn quantum.core.logic, defalias quantum.core.ns, whencf*n quantum.core.logic, with->> quantum.core.function, <- quantum.core.function, whenc quantum.core.logic, mfn quantum.core.function, if*n quantum.core.logic, condf*n quantum.core.logic, fn-> quantum.core.function, reducei quantum.core.loops, for quantum.core.loops, whenf quantum.core.logic, should-transientize? quantum.core.type, condf quantum.core.logic, fn->> quantum.core.function}, :excludes #{reduce contains? butlast first peek last rest range doseq repeatedly get into vec second pop merge for count repeat}, :name quantum.core.collections, :imports nil, :requires {set quantum.core.data.set, logic quantum.core.logic, log quantum.core.log, map quantum.core.data.map, quantum.core.type quantum.core.type, num quantum.core.numeric, async cljs.core.async, quantum.core.numeric quantum.core.numeric, fn quantum.core.function, walk clojure.walk, quantum.core.collections.core quantum.core.collections.core, vec quantum.core.data.vector, quantum.core.log quantum.core.log, cljs.core.async cljs.core.async, ns quantum.core.ns, quantum.core.data.vector quantum.core.data.vector, quantum.core.logic quantum.core.logic, err quantum.core.error, quantum.core.loops quantum.core.loops, coll quantum.core.collections.core, type quantum.core.type, quantum.core.reducers quantum.core.reducers, quantum.core.data.set quantum.core.data.set, loops quantum.core.loops, str quantum.core.string, red quantum.core.reducers, quantum.core.string quantum.core.string, clojure.walk clojure.walk, quantum.core.error quantum.core.error, quantum.core.ns quantum.core.ns, quantum.core.data.map quantum.core.data.map, quantum.core.function quantum.core.function}, :uses {vector+? quantum.core.data.vector, Editable quantum.core.ns, any? quantum.core.logic, greatest quantum.core.numeric, boolean? quantum.core.type, sorted-map? quantum.core.type, close! cljs.core.async, Nil quantum.core.ns, *fn quantum.core.function, Bool quantum.core.ns, f*n quantum.core.function, chan cljs.core.async, IllegalArgumentException quantum.core.ns, fn-not quantum.core.logic, conjl quantum.core.data.vector, catvec quantum.core.data.vector, Vec quantum.core.ns, nnil? quantum.core.logic, Num quantum.core.ns, double? quantum.core.type, map-entry? quantum.core.type, Regex quantum.core.ns, transient? quantum.core.type, regex? quantum.core.type, Key quantum.core.ns, pattern? quantum.core.type, subvec+ quantum.core.data.vector, zeroid quantum.core.function, Map quantum.core.ns, ArrList quantum.core.ns, name-from-class quantum.core.type, array-list? quantum.core.type, LSeq quantum.core.ns, fn-or quantum.core.logic, coll+? quantum.core.type, Set quantum.core.ns, splice-or quantum.core.logic, fn-eq? quantum.core.logic, editable? quantum.core.type, ExactNum quantum.core.ns, instance+? quantum.core.type, fn-and quantum.core.logic, fn* quantum.core.function, fn= quantum.core.logic, queue? quantum.core.type, compr quantum.core.function, Queue quantum.core.ns, TreeMap quantum.core.ns, least quantum.core.numeric, Exception quantum.core.ns, class quantum.core.type, Decimal quantum.core.ns, Int quantum.core.ns, lseq? quantum.core.type, nempty? quantum.core.logic, Transient quantum.core.ns, map-entry quantum.core.data.map, unary quantum.core.function}, :defs {dissocs+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 1047, :column 7, :end-line 1047, :end-column 15, :arglists (quote ([coll & ks])), :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(coll ks)], :arglists ([coll & ks]), :arglists-meta (nil)}}, :name quantum.core.collections/dissocs+, :variadic true, :file "src/cljc/quantum/core/collections.cljc", :end-column 15, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(coll ks)], :arglists ([coll & ks]), :arglists-meta (nil)}, :method-params [(coll ks)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 1047, :end-line 1047, :max-fixed-arity 1, :fn-var true, :arglists ([coll & ks])}, third {:name quantum.core.collections/third, :file "src/cljc/quantum/core/collections.cljc", :line 155, :column 1, :end-line 155, :end-column 16, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 155, :column 11, :end-line 155, :end-column 16}}, reduce {:name quantum.core.collections/reduce, :file "src/cljc/quantum/core/collections.cljc", :line 83, :column 1, :end-line 83, :end-column 17, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 83, :column 11, :end-line 83, :end-column 17}}, contains? {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 686, :column 4, :end-line 686, :end-column 13, :protocol quantum.core.collections/Contains?, :doc nil, :arglists (quote ([coll elem]))}, :protocol quantum.core.collections/Contains?, :name quantum.core.collections/contains?, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 13, :method-params ([coll elem]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 685, :end-line 686, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll elem])), :doc nil}, postwalk {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 1313, :column 7, :end-line 1313, :end-column 15, :arglists (quote ([f form])), :doc "Performs a depth-first, post-order traversal of form.  Calls f on\n  each sub-form, uses f's return value in place of the original.\n  Recognizes all Clojure data structures. Consumes seqs as with doall.", :attribution "Stuart Sierra, stuartsierra/clojure.walk2"}, :name quantum.core.collections/postwalk, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 15, :method-params ([f form]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1313, :attribution "Stuart Sierra, stuartsierra/clojure.walk2", :end-line 1313, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f form])), :doc "Performs a depth-first, post-order traversal of form.  Calls f on\n  each sub-form, uses f's return value in place of the original.\n  Recognizes all Clojure data structures. Consumes seqs as with doall."}, updates+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 934, :column 7, :end-line 934, :end-column 15, :arglists (quote ([coll & kfs])), :doc "For each key-function pair in @kfs,\n   updates value in an associative data structure @coll associated with key\n   by applying the function @f to the existing value.", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(coll kfs)], :arglists ([coll & kfs]), :arglists-meta (nil)}}, :name quantum.core.collections/updates+, :variadic true, :file "src/cljc/quantum/core/collections.cljc", :end-column 15, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(coll kfs)], :arglists ([coll & kfs]), :arglists-meta (nil)}, :method-params [(coll kfs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 934, :end-line 934, :max-fixed-arity 1, :fn-var true, :arglists ([coll & kfs]), :doc "For each key-function pair in @kfs,\n   updates value in an associative data structure @coll associated with key\n   by applying the function @f to the existing value."}, popr {:name quantum.core.collections/popr, :file "src/cljc/quantum/core/collections.cljc", :line 150, :column 1, :end-line 150, :end-column 15, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 150, :column 11, :end-line 150, :end-column 15}}, butlast {:name quantum.core.collections/butlast, :file "src/cljc/quantum/core/collections.cljc", :line 159, :column 1, :end-line 159, :end-column 18, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 159, :column 11, :end-line 159, :end-column 18}}, single? {:name quantum.core.collections/single?, :file "src/cljc/quantum/core/collections.cljc", :line 589, :column 1, :end-line 589, :end-column 13, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 589, :column 6, :end-line 589, :end-column 13}, :doc "Does coll have only one element?"}, first {:name quantum.core.collections/first, :file "src/cljc/quantum/core/collections.cljc", :line 153, :column 1, :end-line 153, :end-column 16, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 153, :column 11, :end-line 153, :end-column 16}}, assoc-in! {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 1009, :column 7, :end-line 1009, :end-column 16, :arglists (quote ([m ks v])), :doc "Associates a value in a nested associative structure, where ks is a sequence of keys\n  and v is the new value and returns a new nested structure. The associative structure\n  can have transients in it, but if any levels do not exist, non-transient hash-maps will\n  be created."}, :name quantum.core.collections/assoc-in!, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 16, :method-params ([m ks v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1009, :end-line 1009, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m ks v])), :doc "Associates a value in a nested associative structure, where ks is a sequence of keys\n  and v is the new value and returns a new nested structure. The associative structure\n  can have transients in it, but if any levels do not exist, non-transient hash-maps will\n  be created."}, filteri+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 291, :column 7, :end-line 291, :end-column 15, :arglists (quote ([pred coll])), :todo ["Use reducers"]}, :name quantum.core.collections/filteri+, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 15, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 291, :todo ["Use reducers"], :end-line 291, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred coll]))}, extend-coll-to {:protocol-inline nil, :meta {:private true, :file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :end-column 22, :column 8, :usage "USAGE: (extend-coll-to [1 2 3] 5) => [1 2 3 nil nil]", :line 888, :attribution "Alex Gunnarson", :end-line 888, :arglists (quote ([coll-0 k])), :doc "Extends an associative structure (for now, only vector) to a given index."}, :private true, :name quantum.core.collections/extend-coll-to, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 22, :method-params ([coll-0 k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :usage "USAGE: (extend-coll-to [1 2 3] 5) => [1 2 3 nil nil]", :line 888, :attribution "Alex Gunnarson", :end-line 888, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll-0 k])), :doc "Extends an associative structure (for now, only vector) to a given index."}, assoc-in+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 1005, :column 7, :end-line 1005, :end-column 16, :arglists (quote ([coll ks v]))}, :name quantum.core.collections/assoc-in+, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 16, :method-params ([coll ks v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1005, :end-line 1005, :max-fixed-arity 3, :fn-var true, :arglists (quote ([coll ks v]))}, peek {:name quantum.core.collections/peek, :file "src/cljc/quantum/core/collections.cljc", :line 152, :column 1, :end-line 152, :end-column 15, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 152, :column 11, :end-line 152, :end-column 15}}, get-key {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 790, :column 7, :end-line 790, :end-column 14, :arglists (quote ([m obj]))}, :name quantum.core.collections/get-key, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 14, :method-params ([m obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 790, :end-line 790, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m obj]))}, last {:name quantum.core.collections/last, :file "src/cljc/quantum/core/collections.cljc", :line 160, :column 1, :end-line 160, :end-column 15, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 160, :column 11, :end-line 160, :end-column 15}}, assoc+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 905, :column 7, :end-line 905, :end-column 13, :arglists (quote ([coll-0 k v] [coll-0 k v & kvs-0])), :todo ["Protocolize on IEditableCollection" "Probably has performance issues"], :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([coll-0 k v]), :arglists ([coll-0 k v] [coll-0 k v & kvs-0]), :arglists-meta (nil nil)}}, :name quantum.core.collections/assoc+, :variadic true, :file "src/cljc/quantum/core/collections.cljc", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([coll-0 k v]), :arglists ([coll-0 k v] [coll-0 k v & kvs-0]), :arglists-meta (nil nil)}, :method-params ([coll-0 k v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 905, :todo ["Protocolize on IEditableCollection" "Probably has performance issues"], :end-line 905, :max-fixed-arity 3, :fn-var true, :arglists ([coll-0 k v] [coll-0 k v & kvs-0])}, keys+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 814, :column 7, :end-line 814, :end-column 12, :arglists (quote ([m])), :attribution "Alex Gunnarson", :todo ["Compare performance with core functions"]}, :name quantum.core.collections/keys+, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 12, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 814, :attribution "Alex Gunnarson", :todo ["Compare performance with core functions"], :end-line 814, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m]))}, lrepeatedly {:name quantum.core.collections/lrepeatedly, :file "src/cljc/quantum/core/collections.cljc", :line 185, :column 1, :end-line 185, :end-column 17, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 185, :column 6, :end-line 185, :end-column 17}}, remove-vals+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 807, :column 7, :end-line 807, :end-column 19, :arglists (quote ([pred coll]))}, :name quantum.core.collections/remove-vals+, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 19, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 807, :end-line 807, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred coll]))}, get-in+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 583, :column 7, :end-line 583, :end-column 14, :arglists (quote ([coll [iden :as keys-0]]))}, :name quantum.core.collections/get-in+, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 14, :method-params ([coll p__30662]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 583, :end-line 583, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll [iden :as keys-0]]))}, group-merge-with+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :end-column 31, :column 14, :line 1190, :out "[{:b 65, :a 5} {:a 1, :b 2}]", :attribution "Alex Gunnarson", :todo ["Can probably make the |merge| process parallel."], :end-line 1190, :tag Delay, :arglists (quote ([group-by-f merge-with-f coll])), :in [":a" "(fn [k v1 v2] v1)" "[{:a 1 :b 2} {:a 1 :b 5} {:a 5 :b 65}]"]}, :name quantum.core.collections/group-merge-with+, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 31, :method-params ([group-by-f merge-with-f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1190, :out "[{:b 65, :a 5} {:a 1, :b 2}]", :attribution "Alex Gunnarson", :todo ["Can probably make the |merge| process parallel."], :ret-tag Delay, :end-line 1190, :max-fixed-arity 3, :tag Delay, :fn-var true, :arglists (quote ([group-by-f merge-with-f coll])), :in [":a" "(fn [k v1 v2] v1)" "[{:a 1 :b 2} {:a 1 :b 5} {:a 5 :b 65}]"]}, drop+ {:name quantum.core.collections/drop+, :file "src/cljc/quantum/core/collections.cljc", :line 97, :column 1, :end-line 97, :end-column 16, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 97, :column 11, :end-line 97, :end-column 16}}, rest {:name quantum.core.collections/rest, :file "src/cljc/quantum/core/collections.cljc", :line 156, :column 1, :end-line 156, :end-column 15, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 156, :column 11, :end-line 156, :end-column 15}}, update-in! {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 975, :column 7, :end-line 975, :end-column 17, :arglists (quote ([m [k & ks] f & args])), :doc "'Updates' a value in a nested associative structure, where ks is a sequence of keys and\n  f is a function that will take the old value and any supplied args and return the new\n  value, and returns a new nested structure. The associative structure can have transients\n  in it, but if any levels do not exist, non-transient hash-maps will be created.", :attribution "flatland.useful", :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(m [k & ks] f args)], :arglists ([m [k & ks] f & args]), :arglists-meta (nil)}}, :name quantum.core.collections/update-in!, :variadic true, :file "src/cljc/quantum/core/collections.cljc", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(m [k & ks] f args)], :arglists ([m [k & ks] f & args]), :arglists-meta (nil)}, :method-params [(m [k & ks] f args)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 975, :attribution "flatland.useful", :end-line 975, :max-fixed-arity 3, :fn-var true, :arglists ([m [k & ks] f & args]), :doc "'Updates' a value in a nested associative structure, where ks is a sequence of keys and\n  f is a function that will take the old value and any supplied args and return the new\n  value, and returns a new nested structure. The associative structure can have transients\n  in it, but if any levels do not exist, non-transient hash-maps will be created."}, lasti {:name quantum.core.collections/lasti, :file "src/cljc/quantum/core/collections.cljc", :line 141, :column 1, :end-line 141, :end-column 16, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 141, :column 11, :end-line 141, :end-column 16}}, range {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 201, :column 7, :end-line 201, :end-column 12, :arglists (quote ([] [a] [a b])), :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([] [a] [a b]), :arglists ([] [a] [a b]), :arglists-meta (nil nil nil)}}, :name quantum.core.collections/range, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 12, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([] [a] [a b]), :arglists ([] [a] [a b]), :arglists-meta (nil nil nil)}, :method-params ([] [a] [a b]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 201, :end-line 201, :max-fixed-arity 2, :fn-var true, :arglists ([] [a] [a b])}, select {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 433, :column 7, :end-line 433, :end-column 13, :arglists (quote ([coll & fns])), :doc "Applies a list of functions, @fns, separately to an object, @coll.\n   A good use case is returning values from an associative structure with keys as @fns.\n   Returns a vector of the results.", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(coll fns)], :arglists ([coll & fns]), :arglists-meta (nil)}}, :name quantum.core.collections/select, :variadic true, :file "src/cljc/quantum/core/collections.cljc", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(coll fns)], :arglists ([coll & fns]), :arglists-meta (nil)}, :method-params [(coll fns)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 433, :end-line 433, :max-fixed-arity 1, :fn-var true, :arglists ([coll & fns]), :doc "Applies a list of functions, @fns, separately to an object, @coll.\n   A good use case is returning values from an associative structure with keys as @fns.\n   Returns a vector of the results."}, re-assocs+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 1089, :column 7, :end-line 1089, :end-column 17, :arglists (quote ([coll & kfs])), :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(coll kfs)], :arglists ([coll & kfs]), :arglists-meta (nil)}}, :name quantum.core.collections/re-assocs+, :variadic true, :file "src/cljc/quantum/core/collections.cljc", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(coll kfs)], :arglists ([coll & kfs]), :arglists-meta (nil)}, :method-params [(coll kfs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 1089, :end-line 1089, :max-fixed-arity 1, :fn-var true, :arglists ([coll & kfs])}, abs-difference {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 214, :column 12, :end-line 214, :end-column 26, :tag Set, :arglists (quote ([a b])), :doc "Returns the absolute difference between a and b.\n   That is, (a diff b) union (b diff a).", :todo ["Probably a better name for this."]}, :name quantum.core.collections/abs-difference, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 26, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 214, :todo ["Probably a better name for this."], :ret-tag Set, :end-line 214, :max-fixed-arity 2, :tag Set, :fn-var true, :arglists (quote ([a b])), :doc "Returns the absolute difference between a and b.\n   That is, (a diff b) union (b diff a)."}, split-with-v+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 878, :column 7, :end-line 878, :end-column 20, :arglists (quote ([pred coll-0]))}, :name quantum.core.collections/split-with-v+, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 20, :method-params ([pred coll-0]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 878, :end-line 878, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred coll-0]))}, gets {:name quantum.core.collections/gets, :file "src/cljc/quantum/core/collections.cljc", :line 147, :column 1, :end-line 147, :end-column 15, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 147, :column 11, :end-line 147, :end-column 15}}, walk2-transient {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 1276, :column 8, :end-line 1276, :end-column 23, :private true, :arglists (quote ([coll f]))}, :private true, :name quantum.core.collections/walk2-transient, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 23, :method-params ([coll f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1276, :end-line 1276, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll f]))}, Walkable {:meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 1244, :column 30, :end-line 1244, :end-column 38, :added "1.6", :doc nil, :protocol-symbol true, :protocol-info {:methods {walk2 [[coll f]]}}}, :protocol-symbol true, :added "1.6", :name quantum.core.collections/Walkable, :file "src/cljc/quantum/core/collections.cljc", :end-column 38, :column 1, :line 1244, :protocol-info {:methods {walk2 [[coll f]]}}, :info nil, :end-line 1244, :impls #{}, :doc nil}, last-index-of {:name quantum.core.collections/last-index-of, :file "src/cljc/quantum/core/collections.cljc", :line 143, :column 1, :end-line 143, :end-column 24, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 143, :column 11, :end-line 143, :end-column 24}}, select-keys-delay {:protocol-inline nil, :meta {:private true, :file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :end-column 32, :column 15, :line 756, :todo ["FIX THIS"], :end-line 756, :tag Delay, :arglists (quote ([ks m])), :doc "Not as fast as select-keys with transients."}, :private true, :name quantum.core.collections/select-keys-delay, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 32, :method-params ([ks m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 756, :todo ["FIX THIS"], :ret-tag Delay, :end-line 756, :max-fixed-arity 2, :tag Delay, :fn-var true, :arglists (quote ([ks m])), :doc "Not as fast as select-keys with transients."}, lrest {:name quantum.core.collections/lrest, :file "src/cljc/quantum/core/collections.cljc", :line 157, :column 1, :end-line 157, :end-column 16, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 157, :column 11, :end-line 157, :end-column 16}}, filter-keys+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 804, :column 7, :end-line 804, :end-column 19, :arglists (quote ([pred coll]))}, :name quantum.core.collections/filter-keys+, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 19, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 804, :end-line 804, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred coll]))}, ffilteri+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :end-column 26, :column 17, :line 276, :out ["4" "3"], :todo ["Use a delayed reduction as the base!" "Allow parallelization"], :end-line 276, :tag MapEntry, :arglists (quote ([pred coll])), :in [(quote (ffilteri+ fn-eq? "4")) (quote ["a" "d" "t" "4" "10"])]}, :name quantum.core.collections/ffilteri+, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 26, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 276, :out ["4" "3"], :todo ["Use a delayed reduction as the base!" "Allow parallelization"], :ret-tag MapEntry, :end-line 276, :max-fixed-arity 2, :tag MapEntry, :fn-var true, :arglists (quote ([pred coll])), :in [(quote (ffilteri+ fn-eq? "4")) (quote ["a" "d" "t" "4" "10"])]}, update+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 926, :column 7, :end-line 926, :end-column 14, :arglists (quote ([coll k f] [coll k f args])), :doc "Updates the value in an associative data structure @coll associated with key @k\n   by applying the function @f to the existing value.", :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([coll k f] [coll k f args]), :arglists ([coll k f] [coll k f args]), :arglists-meta (nil nil)}}, :name quantum.core.collections/update+, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 14, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([coll k f] [coll k f args]), :arglists ([coll k f] [coll k f args]), :arglists-meta (nil nil)}, :method-params ([coll k f] [coll k f args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 926, :end-line 926, :max-fixed-arity 4, :fn-var true, :arglists ([coll k f] [coll k f args]), :doc "Updates the value in an associative data structure @coll associated with key @k\n   by applying the function @f to the existing value."}, take-untili+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 363, :column 7, :end-line 363, :end-column 19, :arglists (quote ([obj sub-obj]))}, :name quantum.core.collections/take-untili+, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 19, :method-params ([obj sub-obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 363, :end-line 363, :max-fixed-arity 2, :fn-var true, :arglists (quote ([obj sub-obj]))}, get {:name quantum.core.collections/get, :file "src/cljc/quantum/core/collections.cljc", :line 146, :column 1, :end-line 146, :end-column 14, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 146, :column 11, :end-line 146, :end-column 14}}, into {:name quantum.core.collections/into, :file "src/cljc/quantum/core/collections.cljc", :line 82, :column 1, :end-line 82, :end-column 15, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 82, :column 11, :end-line 82, :end-column 15}}, dropl+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 409, :column 7, :end-line 409, :end-column 13, :arglists (quote ([obj n])), :attribution "Alex Gunnarson"}, :name quantum.core.collections/dropl+, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 13, :method-params ([obj n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 409, :attribution "Alex Gunnarson", :end-line 409, :max-fixed-arity 2, :fn-var true, :arglists (quote ([obj n]))}, dissoc+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 1031, :column 7, :end-line 1031, :end-column 14, :arglists (quote ([coll key-0] [coll key-0 & keys-0])), :todo ["Protocolize"], :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([coll key-0]), :arglists ([coll key-0] [coll key-0 & keys-0]), :arglists-meta (nil nil)}}, :name quantum.core.collections/dissoc+, :variadic true, :file "src/cljc/quantum/core/collections.cljc", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([coll key-0]), :arglists ([coll key-0] [coll key-0 & keys-0]), :arglists-meta (nil nil)}, :method-params ([coll key-0]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1031, :todo ["Protocolize"], :end-line 1031, :max-fixed-arity 2, :fn-var true, :arglists ([coll key-0] [coll key-0 & keys-0])}, filter-vals+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 806, :column 7, :end-line 806, :end-column 19, :arglists (quote ([pred coll]))}, :name quantum.core.collections/filter-vals+, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 19, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 806, :end-line 806, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred coll]))}, getf {:name quantum.core.collections/getf, :file "src/cljc/quantum/core/collections.cljc", :line 148, :column 1, :end-line 148, :end-column 15, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 148, :column 11, :end-line 148, :end-column 15}}, walk2-default {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 1291, :column 8, :end-line 1291, :end-column 21, :private true, :arglists (quote ([coll f]))}, :private true, :name quantum.core.collections/walk2-default, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 21, :method-params ([coll f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1291, :end-line 1291, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll f]))}, dissoc-in+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 1058, :column 7, :end-line 1058, :end-column 17, :arglists (quote ([m ks])), :doc "Dissociate a value in a nested assocative structure, identified by a sequence\n  of keys. Any collections left empty by the operation will be dissociated from\n  their containing structures.\n  This implementation was adapted from clojure.core.contrib", :attribution "weavejester.medley", :todo ["Transientize"]}, :name quantum.core.collections/dissoc-in+, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 17, :method-params ([m ks]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1058, :attribution "weavejester.medley", :todo ["Transientize"], :end-line 1058, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m ks])), :doc "Dissociate a value in a nested assocative structure, identified by a sequence\n  of keys. Any collections left empty by the operation will be dissociated from\n  their containing structures.\n  This implementation was adapted from clojure.core.contrib"}, walk {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 1304, :column 7, :end-line 1304, :end-column 11, :arglists (quote ([inner outer form])), :doc "Traverses form, an arbitrary data structure.  inner and outer are\n  functions.  Applies inner to each element of form, building up a\n  data structure of the same type, then applies outer to the result.\n  Recognizes all Clojure data structures. Consumes seqs as with doall.", :attribution "Stuart Sierra, stuartsierra/clojure.walk2"}, :name quantum.core.collections/walk, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 11, :method-params ([inner outer form]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1304, :attribution "Stuart Sierra, stuartsierra/clojure.walk2", :end-line 1304, :max-fixed-arity 3, :fn-var true, :arglists (quote ([inner outer form])), :doc "Traverses form, an arbitrary data structure.  inner and outer are\n  functions.  Applies inner to each element of form, building up a\n  data structure of the same type, then applies outer to the result.\n  Recognizes all Clojure data structures. Consumes seqs as with doall."}, lrange {:name quantum.core.collections/lrange, :file "src/cljc/quantum/core/collections.cljc", :line 199, :column 1, :end-line 199, :end-column 17, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 199, :column 11, :end-line 199, :end-column 17}}, seq-if {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 475, :column 7, :end-line 475, :end-column 13, :arglists (quote ([obj]))}, :name quantum.core.collections/seq-if, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 13, :method-params ([obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 475, :end-line 475, :max-fixed-arity 1, :fn-var true, :arglists (quote ([obj]))}, vec {:name quantum.core.collections/vec, :file "src/cljc/quantum/core/collections.cljc", :line 81, :column 1, :end-line 81, :end-column 14, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 81, :column 11, :end-line 81, :end-column 14}}, remove+ {:name quantum.core.collections/remove+, :file "src/cljc/quantum/core/collections.cljc", :line 93, :column 1, :end-line 93, :end-column 18, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 93, :column 11, :end-line 93, :end-column 18}}, update-val+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 957, :column 7, :end-line 957, :end-column 18, :arglists (quote ([f])), :attribution "Alex Gunnarson", :usage (quote (->> {:a 4, :b 12} (map+ (update-val+ (f*n / 2)))))}, :name quantum.core.collections/update-val+, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 18, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :usage (quote (->> {:a 4, :b 12} (map+ (update-val+ (f*n / 2))))), :line 957, :attribution "Alex Gunnarson", :end-line 957, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f]))}, second {:name quantum.core.collections/second, :file "src/cljc/quantum/core/collections.cljc", :line 154, :column 1, :end-line 154, :end-column 17, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 154, :column 11, :end-line 154, :end-column 17}}, takeri+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :end-column 14, :column 7, :line 368, :out "'defg'", :todo "Combine code with /taker-untili+/", :end-line 368, :arglists (quote ([super sub])), :doc "Take up to and including right index of.", :in "(untilri+ 'abcdefg' 'c')"}, :name quantum.core.collections/takeri+, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 14, :method-params ([super sub]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 368, :out "'defg'", :todo "Combine code with /taker-untili+/", :end-line 368, :max-fixed-arity 2, :fn-var true, :arglists (quote ([super sub])), :doc "Take up to and including right index of.", :in "(untilri+ 'abcdefg' 'c')"}, fval+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 554, :column 7, :end-line 554, :end-column 12, :arglists (quote ([m]))}, :name quantum.core.collections/fval+, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 12, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 554, :end-line 554, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m]))}, ffilter+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 266, :column 7, :end-line 266, :end-column 15, :arglists (quote ([pred coll])), :todo ["Use a delayed reduction as the base!"]}, :name quantum.core.collections/ffilter+, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 15, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 266, :todo ["Use a delayed reduction as the base!"], :end-line 266, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred coll]))}, tree-filter {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 1375, :column 7, :end-line 1375, :end-column 18, :arglists (quote ([pred tree])), :doc "Like |filter|, but performs a |postwalk| on a treelike structure @tree, putting in a new vector\n   only the elements for which @pred is true.", :attribution "Alex Gunnarson"}, :name quantum.core.collections/tree-filter, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 18, :method-params ([pred tree]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1375, :attribution "Alex Gunnarson", :end-line 1375, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred tree])), :doc "Like |filter|, but performs a |postwalk| on a treelike structure @tree, putting in a new vector\n   only the elements for which @pred is true."}, prewalk-replace {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 1359, :column 7, :end-line 1359, :end-column 22, :arglists (quote ([smap form])), :doc "Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the root of the tree first.", :attribution "Stuart Sierra, stuartsierra/clojure.walk2"}, :name quantum.core.collections/prewalk-replace, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 22, :method-params ([smap form]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1359, :attribution "Stuart Sierra, stuartsierra/clojure.walk2", :end-line 1359, :max-fixed-arity 2, :fn-var true, :arglists (quote ([smap form])), :doc "Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the root of the tree first."}, Contains? {:meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 685, :column 14, :end-line 685, :end-column 23, :doc nil, :protocol-symbol true, :protocol-info {:methods {contains? [[coll elem]]}}}, :protocol-symbol true, :name quantum.core.collections/Contains?, :file "src/cljc/quantum/core/collections.cljc", :end-column 23, :column 1, :line 685, :protocol-info {:methods {contains? [[coll elem]]}}, :info nil, :end-line 685, :impls #{quantum.core.ns/Regex default string}, :doc nil}, pop {:name quantum.core.collections/pop, :file "src/cljc/quantum/core/collections.cljc", :line 149, :column 1, :end-line 149, :end-column 14, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 149, :column 11, :end-line 149, :end-column 14}}, group-by+ {:name quantum.core.collections/group-by+, :file "src/cljc/quantum/core/collections.cljc", :line 98, :column 1, :end-line 98, :end-column 20, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 98, :column 11, :end-line 98, :end-column 20}}, stringify-keys {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 1344, :column 7, :end-line 1344, :end-column 21, :arglists (quote ([m])), :doc "Recursively transforms all map keys from keywords to strings.", :attribution "Stuart Sierra, stuartsierra/clojure.walk2", :contributors #{"Alex Gunnarson"}}, :name quantum.core.collections/stringify-keys, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 21, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1344, :contributors #{"Alex Gunnarson"}, :attribution "Stuart Sierra, stuartsierra/clojure.walk2", :end-line 1344, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Recursively transforms all map keys from keywords to strings."}, record->map {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 971, :column 7, :end-line 971, :end-column 18, :arglists (quote ([rec]))}, :name quantum.core.collections/record->map, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 18, :method-params ([rec]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 971, :end-line 971, :max-fixed-arity 1, :fn-var true, :arglists (quote ([rec]))}, update-key+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 946, :column 7, :end-line 946, :end-column 18, :arglists (quote ([f])), :attribution "Alex Gunnarson", :usage (quote (->> {:a 4, :b 12} (map+ (update-key+ str))))}, :name quantum.core.collections/update-key+, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 18, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :usage (quote (->> {:a 4, :b 12} (map+ (update-key+ str)))), :line 946, :attribution "Alex Gunnarson", :end-line 946, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f]))}, prewalk {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 1321, :column 7, :end-line 1321, :end-column 14, :arglists (quote ([f form])), :doc "Like postwalk, but does pre-order traversal.", :attribution "Stuart Sierra, stuartsierra/clojure.walk2"}, :name quantum.core.collections/prewalk, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 14, :method-params ([f form]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1321, :attribution "Stuart Sierra, stuartsierra/clojure.walk2", :end-line 1321, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f form])), :doc "Like postwalk, but does pre-order traversal."}, updates-in+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 1075, :column 7, :end-line 1075, :end-column 18, :arglists (quote ([coll & kfs])), :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(coll kfs)], :arglists ([coll & kfs]), :arglists-meta (nil)}}, :name quantum.core.collections/updates-in+, :variadic true, :file "src/cljc/quantum/core/collections.cljc", :end-column 18, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(coll kfs)], :arglists ([coll & kfs]), :arglists-meta (nil)}, :method-params [(coll kfs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 1075, :end-line 1075, :max-fixed-arity 1, :fn-var true, :arglists ([coll & kfs])}, dissoc-if+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 1054, :column 7, :end-line 1054, :end-column 17, :arglists (quote ([coll pred k]))}, :name quantum.core.collections/dissoc-if+, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 17, :method-params ([coll pred k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1054, :end-line 1054, :max-fixed-arity 3, :fn-var true, :arglists (quote ([coll pred k]))}, in? {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 703, :column 7, :end-line 703, :end-column 10, :arglists (quote ([elem coll])), :doc "The inverse of |contains?|", :todo ["|definline| this?"]}, :name quantum.core.collections/in?, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 10, :method-params ([elem coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 703, :todo ["|definline| this?"], :end-line 703, :max-fixed-arity 2, :fn-var true, :arglists (quote ([elem coll])), :doc "The inverse of |contains?|"}, merge-right {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 1224, :column 7, :end-line 1224, :end-column 18, :arglists (quote ([alert-level] [k v1 v2])), :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([alert-level] [k v1 v2]), :arglists ([alert-level] [k v1 v2]), :arglists-meta (nil nil)}}, :name quantum.core.collections/merge-right, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 18, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([alert-level] [k v1 v2]), :arglists ([alert-level] [k v1 v2]), :arglists-meta (nil nil)}, :method-params ([alert-level] [k v1 v2]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1224, :end-line 1224, :max-fixed-arity 3, :fn-var true, :arglists ([alert-level] [k v1 v2])}, dropr+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 414, :column 7, :end-line 414, :end-column 13, :arglists (quote ([obj n])), :attribution "Alex Gunnarson"}, :name quantum.core.collections/dropr+, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 13, :method-params ([obj n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 414, :attribution "Alex Gunnarson", :end-line 414, :max-fixed-arity 2, :fn-var true, :arglists (quote ([obj n]))}, take-afteri+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 353, :column 7, :end-line 353, :end-column 19, :arglists (quote ([obj sub-obj])), :todo ["Use reducers"], :in ["asdbsd" "db"], :out "dbsd"}, :name quantum.core.collections/take-afteri+, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 19, :method-params ([obj sub-obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 353, :out "dbsd", :todo ["Use reducers"], :end-line 353, :max-fixed-arity 2, :fn-var true, :arglists (quote ([obj sub-obj])), :in ["asdbsd" "db"]}, frest {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 164, :column 6, :end-line 164, :end-column 11}, :name quantum.core.collections/frest, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 11, :method-params ([x__22733__auto__]), :protocol-impl nil, :arglists-meta (), :column 1, :line 164, :end-line 164, :max-fixed-arity 1, :fn-var true, :arglists nil}, take-from+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 340, :column 7, :end-line 340, :end-column 17, :arglists (quote ([obj n])), :doc "Take starting at and including index n.", :todo ["Use reducers"]}, :name quantum.core.collections/take-from+, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 17, :method-params ([obj n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 340, :todo ["Use reducers"], :end-line 340, :max-fixed-arity 2, :fn-var true, :arglists (quote ([obj n])), :doc "Take starting at and including index n."}, lsort {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 1404, :column 7, :end-line 1404, :end-column 12, :arglists (quote ([elems])), :doc "Lazy 'quick'-sorting", :attribution "The Joy of Clojure, 2nd ed."}, :name quantum.core.collections/lsort, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 12, :method-params ([elems]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1404, :attribution "The Joy of Clojure, 2nd ed.", :end-line 1404, :max-fixed-arity 1, :fn-var true, :arglists (quote ([elems])), :doc "Lazy 'quick'-sorting"}, indices-of+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 313, :column 7, :end-line 313, :end-column 18, :arglists (quote ([coll elem-0])), :todo ["Make parallizeable"]}, :name quantum.core.collections/indices-of+, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 18, :method-params ([coll elem-0]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 313, :todo ["Make parallizeable"], :end-line 313, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll elem-0]))}, select-keys+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 765, :column 12, :end-line 765, :end-column 24, :tag Map, :arglists (quote ([m ks])), :todo ["Determine actual inflection point at which select-keys-large\n      should be used over select-keys-small."]}, :name quantum.core.collections/select-keys+, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 24, :method-params ([m ks]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 765, :todo ["Determine actual inflection point at which select-keys-large\n      should be used over select-keys-small."], :ret-tag Map, :end-line 765, :max-fixed-arity 2, :tag Map, :fn-var true, :arglists (quote ([m ks]))}, fold {:name quantum.core.collections/fold, :file "src/cljc/quantum/core/collections.cljc", :line 87, :column 1, :end-line 87, :end-column 15, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 87, :column 11, :end-line 87, :end-column 15}}, coll-if {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 472, :column 7, :end-line 472, :end-column 14, :arglists (quote ([obj]))}, :name quantum.core.collections/coll-if, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 14, :method-params ([obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 472, :end-line 472, :max-fixed-arity 1, :fn-var true, :arglists (quote ([obj]))}, subs? {:name quantum.core.collections/subs?, :file "src/cljc/quantum/core/collections.cljc", :line 709, :column 1, :end-line 709, :end-column 11, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 709, :column 6, :end-line 709, :end-column 11}}, first-uniques-by+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 1235, :column 14, :end-line 1235, :end-column 31, :tag Delay, :arglists (quote ([k coll]))}, :name quantum.core.collections/first-uniques-by+, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 31, :method-params ([k coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1235, :ret-tag Delay, :end-line 1235, :max-fixed-arity 2, :tag Delay, :fn-var true, :arglists (quote ([k coll]))}, walk2 {:protocol-inline nil, :meta {:protocol quantum.core.collections/Walkable, :added "1.6", :file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :end-column 11, :column 6, :line 1247, :attribution "Stuart Sierra, stuartsierra/clojure.walk2", :end-line 1247, :arglists (quote ([coll f])), :doc "If coll is a collection, applies f to each element of the collection\n     and returns a collection of the results, of the same type and order\n     as coll. If coll is not a collection, returns it unchanged. \"Same\n     type\" means a type with the same behavior. For example, a hash-map\n     may be returned as an array-map, but a a sorted-map will be returned\n     as a sorted-map with the same comparator."}, :protocol quantum.core.collections/Walkable, :added "1.6", :name quantum.core.collections/walk2, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 11, :method-params ([coll f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1244, :attribution "Stuart Sierra, stuartsierra/clojure.walk2", :end-line 1247, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll f])), :doc "If coll is a collection, applies f to each element of the collection\n     and returns a collection of the results, of the same type and order\n     as coll. If coll is not a collection, returns it unchanged. \"Same\n     type\" means a type with the same behavior. For example, a hash-map\n     may be returned as an array-map, but a a sorted-map will be returned\n     as a sorted-map with the same comparator."}, flatten+ {:name quantum.core.collections/flatten+, :file "src/cljc/quantum/core/collections.cljc", :line 99, :column 1, :end-line 99, :end-column 19, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 99, :column 11, :end-line 99, :end-column 19}}, concat++ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 673, :column 8, :end-line 673, :end-column 16, :private true, :arglists (quote ([coll] [coll & colls])), :todo ["Needs optimization"], :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([coll]), :arglists ([coll] [coll & colls]), :arglists-meta (nil nil)}}, :private true, :name quantum.core.collections/concat++, :variadic true, :file "src/cljc/quantum/core/collections.cljc", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([coll]), :arglists ([coll] [coll & colls]), :arglists-meta (nil nil)}, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 673, :todo ["Needs optimization"], :end-line 673, :max-fixed-arity 1, :fn-var true, :arglists ([coll] [coll & colls])}, filter+ {:name quantum.core.collections/filter+, :file "src/cljc/quantum/core/collections.cljc", :line 91, :column 1, :end-line 91, :end-column 18, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 91, :column 11, :end-line 91, :end-column 18}}, merge-keep-left {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 421, :column 7, :end-line 421, :end-column 22, :arglists (quote ([a b]))}, :name quantum.core.collections/merge-keep-left, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 22, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 421, :end-line 421, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b]))}, remove-keys+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 805, :column 7, :end-line 805, :end-column 19, :arglists (quote ([pred coll]))}, :name quantum.core.collections/remove-keys+, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 19, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 805, :end-line 805, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred coll]))}, select-keys-large {:protocol-inline nil, :meta {:private true, :performance "45.3 ms vs. core's 60.29 ms on:\n     (dotimes [_ 100000]\n       (select-keys\n         {:a 1 :b 2 :c 3 :d 4 :e 5 :f 6 :g 7}\n         [:b :c :e]))).\n     Performs much better on large set of keys.", :file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :end-column 30, :column 13, :line 712, :end-line 712, :tag Map, :arglists (quote ([keyseq m])), :doc "A transient and reducing version of clojure.core's |select-keys|."}, :private true, :performance "45.3 ms vs. core's 60.29 ms on:\n     (dotimes [_ 100000]\n       (select-keys\n         {:a 1 :b 2 :c 3 :d 4 :e 5 :f 6 :g 7}\n         [:b :c :e]))).\n     Performs much better on large set of keys.", :name quantum.core.collections/select-keys-large, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 30, :method-params ([keyseq m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 712, :ret-tag Map, :end-line 712, :max-fixed-arity 2, :tag Map, :fn-var true, :arglists (quote ([keyseq m])), :doc "A transient and reducing version of clojure.core's |select-keys|."}, key+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 531, :column 7, :end-line 531, :end-column 11, :arglists (quote ([obj] [k v])), :doc "Like |key| but more robust.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([obj] [k v]), :arglists ([obj] [k v]), :arglists-meta (nil nil)}}, :name quantum.core.collections/key+, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([obj] [k v]), :arglists ([obj] [k v]), :arglists-meta (nil nil)}, :method-params ([obj] [k v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 531, :end-line 531, :max-fixed-arity 2, :fn-var true, :arglists ([obj] [k v]), :doc "Like |key| but more robust."}, take-while+ {:name quantum.core.collections/take-while+, :file "src/cljc/quantum/core/collections.cljc", :line 96, :column 1, :end-line 96, :end-column 22, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 96, :column 11, :end-line 96, :end-column 22}}, re-assoc+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 1082, :column 7, :end-line 1082, :end-column 16, :arglists (quote ([coll k-0 k-f]))}, :name quantum.core.collections/re-assoc+, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 16, :method-params ([coll k-0 k-f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1082, :end-line 1082, :max-fixed-arity 3, :fn-var true, :arglists (quote ([coll k-0 k-f]))}, assocs-in+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 1018, :column 7, :end-line 1018, :end-column 17, :arglists (quote ([coll & kvs])), :usage "(assocs-in ['file0' 'file1' 'file2']\n             [0] 'file10'\n             [1] 'file11'\n             [2] 'file12')", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(coll kvs)], :arglists ([coll & kvs]), :arglists-meta (nil)}}, :name quantum.core.collections/assocs-in+, :variadic true, :file "src/cljc/quantum/core/collections.cljc", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(coll kvs)], :arglists ([coll & kvs]), :arglists-meta (nil)}, :method-params [(coll kvs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :usage "(assocs-in ['file0' 'file1' 'file2']\n             [0] 'file10'\n             [1] 'file11'\n             [2] 'file12')", :line 1018, :end-line 1018, :max-fixed-arity 1, :fn-var true, :arglists ([coll & kvs])}, redm {:name quantum.core.collections/redm, :file "src/cljc/quantum/core/collections.cljc", :line 86, :column 1, :end-line 86, :end-column 15, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 86, :column 11, :end-line 86, :end-column 15}}, kv+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 125, :column 9, :end-line 125, :end-column 12, :arglists (quote ([obj] [k v])), :doc "For some reason ClojureScript reducers have an issue and it's terrible... so use it like so:\n     (map+ (compr kv+ <myfunc>) _)\n     |reduce| doesn't have this problem.", :todo ["Eliminate the need for this."], :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([obj] [k v]), :arglists ([obj] [k v]), :arglists-meta (nil nil)}}, :name quantum.core.collections/kv+, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 12, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([obj] [k v]), :arglists ([obj] [k v]), :arglists-meta (nil nil)}, :method-params ([obj] [k v]), :protocol-impl nil, :arglists-meta (nil nil), :column 3, :line 125, :todo ["Eliminate the need for this."], :end-line 125, :max-fixed-arity 2, :fn-var true, :arglists ([obj] [k v]), :doc "For some reason ClojureScript reducers have an issue and it's terrible... so use it like so:\n     (map+ (compr kv+ <myfunc>) _)\n     |reduce| doesn't have this problem."}, merge {:name quantum.core.collections/merge, :file "src/cljc/quantum/core/collections.cljc", :line 162, :column 1, :end-line 162, :end-column 16, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 162, :column 11, :end-line 162, :end-column 16}}, foldv {:name quantum.core.collections/foldv, :file "src/cljc/quantum/core/collections.cljc", :line 88, :column 1, :end-line 88, :end-column 16, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 88, :column 11, :end-line 88, :end-column 16}}, lfilter {:name quantum.core.collections/lfilter, :file "src/cljc/quantum/core/collections.cljc", :line 92, :column 1, :end-line 92, :end-column 18, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 92, :column 11, :end-line 92, :end-column 18}}, mapmux {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 968, :column 7, :end-line 968, :end-column 13, :arglists (quote ([kv] [k v])), :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([kv] [k v]), :arglists ([kv] [k v]), :arglists-meta (nil nil)}}, :name quantum.core.collections/mapmux, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([kv] [k v]), :arglists ([kv] [k v]), :arglists-meta (nil nil)}, :method-params ([kv] [k v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 968, :end-line 968, :max-fixed-arity 2, :fn-var true, :arglists ([kv] [k v])}, update-in+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 990, :column 7, :end-line 990, :end-column 17, :arglists (quote ([coll-0 [k0 & keys-0] v0])), :doc "Created so vectors would also automatically be grown like maps,\n   given indices not present in the vector.", :attribution "Alex Gunnarson", :todo ["optimize via transients" "allow to use :last on vectors" "allow |identity| function for unity's sake"]}, :name quantum.core.collections/update-in+, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 17, :method-params ([coll-0 p__30707 v0]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 990, :attribution "Alex Gunnarson", :todo ["optimize via transients" "allow to use :last on vectors" "allow |identity| function for unity's sake"], :end-line 990, :max-fixed-arity 3, :fn-var true, :arglists (quote ([coll-0 [k0 & keys-0] v0])), :doc "Created so vectors would also automatically be grown like maps,\n   given indices not present in the vector."}, sort-parts {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 1387, :column 8, :end-line 1387, :end-column 18, :private true, :arglists (quote ([work])), :doc "Lazy, tail-recursive, incremental quicksort. Works against\n   and creates partitions based on the pivot, defined as 'work'.", :attribution "The Joy of Clojure, 2nd ed."}, :private true, :name quantum.core.collections/sort-parts, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 18, :method-params ([work]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1387, :attribution "The Joy of Clojure, 2nd ed.", :end-line 1387, :max-fixed-arity 1, :fn-var true, :arglists (quote ([work])), :doc "Lazy, tail-recursive, incremental quicksort. Works against\n   and creates partitions based on the pivot, defined as 'work'."}, val+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 543, :column 7, :end-line 543, :end-column 11, :arglists (quote ([obj] [k v])), :doc "Like |val| but more robust.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([obj] [k v]), :arglists ([obj] [k v]), :arglists-meta (nil nil)}}, :name quantum.core.collections/val+, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([obj] [k v]), :arglists ([obj] [k v]), :arglists-meta (nil nil)}, :method-params ([obj] [k v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 543, :end-line 543, :max-fixed-arity 2, :fn-var true, :arglists ([obj] [k v]), :doc "Like |val| but more robust."}, rename-keys {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 567, :column 9, :end-line 567, :end-column 20, :arglists (quote ([m-0 rename-m]))}, :name quantum.core.collections/rename-keys, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 20, :method-params ([m-0 rename-m]), :protocol-impl nil, :arglists-meta (nil nil), :column 3, :line 567, :end-line 567, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m-0 rename-m]))}, split {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 873, :column 7, :end-line 873, :end-column 12, :arglists (quote ([ind coll-0]))}, :name quantum.core.collections/split, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 12, :method-params ([ind coll-0]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 873, :end-line 873, :max-fixed-arity 2, :fn-var true, :arglists (quote ([ind coll-0]))}, merge-with+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :end-column 18, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f maps)], :arglists ([f & maps]), :arglists-meta (nil)}, :column 7, :line 622, :contributors ["Alex Gunnarson"], :attribution "prismatic.plumbing", :todo ["Make it not output HashMaps but preserve records"], :end-line 622, :arglists (quote ([f & maps])), :doc "Like merge-with, but the merging function takes the key being merged\n   as the first argument"}, :name quantum.core.collections/merge-with+, :variadic true, :file "src/cljc/quantum/core/collections.cljc", :end-column 18, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f maps)], :arglists ([f & maps]), :arglists-meta (nil)}, :method-params [(f maps)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 622, :contributors ["Alex Gunnarson"], :attribution "prismatic.plumbing", :todo ["Make it not output HashMaps but preserve records"], :end-line 622, :max-fixed-arity 1, :fn-var true, :arglists ([f & maps]), :doc "Like merge-with, but the merging function takes the key being merged\n   as the first argument"}, keywordify-keys {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 1328, :column 7, :end-line 1328, :end-column 22, :arglists (quote ([m])), :doc "Recursively transforms all map keys from keywords to strings.", :attribution "Stuart Sierra, stuartsierra/clojure.walk2", :contributors #{"Alex Gunnarson"}}, :name quantum.core.collections/keywordify-keys, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 22, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1328, :contributors #{"Alex Gunnarson"}, :attribution "Stuart Sierra, stuartsierra/clojure.walk2", :end-line 1328, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Recursively transforms all map keys from keywords to strings."}, merge-vals-left {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :end-column 27, :column 12, :line 642, :out (quote {:a {:aa 6}, :b {:aa 3}}), :todo "Make a reducer, not just implement using |reduce| function.", :end-line 642, :tag Map, :arglists (quote ([left right f])), :doc "Merges into the left map all elements of the right map whose\n   keys are found in the left map.\n\n   Combines using @f, a |merge-with| function.", :in [(quote {:a {:aa 1}, :b {:aa 3}}) {:a {:aa 5}, :c {:bb 4}} (fn [k v1 v2] (+ v1 v2))]}, :name quantum.core.collections/merge-vals-left, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 27, :method-params ([left right f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 642, :out (quote {:a {:aa 6}, :b {:aa 3}}), :todo "Make a reducer, not just implement using |reduce| function.", :ret-tag Map, :end-line 642, :max-fixed-arity 3, :tag Map, :fn-var true, :arglists (quote ([left right f])), :doc "Merges into the left map all elements of the right map whose\n   keys are found in the left map.\n\n   Combines using @f, a |merge-with| function.", :in [(quote {:a {:aa 1}, :b {:aa 3}}) {:a {:aa 5}, :c {:bb 4}} (fn [k v1 v2] (+ v1 v2))]}, vals+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 809, :column 7, :end-line 809, :end-column 12, :arglists (quote ([m])), :attribution "Alex Gunnarson", :todo ["Compare performance with core functions"]}, :name quantum.core.collections/vals+, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 12, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 809, :attribution "Alex Gunnarson", :todo ["Compare performance with core functions"], :end-line 809, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m]))}, takel+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 337, :column 7, :end-line 337, :end-column 13, :arglists (quote ([coll n]))}, :name quantum.core.collections/takel+, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 13, :method-params ([coll n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 337, :end-line 337, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll n]))}, getr {:name quantum.core.collections/getr, :file "src/cljc/quantum/core/collections.cljc", :line 145, :column 1, :end-line 145, :end-column 15, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 145, :column 11, :end-line 145, :end-column 15}}, fkey+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 552, :column 7, :end-line 552, :end-column 12, :arglists (quote ([m]))}, :name quantum.core.collections/fkey+, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 12, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 552, :end-line 552, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m]))}, get-keys {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 779, :column 7, :end-line 779, :end-column 15, :arglists (quote ([m obj])), :attribution "Alex Gunnarson"}, :name quantum.core.collections/get-keys, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 15, :method-params ([m obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 779, :attribution "Alex Gunnarson", :end-line 779, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m obj]))}, reduce-2 {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 243, :column 7, :end-line 243, :end-column 15, :arglists (quote ([func init coll])), :doc "Like |reduce|, but reduces over two items in a collection at a time.\n\n   Its function @func must take three arguments:\n   1) The accumulated return value of the reduction function\n   2) The                next item in the collection being reduced over\n   3) The item after the next item in the collection being reduced over", :attribution "Alex Gunnarson"}, :name quantum.core.collections/reduce-2, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 15, :method-params ([func init coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 243, :attribution "Alex Gunnarson", :end-line 243, :max-fixed-arity 3, :fn-var true, :arglists (quote ([func init coll])), :doc "Like |reduce|, but reduces over two items in a collection at a time.\n\n   Its function @func must take three arguments:\n   1) The accumulated return value of the reduction function\n   2) The                next item in the collection being reduced over\n   3) The item after the next item in the collection being reduced over"}, interpose+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 1148, :column 7, :end-line 1148, :end-column 17, :arglists (quote ([elem coll])), :todo ["|definline| this"]}, :name quantum.core.collections/interpose+, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 17, :method-params ([elem coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1148, :todo ["|definline| this"], :end-line 1148, :max-fixed-arity 2, :fn-var true, :arglists (quote ([elem coll]))}, popl {:name quantum.core.collections/popl, :file "src/cljc/quantum/core/collections.cljc", :line 151, :column 1, :end-line 151, :end-column 15, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 151, :column 11, :end-line 151, :end-column 15}}, linterleave-all {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 1152, :column 7, :end-line 1152, :end-column 22, :arglists (quote ([& colls])), :doc "Analogy: partition:partition-all :: interleave:interleave-all", :attribution "prismatic/plumbing", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(colls)], :arglists ([& colls]), :arglists-meta (nil)}}, :name quantum.core.collections/linterleave-all, :variadic true, :file "src/cljc/quantum/core/collections.cljc", :end-column 22, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(colls)], :arglists ([& colls]), :arglists-meta (nil)}, :method-params [(colls)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 1152, :attribution "prismatic/plumbing", :end-line 1152, :max-fixed-arity 0, :fn-var true, :arglists ([& colls]), :doc "Analogy: partition:partition-all :: interleave:interleave-all"}, take-fromi+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 346, :column 7, :end-line 346, :end-column 18, :arglists (quote ([obj sub-obj])), :todo ["Use reducers"], :in ["asdbsd" "db"], :out "dbsd"}, :name quantum.core.collections/take-fromi+, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 18, :method-params ([obj sub-obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 346, :out "dbsd", :todo ["Use reducers"], :end-line 346, :max-fixed-arity 2, :fn-var true, :arglists (quote ([obj sub-obj])), :in ["asdbsd" "db"]}, taker-untili+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :end-column 20, :column 7, :line 385, :out "'defg'", :todo "Combine code with /takeri/", :end-line 385, :arglists (quote ([super sub])), :doc "Until right index of.", :in ["abcdefg" "c"]}, :name quantum.core.collections/taker-untili+, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 20, :method-params ([super sub]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 385, :out "'defg'", :todo "Combine code with /takeri/", :end-line 385, :max-fixed-arity 2, :fn-var true, :arglists (quote ([super sub])), :doc "Until right index of.", :in ["abcdefg" "c"]}, take+ {:name quantum.core.collections/take+, :file "src/cljc/quantum/core/collections.cljc", :line 95, :column 1, :end-line 95, :end-column 16, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 95, :column 11, :end-line 95, :end-column 16}}, slice {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 824, :column 7, :end-line 824, :end-column 12, :arglists (quote ([n-0 coll])), :doc "Divide coll into n approximately equal slices.\n   Like partition.", :attribution "flatland.useful.seq", :todo ["Optimize" "Use transients"]}, :name quantum.core.collections/slice, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 12, :method-params ([n-0 coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 824, :attribution "flatland.useful.seq", :todo ["Optimize" "Use transients"], :end-line 824, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n-0 coll])), :doc "Divide coll into n approximately equal slices.\n   Like partition."}, Interpose {:meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 1136, :column 14, :end-line 1136, :end-column 23, :doc nil, :protocol-symbol true, :protocol-info {:methods {interpose+- [[coll elem]]}}}, :protocol-symbol true, :name quantum.core.collections/Interpose, :file "src/cljc/quantum/core/collections.cljc", :end-column 23, :column 1, :line 1136, :protocol-info {:methods {interpose+- [[coll elem]]}}, :info nil, :end-line 1136, :impls #{default string}, :doc nil}, count {:name quantum.core.collections/count, :file "src/cljc/quantum/core/collections.cljc", :line 144, :column 1, :end-line 144, :end-column 16, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 144, :column 11, :end-line 144, :end-column 16}}, map+ {:name quantum.core.collections/map+, :file "src/cljc/quantum/core/collections.cljc", :line 90, :column 1, :end-line 90, :end-column 15, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 90, :column 11, :end-line 90, :end-column 15}}, select-keys-small {:protocol-inline nil, :meta {:private true, :performance "39.09 ms vs. core's 60.29 ms on:\n     (dotimes [_ 100000]\n       (select-keys\n         {:a 1 :b 2 :c 3 :d 4 :e 5 :f 6 :g 7}\n         [:b :c :e])))", :file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :end-column 30, :column 13, :line 733, :end-line 733, :tag Map, :arglists (quote ([keyseq m])), :doc "A transient version of clojure.core's |select-keys|.\n\n   Note: using a reducer here incurs the overhead of creating a\n   function on the fly (can't extern it because of a closure).\n   This is better for small set of keys."}, :private true, :performance "39.09 ms vs. core's 60.29 ms on:\n     (dotimes [_ 100000]\n       (select-keys\n         {:a 1 :b 2 :c 3 :d 4 :e 5 :f 6 :g 7}\n         [:b :c :e])))", :name quantum.core.collections/select-keys-small, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 30, :method-params ([keyseq m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 733, :ret-tag Map, :end-line 733, :max-fixed-arity 2, :tag Map, :fn-var true, :arglists (quote ([keyseq m])), :doc "A transient version of clojure.core's |select-keys|.\n\n   Note: using a reducer here incurs the overhead of creating a\n   function on the fly (can't extern it because of a closure).\n   This is better for small set of keys."}, split-remove+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 423, :column 7, :end-line 423, :end-column 20, :arglists (quote ([coll split-at-obj])), :todo ["Slightly inefficient — two /index-of/ implicit."]}, :name quantum.core.collections/split-remove+, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 20, :method-params ([coll split-at-obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 423, :todo ["Slightly inefficient — two /index-of/ implicit."], :end-line 423, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll split-at-obj]))}, merge-left {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 1213, :column 7, :end-line 1213, :end-column 17, :arglists (quote ([alert-level] [k v1 v2])), :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([alert-level] [k v1 v2]), :arglists ([alert-level] [k v1 v2]), :arglists-meta (nil nil)}}, :name quantum.core.collections/merge-left, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([alert-level] [k v1 v2]), :arglists ([alert-level] [k v1 v2]), :arglists-meta (nil nil)}, :method-params ([alert-level] [k v1 v2]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1213, :end-line 1213, :max-fixed-arity 3, :fn-var true, :arglists ([alert-level] [k v1 v2])}, redv {:name quantum.core.collections/redv, :file "src/cljc/quantum/core/collections.cljc", :line 85, :column 1, :end-line 85, :end-column 15, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 85, :column 11, :end-line 85, :end-column 15}}, postwalk-replace {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 1367, :column 7, :end-line 1367, :end-column 23, :arglists (quote ([smap form])), :doc "Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the leaves of the tree first.", :attribution "Stuart Sierra, stuartsierra/clojure.walk2"}, :name quantum.core.collections/postwalk-replace, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 23, :method-params ([smap form]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1367, :attribution "Stuart Sierra, stuartsierra/clojure.walk2", :end-line 1367, :max-fixed-arity 2, :fn-var true, :arglists (quote ([smap form])), :doc "Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the leaves of the tree first."}, index-of {:name quantum.core.collections/index-of, :file "src/cljc/quantum/core/collections.cljc", :line 142, :column 1, :end-line 142, :end-column 19, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 142, :column 11, :end-line 142, :end-column 19}}, repeat {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 208, :column 7, :end-line 208, :end-column 13, :arglists (quote ([obj] [n obj])), :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([obj] [n obj]), :arglists ([obj] [n obj]), :arglists-meta (nil nil)}}, :name quantum.core.collections/repeat, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([obj] [n obj]), :arglists ([obj] [n obj]), :arglists-meta (nil nil)}, :method-params ([obj] [n obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 208, :end-line 208, :max-fixed-arity 2, :fn-var true, :arglists ([obj] [n obj])}, foldm {:name quantum.core.collections/foldm, :file "src/cljc/quantum/core/collections.cljc", :line 89, :column 1, :end-line 89, :end-column 16, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 89, :column 11, :end-line 89, :end-column 16}}, lremove {:name quantum.core.collections/lremove, :file "src/cljc/quantum/core/collections.cljc", :line 94, :column 1, :end-line 94, :end-column 18, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 94, :column 11, :end-line 94, :end-column 18}}, range+ {:name quantum.core.collections/range+, :file "src/cljc/quantum/core/collections.cljc", :line 197, :column 1, :end-line 197, :end-column 36, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 197, :column 30, :end-line 197, :end-column 36}}, reverse+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 587, :column 7, :end-line 587, :end-column 15, :arglists (quote ([coll]))}, :name quantum.core.collections/reverse+, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 587, :end-line 587, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, unchunk {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 491, :column 7, :end-line 491, :end-column 14, :arglists (quote ([s])), :doc "Takes a seqable and returns a lazy sequence that\n   is maximally lazy and doesn't realize elements due to either\n   chunking or apply.\n\n   Useful when you don't want chunking, for instance,\n   (first awesome-website? (map slurp <a-bunch-of-urls>))\n   may slurp up to 31 unneed webpages, whereas\n   (first awesome-website? (map slurp (unchunk <a-bunch-of-urls>)))\n   is guaranteed to stop slurping after the first awesome website.\n\n  Taken from http://stackoverflow.com/questions/3407876/how-do-i-avoid-clojures-chunking-behavior-for-lazy-seqs-that-i-want-to-short-ci", :attribution "prismatic.plumbing"}, :name quantum.core.collections/unchunk, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 14, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 491, :attribution "prismatic.plumbing", :end-line 491, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Takes a seqable and returns a lazy sequence that\n   is maximally lazy and doesn't realize elements due to either\n   chunking or apply.\n\n   Useful when you don't want chunking, for instance,\n   (first awesome-website? (map slurp <a-bunch-of-urls>))\n   may slurp up to 31 unneed webpages, whereas\n   (first awesome-website? (map slurp (unchunk <a-bunch-of-urls>)))\n   is guaranteed to stop slurping after the first awesome website.\n\n  Taken from http://stackoverflow.com/questions/3407876/how-do-i-avoid-clojures-chunking-behavior-for-lazy-seqs-that-i-want-to-short-ci"}, up-val {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 557, :column 7, :end-line 557, :end-column 13, :arglists (quote ([m k])), :in (quote [{:a "ABC", :b 123} :a]), :out (quote {"ABC" {:b 123}}), :todo ["hash-map creation inefficient ATM"]}, :name quantum.core.collections/up-val, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 13, :method-params ([m k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 557, :out (quote {"ABC" {:b 123}}), :todo ["hash-map creation inefficient ATM"], :end-line 557, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m k])), :in (quote [{:a "ABC", :b 123} :a])}, select-as+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :end-column 22, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([coll kfs]), :arglists ([coll kfs] [coll k1 f1 & {:as kfs}]), :arglists-meta (nil nil)}, :column 12, :line 1095, :attribution "Alex Gunnarson", :todo ["Name this function more appropriately"], :end-line 1095, :tag Map, :arglists (quote ([coll kfs] [coll k1 f1 & {:as kfs}]))}, :name quantum.core.collections/select-as+, :variadic true, :file "src/cljc/quantum/core/collections.cljc", :end-column 22, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([coll kfs]), :arglists ([coll kfs] [coll k1 f1 & {:as kfs}]), :arglists-meta (nil nil)}, :method-params ([coll kfs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1095, :attribution "Alex Gunnarson", :todo ["Name this function more appropriately"], :ret-tag Map, :end-line 1095, :max-fixed-arity 3, :tag Map, :fn-var true, :arglists ([coll kfs] [coll k1 f1 & {:as kfs}])}, ffilter {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 260, :column 7, :end-line 260, :end-column 14, :arglists (quote ([filter-fn coll])), :doc "Returns the first result of a |filter| operation.\n   Uses lazy |filter| so as to do it in the fastest possible way."}, :name quantum.core.collections/ffilter, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 14, :method-params ([filter-fn coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 260, :end-line 260, :max-fixed-arity 2, :fn-var true, :arglists (quote ([filter-fn coll])), :doc "Returns the first result of a |filter| operation.\n   Uses lazy |filter| so as to do it in the fastest possible way."}, comparator-extreme-of {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 442, :column 7, :end-line 442, :end-column 28, :arglists (quote ([coll compare-fn])), :doc "For compare-fns that don't have enough arity to do, say,\n   |(apply time/latest [date1 date2 date3])|.\n\n   Gets the most \"extreme\" element in collection @coll,\n   \"extreme\" being defined on the @compare-fn.\n\n   In the case of |time/latest|, it would return the latest\n   DateTime in a collection.\n\n   In the case of |>| (greater than), it would return the\n   greatest element in the collection:\n\n   (comparator-extreme-of [1 2 3] (fn [a b] (if (> a b) a b)) )\n   :: 3\n\n   |(fn [a b] (if (> a b) a b))| is the same thing as\n   |(choice-comparator >)|.", :todo ["Rename this function." "HOW DOES THIS HAVE ANY RELEVANCE?" "Possibly belongs in a different namespace"]}, :name quantum.core.collections/comparator-extreme-of, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 28, :method-params ([coll compare-fn]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 442, :todo ["Rename this function." "HOW DOES THIS HAVE ANY RELEVANCE?" "Possibly belongs in a different namespace"], :end-line 442, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll compare-fn])), :doc "For compare-fns that don't have enough arity to do, say,\n   |(apply time/latest [date1 date2 date3])|.\n\n   Gets the most \"extreme\" element in collection @coll,\n   \"extreme\" being defined on the @compare-fn.\n\n   In the case of |time/latest|, it would return the latest\n   DateTime in a collection.\n\n   In the case of |>| (greater than), it would return the\n   greatest element in the collection:\n\n   (comparator-extreme-of [1 2 3] (fn [a b] (if (> a b) a b)) )\n   :: 3\n\n   |(fn [a b] (if (> a b) a b))| is the same thing as\n   |(choice-comparator >)|."}, interpose+- {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/collections.cljc", :line 1137, :column 4, :end-line 1137, :end-column 15, :protocol quantum.core.collections/Interpose, :doc nil, :arglists (quote ([coll elem]))}, :protocol quantum.core.collections/Interpose, :name quantum.core.collections/interpose+-, :variadic false, :file "src/cljc/quantum/core/collections.cljc", :end-column 15, :method-params ([coll elem]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1136, :end-line 1137, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll elem])), :doc nil}}, :require-macros {logic quantum.core.logic, quantum.core.type quantum.core.type, fn quantum.core.function, ns quantum.core.ns, quantum.core.logic quantum.core.logic, quantum.core.loops quantum.core.loops, type quantum.core.type, loops quantum.core.loops, quantum.core.ns quantum.core.ns, quantum.core.function quantum.core.function}, :cljs.analyzer/constants {:seen #{:else :performance :added :ns :name :variadic :file :end-column :top-fn :method-params :arglists-meta :column :usage :line :out :macro :contributors :attribution :todo :end-line :max-fixed-arity :contains? :tag :arglists :doc :map :test}, :order [:ns :name :file :end-column :column :line :end-line :arglists :doc :test :macro :top-fn :todo :variadic :max-fixed-arity :method-params :arglists-meta :attribution :added :contributors :performance :tag :usage :out :else :map :contains?]}, :doc "Various collections functions.\n\n       Includes better versions of the following than clojure.core:\n\n       for, doseq, repeat, repeatedly, range, merge,\n       count, vec, reduce, into, first, second, rest,\n       last, butlast, get, pop, peek ...\n\n       and more.\n\n       Many of them are aliased from other namespaces like\n       quantum.core.collections.core, or quantum.core.reducers."}