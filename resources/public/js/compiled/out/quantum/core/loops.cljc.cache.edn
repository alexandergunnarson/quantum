;; Analyzed by ClojureScript 0.0-3269
{:name quantum.core.loops, :doc "Useful looping constructs. Most of these, like |doseq| and |for|,\n          are faster than their lazy clojure.core counterparts.", :excludes #{doseq for}, :use-macros {defalias quantum.core.ns, assert-args quantum.core.macros, should-transientize? quantum.core.type}, :require-macros {quantum.core.macros quantum.core.macros, quantum.core.type quantum.core.type, ns quantum.core.ns, quantum.core.ns quantum.core.ns}, :uses {Editable quantum.core.ns, boolean? quantum.core.type, sorted-map? quantum.core.type, sorted-map+ quantum.core.data.map, Nil quantum.core.ns, Bool quantum.core.ns, IllegalArgumentException quantum.core.ns, Vec quantum.core.ns, Num quantum.core.ns, double? quantum.core.type, map-entry? quantum.core.type, Regex quantum.core.ns, transient? quantum.core.type, regex? quantum.core.type, Key quantum.core.ns, pattern? quantum.core.type, Map quantum.core.ns, ArrList quantum.core.ns, array-list? quantum.core.type, LSeq quantum.core.ns, coll+? quantum.core.type, Set quantum.core.ns, editable? quantum.core.type, ExactNum quantum.core.ns, instance+? quantum.core.type, queue? quantum.core.type, Queue quantum.core.ns, TreeMap quantum.core.ns, Exception quantum.core.ns, class quantum.core.type, Decimal quantum.core.ns, Int quantum.core.ns, lseq? quantum.core.type, Transient quantum.core.ns}, :requires {ns quantum.core.ns, quantum.core.ns quantum.core.ns, map quantum.core.data.map, quantum.core.data.map quantum.core.data.map, quantum.core.macros quantum.core.macros, type quantum.core.type, quantum.core.type quantum.core.type}, :imports nil, :defs {reduce-2 {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/loops.cljc", :line 61, :column 7, :end-line 61, :end-column 15, :arglists (quote ([func init coll])), :doc "|reduce|s over 2 values in a collection with each pass.\n\n   Doesn't use CollReduce... so not as fast as |reduce|.", :todo ["Possibly find a better way to do it?"], :attribution "Alex Gunnarson"}, :name quantum.core.loops/reduce-2, :variadic false, :file "src/cljc/quantum/core/loops.cljc", :end-column 15, :method-params ([func init coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 61, :attribution "Alex Gunnarson", :todo ["Possibly find a better way to do it?"], :end-line 61, :max-fixed-arity 3, :fn-var true, :arglists (quote ([func init coll])), :doc "|reduce|s over 2 values in a collection with each pass.\n\n   Doesn't use CollReduce... so not as fast as |reduce|."}, while-recur {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/loops.cljc", :line 74, :column 7, :end-line 74, :end-column 18, :arglists (quote ([obj-0 pred func])), :attribution "Alex Gunnarson"}, :name quantum.core.loops/while-recur, :variadic false, :file "src/cljc/quantum/core/loops.cljc", :end-column 18, :method-params ([obj-0 pred func]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 74, :attribution "Alex Gunnarson", :end-line 74, :max-fixed-arity 3, :fn-var true, :arglists (quote ([obj-0 pred func]))}}}