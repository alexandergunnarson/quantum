;; Analyzed by ClojureScript 0.0-3269
{:use-macros nil, :excludes #{split-at}, :name quantum.core.data.map, :imports nil, :requires {avl clojure.data.avl, clojure.data.avl clojure.data.avl, ns quantum.core.ns, quantum.core.ns quantum.core.ns}, :uses {Editable quantum.core.ns, Nil quantum.core.ns, Bool quantum.core.ns, IllegalArgumentException quantum.core.ns, Vec quantum.core.ns, Num quantum.core.ns, Regex quantum.core.ns, Key quantum.core.ns, Map quantum.core.ns, ArrList quantum.core.ns, LSeq quantum.core.ns, Set quantum.core.ns, ExactNum quantum.core.ns, Queue quantum.core.ns, TreeMap quantum.core.ns, Exception quantum.core.ns, Decimal quantum.core.ns, Int quantum.core.ns, Transient quantum.core.ns}, :defs {map-entry {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/data/map.cljc", :line 28, :column 7, :end-line 28, :end-column 16, :arglists (quote ([k v])), :doc "A performant replacement for creating 2-tuples (vectors), e.g., as return values\n   in a |kv-reduce| function.", :attribution "Alex Gunnarson"}, :name quantum.core.data.map/map-entry, :variadic false, :file "src/cljc/quantum/core/data/map.cljc", :end-column 16, :method-params ([k v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 28, :attribution "Alex Gunnarson", :end-line 28, :max-fixed-arity 2, :fn-var true, :arglists (quote ([k v])), :doc "A performant replacement for creating 2-tuples (vectors), e.g., as return values\n   in a |kv-reduce| function."}, merge+ {:protocol-inline nil, :meta {:performance "782.922731 ms |merge+| vs. 1.133217 sec normal |merge| ; 1.5 times faster!", :file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/data/map.cljc", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(map-0 maps)], :arglists ([map-0 & maps]), :arglists-meta (nil)}, :column 7, :line 40, :attribution "Alex Gunnarson", :end-line 40, :arglists (quote ([map-0 & maps])), :doc "A performant drop-in replacemen for |clojure.core/merge|."}, :performance "782.922731 ms |merge+| vs. 1.133217 sec normal |merge| ; 1.5 times faster!", :name quantum.core.data.map/merge+, :variadic true, :file "src/cljc/quantum/core/data/map.cljc", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(map-0 maps)], :arglists ([map-0 & maps]), :arglists-meta (nil)}, :method-params [(map-0 maps)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 40, :attribution "Alex Gunnarson", :end-line 40, :max-fixed-arity 1, :fn-var true, :arglists ([map-0 & maps]), :doc "A performant drop-in replacemen for |clojure.core/merge|."}, merge-deep-with {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/data/map.cljc", :end-column 22, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f maps)], :arglists ([f & maps]), :arglists-meta (nil)}, :column 7, :line 52, :attribution "clojure.contrib.map-utils via taoensso.encore", :todo ["Replace |merge-with| with a more performant version which uses |merge+|."], :end-line 52, :arglists (quote ([f & maps])), :doc "Like `merge-with` but merges maps recursively, applying the given fn\n  only when there's a non-map at a particular level.\n\n  (merge-deep-with + {:a {:b {:c 1 :d {:x 1 :y 2}} :e 3} :f 4}\n                    {:a {:b {:c 2 :d {:z 9} :z 3} :e 100}})\n  => {:a {:b {:z 3, :c 3, :d {:z 9, :x 1, :y 2}}, :e 103}, :f 4}"}, :name quantum.core.data.map/merge-deep-with, :variadic true, :file "src/cljc/quantum/core/data/map.cljc", :end-column 22, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f maps)], :arglists ([f & maps]), :arglists-meta (nil)}, :method-params [(f maps)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 52, :attribution "clojure.contrib.map-utils via taoensso.encore", :todo ["Replace |merge-with| with a more performant version which uses |merge+|."], :end-line 52, :max-fixed-arity 1, :fn-var true, :arglists ([f & maps]), :doc "Like `merge-with` but merges maps recursively, applying the given fn\n  only when there's a non-map at a particular level.\n\n  (merge-deep-with + {:a {:b {:c 1 :d {:x 1 :y 2}} :e 3} :f 4}\n                    {:a {:b {:c 2 :d {:z 9} :z 3} :e 100}})\n  => {:a {:b {:z 3, :c 3, :d {:z 9, :x 1, :y 2}}, :e 103}, :f 4}"}, merge-deep {:name quantum.core.data.map/merge-deep, :file "src/cljc/quantum/core/data/map.cljc", :line 69, :column 1, :end-line 69, :end-column 16, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/data/map.cljc", :line 69, :column 6, :end-line 69, :end-column 16}}, sorted-map+ {:name quantum.core.data.map/sorted-map+, :file "src/cljc/quantum/core/data/map.cljc", :line 73, :column 1, :end-line 73, :end-column 17, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/data/map.cljc", :line 73, :column 6, :end-line 73, :end-column 17}}, sorted-map-by+ {:name quantum.core.data.map/sorted-map-by+, :file "src/cljc/quantum/core/data/map.cljc", :line 74, :column 1, :end-line 74, :end-column 20, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/data/map.cljc", :line 74, :column 6, :end-line 74, :end-column 20}}, split-at {:name quantum.core.data.map/split-at, :file "src/cljc/quantum/core/data/map.cljc", :line 76, :column 1, :end-line 76, :end-column 14, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/data/map.cljc", :line 76, :column 6, :end-line 76, :end-column 14}}}, :require-macros nil, :cljs.analyzer/constants {:seen #{:warn-on-boxed}, :order [:warn-on-boxed]}, :doc "Useful map functions. |map-entry|, a better merge (|merge+|), sorted-maps, etc."}