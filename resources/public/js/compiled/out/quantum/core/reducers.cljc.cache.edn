;; Analyzed by ClojureScript 0.0-3269
{:use-macros {whenf*n quantum.core.logic, condfc quantum.core.logic, defcurried quantum.core.function, ifn quantum.core.logic, do-mod quantum.core.macros, whencf*n quantum.core.logic, <- quantum.core.function, whenc quantum.core.logic, if*n quantum.core.logic, condf*n quantum.core.logic, fn-> quantum.core.function, rfn quantum.core.function, whenf quantum.core.logic, should-transientize? quantum.core.type, emit-comprehension quantum.core.macros, condf quantum.core.logic, fn->> quantum.core.function}, :excludes #{reduce ->Range Range}, :name quantum.core.reducers, :imports nil, :requires {set quantum.core.data.set, log quantum.core.logic, map quantum.core.data.map, quantum.core.macros quantum.core.macros, quantum.core.type quantum.core.type, num quantum.core.numeric, quantum.core.numeric quantum.core.numeric, fn quantum.core.function, walk clojure.walk, vec quantum.core.data.vector, macros quantum.core.macros, ns quantum.core.ns, quantum.core.data.vector quantum.core.data.vector, quantum.core.logic quantum.core.logic, type quantum.core.type, quantum.core.data.set quantum.core.data.set, clojure.walk clojure.walk, quantum.core.ns quantum.core.ns, quantum.core.data.map quantum.core.data.map, quantum.core.function quantum.core.function}, :uses {Editable quantum.core.ns, boolean? quantum.core.type, sorted-map? quantum.core.type, merge+ quantum.core.data.map, firsta quantum.core.function, sorted-map+ quantum.core.data.map, Nil quantum.core.ns, Bool quantum.core.ns, f*n quantum.core.function, IllegalArgumentException quantum.core.ns, fn-not quantum.core.logic, catvec quantum.core.data.vector, Vec quantum.core.ns, Num quantum.core.ns, double? quantum.core.type, map-entry? quantum.core.type, call quantum.core.function, Regex quantum.core.ns, transient? quantum.core.type, regex? quantum.core.type, Key quantum.core.ns, pattern? quantum.core.type, subvec+ quantum.core.data.vector, Map quantum.core.ns, ArrList quantum.core.ns, array-list? quantum.core.type, LSeq quantum.core.ns, fn-or quantum.core.logic, coll+? quantum.core.type, Set quantum.core.ns, splice-or quantum.core.logic, editable? quantum.core.type, ExactNum quantum.core.ns, instance+? quantum.core.type, fn-and quantum.core.logic, fn* quantum.core.function, queue? quantum.core.type, compr quantum.core.function, Queue quantum.core.ns, TreeMap quantum.core.ns, Exception quantum.core.ns, class quantum.core.type, Decimal quantum.core.ns, monoid quantum.core.function, Int quantum.core.ns, lseq? quantum.core.type, Transient quantum.core.ns, map-entry quantum.core.data.map, unary quantum.core.function}, :defs {folder+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 537, :column 7, :end-line 537, :end-column 14, :arglists (quote ([coll xf])), :doc "Given a foldable collection, and a transformation function xf,\n  returns a foldable collection, where any supplied reducing\n  fn will be transformed by xf. xf is a function of reducing fn to\n  reducing fn.\n\n  Modifies reducers to not use Java methods but external extensions.\n  This is because the protocol methods is not a Java method of the reducer\n  object anymore and thus it can be reclaimed while the protocol method\n  is executing.", :attribution "Christophe Grand - http://clj-me.cgrand.net/2013/09/11/macros-closures-and-unexpected-object-retention/", :todo ["Possibly fix the CLJS version?"]}, :name quantum.core.reducers/folder+, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 14, :method-params ([coll xf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 537, :attribution "Christophe Grand - http://clj-me.cgrand.net/2013/09/11/macros-closures-and-unexpected-object-retention/", :todo ["Possibly fix the CLJS version?"], :end-line 537, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll xf])), :doc "Given a foldable collection, and a transformation function xf,\n  returns a foldable collection, where any supplied reducing\n  fn will be transformed by xf. xf is a function of reducing fn to\n  reducing fn.\n\n  Modifies reducers to not use Java methods but external extensions.\n  This is because the protocol methods is not a Java method of the reducer\n  object anymore and thus it can be reclaimed while the protocol method\n  is executing."}, reduce {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 374, :column 7, :end-line 374, :end-column 13, :arglists (quote ([f coll] [f init coll])), :doc "Like |core/reduce| except:\n   When init is not provided, (f) is used.\n   Maps are reduced with reduce-kv.\n\n   Entry point for internal reduce (in order to switch the args\n   around to dispatch on type).", :attribution "Alex Gunnarson", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f coll] [f init coll]), :arglists ([f coll] [f init coll]), :arglists-meta (nil nil)}}, :name quantum.core.reducers/reduce, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f coll] [f init coll]), :arglists ([f coll] [f init coll]), :arglists-meta (nil nil)}, :method-params ([f coll] [f init coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 374, :attribution "Alex Gunnarson", :end-line 374, :max-fixed-arity 3, :fn-var true, :arglists ([f coll] [f init coll]), :doc "Like |core/reduce| except:\n   When init is not provided, (f) is used.\n   Maps are reduced with reduce-kv.\n\n   Entry point for internal reduce (in order to switch the args\n   around to dispatch on type)."}, reduce-s+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 676, :column 7, :end-line 676, :end-column 16, :arglists (quote ([coll])), :doc "Reduce into hash-set.", :todo ["Speed this up!"]}, :name quantum.core.reducers/reduce-s+, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 16, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 676, :todo ["Speed this up!"], :end-line 676, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Reduce into hash-set."}, t23183 {:num-fields 4, :protocols #{cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}, :name quantum.core.reducers/t23183, :file "src/cljc/quantum/core/reducers.cljc", :type true, :anonymous true, :column 5, :line 433, :record false, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}}, take* {:protocol-inline nil, :meta {:private true, :added "1.5", :file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :end-column 28, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([n] [n coll]), :arglists ([n] [n coll]), :arglists-meta (nil nil)}, :column 23, :line 1008, :contributors "Alex Gunnarson", :attribution "clojure.core.reducers", :end-line 1008, :arglists (quote ([n] [n coll])), :doc "Ends the reduction of coll after consuming n values."}, :private true, :added "1.5", :name quantum.core.reducers/take*, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 28, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([n] [n coll]), :arglists ([n] [n coll]), :arglists-meta (nil nil)}, :method-params ([n] [n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1008, :contributors "Alex Gunnarson", :attribution "clojure.core.reducers", :end-line 1008, :max-fixed-arity 2, :fn-var true, :arglists ([n] [n coll]), :doc "Ends the reduction of coll after consuming n values."}, mapcat* {:protocol-inline nil, :meta {:private true, :added "1.5", :file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :end-column 30, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}, :column 23, :line 825, :attribution "clojure.core.reducers", :end-line 825, :arglists (quote ([f] [f coll])), :doc "Applies f to every value in the reduction of coll, concatenating the result\n  colls of (f val). Foldable."}, :private true, :added "1.5", :name quantum.core.reducers/mapcat*, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 30, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}, :method-params ([f] [f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 825, :attribution "clojure.core.reducers", :end-line 825, :max-fixed-arity 2, :fn-var true, :arglists ([f] [f coll]), :doc "Applies f to every value in the reduction of coll, concatenating the result\n  colls of (f val). Foldable."}, distinct+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 1186, :column 14, :end-line 1186, :end-column 23, :tag Delay, :arglists (quote ([coll])), :doc "Remove adjacent duplicate values from @coll.\n   CAVEAT: Requires @coll to be sorted to work correctly.", :attribution "parkour.reducers"}, :name quantum.core.reducers/distinct+, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 23, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1186, :attribution "parkour.reducers", :ret-tag Delay, :end-line 1186, :max-fixed-arity 1, :tag Delay, :fn-var true, :arglists (quote ([coll])), :doc "Remove adjacent duplicate values from @coll.\n   CAVEAT: Requires @coll to be sorted to work correctly."}, distinct-by+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 1170, :column 14, :end-line 1170, :end-column 26, :tag Delay, :arglists (quote ([f coll])), :doc "Remove adjacent duplicate values of (@f x) for each x in @coll.\n   CAVEAT: Requires @coll to be sorted to work correctly.", :attribution "parkour.reducers"}, :name quantum.core.reducers/distinct-by+, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 26, :method-params ([f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1170, :attribution "parkour.reducers", :ret-tag Delay, :end-line 1170, :max-fixed-arity 2, :tag Delay, :fn-var true, :arglists (quote ([f coll])), :doc "Remove adjacent duplicate values of (@f x) for each x in @coll.\n   CAVEAT: Requires @coll to be sorted to work correctly."}, zipvec+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 1210, :column 7, :end-line 1210, :end-column 14, :arglists (quote ([vec-0] [vec-0 & vecs])), :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([vec-0]), :arglists ([vec-0] [vec-0 & vecs]), :arglists-meta (nil nil)}}, :name quantum.core.reducers/zipvec+, :variadic true, :file "src/cljc/quantum/core/reducers.cljc", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([vec-0]), :arglists ([vec-0] [vec-0 & vecs]), :arglists-meta (nil nil)}, :method-params ([vec-0]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1210, :end-line 1210, :max-fixed-arity 1, :fn-var true, :arglists ([vec-0] [vec-0 & vecs])}, reductions+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :end-column 18, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f coll] [f init coll]), :arglists ([f coll] [f init coll]), :arglists-meta (nil nil)}, :column 7, :usage (quote (into+ [] (reductions+ + [1 2 3]))), :line 854, :out (quote [1 3 6]), :attribution "parkour.reducers", :end-line 854, :arglists (quote ([f coll] [f init coll])), :doc "Reducers version of /reductions/.\n   Returns a reducer of the intermediate values of the reduction (as per reduce) of coll by f.\n   "}, :name quantum.core.reducers/reductions+, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 18, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f coll] [f init coll]), :arglists ([f coll] [f init coll]), :arglists-meta (nil nil)}, :method-params ([f coll] [f init coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :usage (quote (into+ [] (reductions+ + [1 2 3]))), :line 854, :out (quote [1 3 6]), :attribution "parkour.reducers", :end-line 854, :max-fixed-arity 3, :fn-var true, :arglists ([f coll] [f init coll]), :doc "Reducers version of /reductions/.\n   Returns a reducer of the intermediate values of the reduction (as per reduce) of coll by f.\n   "}, coll-n {:name quantum.core.reducers/coll-n, :file "src/cljc/quantum/core/reducers.cljc", :line 591, :column 3, :end-line 591, :end-column 14, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 591, :column 8, :end-line 591, :end-column 14}}, drop+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 1083, :column 14, :end-line 1083, :end-column 19, :tag Delay, :arglists (quote ([n coll]))}, :name quantum.core.reducers/drop+, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 19, :method-params ([n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1083, :ret-tag Delay, :end-line 1083, :max-fixed-arity 2, :tag Delay, :fn-var true, :arglists (quote ([n coll]))}, t23180 {:num-fields 4, :protocols #{cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}, :name quantum.core.reducers/t23180, :file "src/cljc/quantum/core/reducers.cljc", :type true, :anonymous true, :column 5, :line 433, :record false, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}}, vec+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 605, :column 6, :end-line 605, :end-column 10}, :name quantum.core.reducers/vec+, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 10, :method-params ([obj__22858__auto__]), :protocol-impl nil, :arglists-meta (), :column 1, :line 605, :end-line 605, :max-fixed-arity 1, :fn-var true, :arglists nil}, reduce-by+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 1125, :column 7, :end-line 1125, :end-column 17, :arglists (quote ([keyfn f coll] [keyfn f init coll])), :doc "Partition `coll` with `keyfn` as per /partition-by/, then reduce\n  each partition with `f` and optional initial value `init` as per\n  /reduce/.", :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([keyfn f coll] [keyfn f init coll]), :arglists ([keyfn f coll] [keyfn f init coll]), :arglists-meta (nil nil)}}, :name quantum.core.reducers/reduce-by+, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([keyfn f coll] [keyfn f init coll]), :arglists ([keyfn f coll] [keyfn f init coll]), :arglists-meta (nil nil)}, :method-params ([keyfn f coll] [keyfn f init coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1125, :end-line 1125, :max-fixed-arity 4, :fn-var true, :arglists ([keyfn f coll] [keyfn f init coll]), :doc "Partition `coll` with `keyfn` as per /partition-by/, then reduce\n  each partition with `f` and optional initial value `init` as per\n  /reduce/."}, reduce-impl {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 266, :column 8, :end-line 266, :end-column 19, :private true, :arglists (quote ([reducer-n])), :doc "Creates an implementation of CollReduce using the given reducer.\n  The two-argument implementation of reduce will call f1 with no args\n  to get an init value, and then forward on to your three-argument version.", :attribution "Alan Malloy - http://dev.clojure.org/jira/browse/CLJ-993"}, :private true, :name quantum.core.reducers/reduce-impl, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 19, :method-params ([reducer-n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 266, :attribution "Alan Malloy - http://dev.clojure.org/jira/browse/CLJ-993", :end-line 266, :max-fixed-arity 1, :fn-var true, :arglists (quote ([reducer-n])), :doc "Creates an implementation of CollReduce using the given reducer.\n  The two-argument implementation of reduce will call f1 with no args\n  to get an init value, and then forward on to your three-argument version."}, -reduce-kv {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 328, :column 8, :end-line 328, :end-column 18, :private true, :arglists (quote ([coll f init]))}, :private true, :name quantum.core.reducers/-reduce-kv, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 18, :method-params ([coll f init]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 328, :end-line 328, :max-fixed-arity 3, :fn-var true, :arglists (quote ([coll f init]))}, ->t23190 {:protocol-inline nil, :meta {:anonymous true, :protocols #{quantum.core.reducers/CollFold cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([folder+ coll xf meta23191])), :file nil}, :protocols #{quantum.core.reducers/CollFold cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}, :name quantum.core.reducers/->t23190, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :method-params ([folder+ coll xf meta23191]), :protocol-impl nil, :arglists-meta (nil nil), :anonymous true, :column 8, :factory :positional, :line 552, :max-fixed-arity 4, :fn-var true, :arglists (quote ([folder+ coll xf meta23191])), :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}}, zipvec* {:protocol-inline nil, :meta {:private true, :file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :end-column 30, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [coll]), :arglists ([] [coll]), :arglists-meta (nil nil)}, :column 23, :line 1194, :attribution "Alex Gunnarson", :end-line 1194, :arglists (quote ([] [coll])), :doc "Zipvec. Needs a better implementation.\n   Must start out with pre-catvec'd colls."}, :private true, :name quantum.core.reducers/zipvec*, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 30, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [coll]), :arglists ([] [coll]), :arglists-meta (nil nil)}, :method-params ([] [coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1194, :attribution "Alex Gunnarson", :end-line 1194, :max-fixed-arity 1, :fn-var true, :arglists ([] [coll]), :doc "Zipvec. Needs a better implementation.\n   Must start out with pre-catvec'd colls."}, drop-while* {:protocol-inline nil, :meta {:private true, :file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :end-column 34, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}, :column 23, :line 1086, :attribution "Alan Malloy - http://dev.clojure.org/jira/browse/CLJ-993", :end-line 1086, :arglists (quote ([pred] [pred coll])), :doc "Skips values from the reduction of coll while (pred val) returns logical true."}, :private true, :name quantum.core.reducers/drop-while*, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 34, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}, :method-params ([pred] [pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1086, :attribution "Alan Malloy - http://dev.clojure.org/jira/browse/CLJ-993", :end-line 1086, :max-fixed-arity 2, :fn-var true, :arglists ([pred] [pred coll]), :doc "Skips values from the reduction of coll while (pred val) returns logical true."}, each {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 1265, :column 13, :end-line 1265, :end-column 17, :arglists (quote ([f] [f coll])), :doc "Applies f to each item in coll, returns nil", :attribution "transduce.reducers", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}}, :name quantum.core.reducers/each, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}, :method-params ([f] [f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1265, :attribution "transduce.reducers", :end-line 1265, :max-fixed-arity 2, :fn-var true, :arglists ([f] [f coll]), :doc "Applies f to each item in coll, returns nil"}, indexed+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 816, :column 7, :end-line 816, :end-column 15, :arglists (quote ([coll])), :doc "Returns an ordered sequence of vectors `[index item]`, where item is a\n  value in coll, and index its position starting from zero.", :attribution "weavejester.medley"}, :name quantum.core.reducers/indexed+, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 816, :attribution "weavejester.medley", :end-line 816, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns an ordered sequence of vectors `[index item]`, where item is a\n  value in coll, and index its position starting from zero."}, map* {:protocol-inline nil, :meta {:private true, :added "1.5", :file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :end-column 27, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}, :column 23, :line 794, :attribution "clojure.core.reducers", :end-line 794, :arglists (quote ([f] [f coll])), :doc "Applies f to every value in the reduction of coll. Foldable."}, :private true, :added "1.5", :name quantum.core.reducers/map*, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 27, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}, :method-params ([f] [f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 794, :attribution "clojure.core.reducers", :end-line 794, :max-fixed-arity 2, :fn-var true, :arglists ([f] [f coll]), :doc "Applies f to every value in the reduction of coll. Foldable."}, fjjoin {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 262, :column 17, :end-line 262, :end-column 23, :private true, :arglists (quote ([task]))}, :private true, :name quantum.core.reducers/fjjoin, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 23, :method-params ([task]), :protocol-impl nil, :arglists-meta (nil nil), :column 10, :line 262, :end-line 262, :max-fixed-arity 1, :fn-var true, :arglists (quote ([task]))}, fjinvoke {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 260, :column 17, :end-line 260, :end-column 25, :private true, :arglists (quote ([f]))}, :private true, :name quantum.core.reducers/fjinvoke, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 25, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 10, :line 260, :end-line 260, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f]))}, into+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 393, :column 7, :end-line 393, :end-column 12, :arglists (quote ([to from] [to from & froms])), :todo ["Add extra arities"], :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([to from]), :arglists ([to from] [to from & froms]), :arglists-meta (nil nil)}}, :name quantum.core.reducers/into+, :variadic true, :file "src/cljc/quantum/core/reducers.cljc", :end-column 12, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([to from]), :arglists ([to from] [to from & froms]), :arglists-meta (nil nil)}, :method-params ([to from]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 393, :todo ["Add extra arities"], :end-line 393, :max-fixed-arity 2, :fn-var true, :arglists ([to from] [to from & froms])}, fold-by-halves {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 465, :column 8, :end-line 465, :end-column 22, :private true, :arglists (quote ([halving-fn coll n combinef reducef])), :doc "Folds the provided collection by halving it until it is smaller than the\n  requested size, and folding each subsection. halving-fn will be passed as\n  input a collection and its size (so you need not recompute the size); it\n  should return the left and right halves of the collection as a pair. Those\n  halves will normally be of the same type as the parent collection, but\n  anything foldable is sufficient.\n\n  Generalized from |foldvec| to work for anything you can split in half.", :attribution "Alan Malloy - http://dev.clojure.org/jira/browse/CLJ-993"}, :private true, :name quantum.core.reducers/fold-by-halves, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 22, :method-params ([halving-fn coll n combinef reducef]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 465, :attribution "Alan Malloy - http://dev.clojure.org/jira/browse/CLJ-993", :end-line 465, :max-fixed-arity 5, :fn-var true, :arglists (quote ([halving-fn coll n combinef reducef])), :doc "Folds the provided collection by halving it until it is smaller than the\n  requested size, and folding each subsection. halving-fn will be passed as\n  input a collection and its size (so you need not recompute the size); it\n  should return the left and right halves of the collection as a pair. Those\n  halves will normally be of the same type as the parent collection, but\n  anything foldable is sufficient.\n\n  Generalized from |foldvec| to work for anything you can split in half."}, ->t23180 {:protocol-inline nil, :meta {:anonymous true, :protocols #{cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([reducer+ coll xf meta23181])), :file nil}, :protocols #{cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}, :name quantum.core.reducers/->t23180, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :method-params ([reducer+ coll xf meta23181]), :protocol-impl nil, :arglists-meta (nil nil), :anonymous true, :column 5, :factory :positional, :line 433, :max-fixed-arity 4, :fn-var true, :arglists (quote ([reducer+ coll xf meta23181])), :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}}, flatten* {:protocol-inline nil, :meta {:private true, :added "1.5", :file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :end-column 31, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [coll]), :arglists ([] [coll]), :arglists-meta (nil nil)}, :column 23, :line 908, :attribution "clojure.core.reducers", :end-line 908, :arglists (quote ([] [coll])), :doc "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat foldable\n  collection."}, :private true, :added "1.5", :name quantum.core.reducers/flatten*, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 31, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [coll]), :arglists ([] [coll]), :arglists-meta (nil nil)}, :method-params ([] [coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 908, :attribution "clojure.core.reducers", :end-line 908, :max-fixed-arity 1, :fn-var true, :arglists ([] [coll]), :doc "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat foldable\n  collection."}, reducer? {:name quantum.core.reducers/reducer?, :file "src/cljc/quantum/core/reducers.cljc", :line 577, :column 1, :end-line 577, :end-column 14, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 577, :column 6, :end-line 577, :end-column 14}}, reducer+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 425, :column 7, :end-line 425, :end-column 15, :arglists (quote ([coll xf])), :doc "Given a reducible collection, and a transformation function xf,\n  returns a reducible collection, where any supplied reducing\n  fn will be transformed by xf. xf is a function of reducing fn to\n  reducing fn.", :added "1.5", :attribution "clojure.core.reducers"}, :added "1.5", :name quantum.core.reducers/reducer+, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 15, :method-params ([coll xf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 425, :attribution "clojure.core.reducers", :end-line 425, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll xf])), :doc "Given a reducible collection, and a transformation function xf,\n  returns a reducible collection, where any supplied reducing\n  fn will be transformed by xf. xf is a function of reducing fn to\n  reducing fn."}, foldp-max+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 642, :column 7, :end-line 642, :end-column 17, :arglists (quote ([obj]))}, :name quantum.core.reducers/foldp-max+, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 17, :method-params ([obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 642, :end-line 642, :max-fixed-arity 1, :fn-var true, :arglists (quote ([obj]))}, foldp+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 644, :column 7, :end-line 644, :end-column 13, :arglists (quote ([obj])), :todo ["Detect whether there can be a speed improvement achieved or not"]}, :name quantum.core.reducers/foldp+, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 13, :method-params ([obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 644, :todo ["Detect whether there can be a speed improvement achieved or not"], :end-line 644, :max-fixed-arity 1, :fn-var true, :arglists (quote ([obj]))}, remove+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 901, :column 7, :end-line 901, :end-column 14, :arglists (quote ([func coll]))}, :name quantum.core.reducers/remove+, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 14, :method-params ([func coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 901, :end-line 901, :max-fixed-arity 2, :fn-var true, :arglists (quote ([func coll]))}, t23190 {:num-fields 4, :protocols #{quantum.core.reducers/CollFold cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}, :name quantum.core.reducers/t23190, :file "src/cljc/quantum/core/reducers.cljc", :type true, :anonymous true, :column 8, :line 552, :record false, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}}, t23245 {:num-fields 3, :protocols #{cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}, :name quantum.core.reducers/t23245, :file "src/cljc/quantum/core/reducers.cljc", :type true, :anonymous true, :column 3, :line 939, :record false, :skip-protocol-flag #{cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}}, CollFold {:meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 462, :column 14, :end-line 462, :end-column 22, :doc nil, :protocol-symbol true, :protocol-info {:methods {coll-fold [[coll n combinef reducef]]}}}, :protocol-symbol true, :name quantum.core.reducers/CollFold, :file "src/cljc/quantum/core/reducers.cljc", :end-column 22, :column 1, :line 462, :protocol-info {:methods {coll-fold [[coll n combinef reducef]]}}, :info nil, :end-line 462, :impls #{nil quantum.core.reducers/t23193 object quantum.core.reducers/Range cljs.core/PersistentVector quantum.core.reducers/t23190 quantum.core.reducers/Cat clojure/data.avl.AVLMap}, :doc nil}, take-while* {:protocol-inline nil, :meta {:private true, :added "1.5", :file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :end-column 34, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}, :column 23, :line 1026, :attribution "clojure.core.reducers", :end-line 1026, :arglists (quote ([pred] [pred coll])), :doc "Ends the reduction of coll when (pred val) returns logical false."}, :private true, :added "1.5", :name quantum.core.reducers/take-while*, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 34, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}, :method-params ([pred] [pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1026, :attribution "clojure.core.reducers", :end-line 1026, :max-fixed-arity 2, :fn-var true, :arglists ([pred] [pred coll]), :doc "Ends the reduction of coll when (pred val) returns logical false."}, flatten-1+ {:name quantum.core.reducers/flatten-1+, :file "src/cljc/quantum/core/reducers.cljc", :line 926, :column 1, :end-line 926, :end-column 17, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 926, :column 7, :end-line 926, :end-column 17}}, reducem+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 402, :column 7, :end-line 402, :end-column 15, :arglists (quote ([coll])), :doc "Requires only one argument for preceding functions in its call chain.", :attribution "Alex Gunnarson", :performance "9.94 ms vs. 17.02 ms for 10000 calls to (into+ {}) for small collections ;\n           This is because the |transient| function deals a performance hit."}, :performance "9.94 ms vs. 17.02 ms for 10000 calls to (into+ {}) for small collections ;\n           This is because the |transient| function deals a performance hit.", :name quantum.core.reducers/reducem+, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 402, :attribution "Alex Gunnarson", :end-line 402, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Requires only one argument for preceding functions in its call chain."}, ->t23183 {:protocol-inline nil, :meta {:anonymous true, :protocols #{cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([reducer+ coll xf meta23184])), :file nil}, :protocols #{cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}, :name quantum.core.reducers/->t23183, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :method-params ([reducer+ coll xf meta23184]), :protocol-impl nil, :arglists-meta (nil nil), :anonymous true, :column 5, :factory :positional, :line 433, :max-fixed-arity 4, :fn-var true, :arglists (quote ([reducer+ coll xf meta23184])), :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}}, group-by+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :end-column 16, :column 7, :usage (quote (group-by odd? (range 10))), :line 1154, :out (quote {false [0 2 4 6 8], true [1 3 5 7 9]}), :attribution "Christophe Grand - http://grokbase.com/t/gg/clojure/12c3k7ztbz/group-by-vs-reducers", :end-line 1154, :arglists (quote ([f coll])), :doc "Reducers version. Possibly slower than |core/group-by|"}, :name quantum.core.reducers/group-by+, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 16, :method-params ([f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :usage (quote (group-by odd? (range 10))), :line 1154, :out (quote {false [0 2 4 6 8], true [1 3 5 7 9]}), :attribution "Christophe Grand - http://grokbase.com/t/gg/clojure/12c3k7ztbz/group-by-vs-reducers", :end-line 1154, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f coll])), :doc "Reducers version. Possibly slower than |core/group-by|"}, cat+ {:protocol-inline nil, :meta {:added "1.5", :file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([] [ctor] [left-0 right-0]), :arglists ([] [ctor] [left-0 right-0]), :arglists-meta (nil nil nil)}, :column 7, :line 752, :attribution "clojure.core.reducers", :end-line 752, :arglists (quote ([] [ctor] [left-0 right-0])), :doc "A high-performance combining fn that yields the catenation of the\n  reduced values. The result is reducible, foldable, seqable and\n  counted, providing the identity collections are reducible, seqable\n  and counted. The single argument version will build a combining fn\n  with the supplied identity constructor. Tests for identity\n  with (zero? (count x)). See also foldcat."}, :added "1.5", :name quantum.core.reducers/cat+, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([] [ctor] [left-0 right-0]), :arglists ([] [ctor] [left-0 right-0]), :arglists-meta (nil nil nil)}, :method-params ([] [ctor] [left-0 right-0]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 752, :attribution "clojure.core.reducers", :end-line 752, :max-fixed-arity 2, :fn-var true, :arglists ([] [ctor] [left-0 right-0]), :doc "A high-performance combining fn that yields the catenation of the\n  reduced values. The result is reducible, foldable, seqable and\n  counted, providing the identity collections are reducible, seqable\n  and counted. The single argument version will build a combining fn\n  with the supplied identity constructor. Tests for identity\n  with (zero? (count x)). See also foldcat."}, map-indexed+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :end-column 19, :column 7, :usage (quote (map-indexed vector "foobar")), :line 806, :out (quote ([0 \f] [1 \o] [2 \o] [3 \b] [4 \a] [5 \r])), :attribution "parkour.reducers", :end-line 806, :arglists (quote ([f coll])), :doc "Reducers version of /map-indexed/."}, :name quantum.core.reducers/map-indexed+, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 19, :method-params ([f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :usage (quote (map-indexed vector "foobar")), :line 806, :out (quote ([0 \f] [1 \o] [2 \o] [3 \b] [4 \a] [5 \r])), :attribution "parkour.reducers", :end-line 806, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f coll])), :doc "Reducers version of /map-indexed/."}, mapcat-state {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 706, :column 13, :end-line 706, :end-column 25, :arglists (quote ([f init] [f init coll])), :doc "Like mapcat, but threads a state through the sequence of transformations. ; so basically like /reductions/?\n  For each x in coll, f is applied to [state x] and should return [state' xs].\n  The result is the concatenation of each returned xs.", :attribution "transduce.reducers", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f init] [f init coll]), :arglists ([f init] [f init coll]), :arglists-meta (nil nil)}}, :name quantum.core.reducers/mapcat-state, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 25, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f init] [f init coll]), :arglists ([f init] [f init coll]), :arglists-meta (nil nil)}, :method-params ([f init] [f init coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 706, :attribution "transduce.reducers", :end-line 706, :max-fixed-arity 3, :fn-var true, :arglists ([f init] [f init coll]), :doc "Like mapcat, but threads a state through the sequence of transformations. ; so basically like /reductions/?\n  For each x in coll, f is applied to [state x] and should return [state' xs].\n  The result is the concatenation of each returned xs."}, append! {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 776, :column 7, :end-line 776, :end-column 14, :arglists (quote ([acc x])), :doc ".adds x to acc and returns acc", :added "1.5", :attribution "clojure.core.reducers"}, :added "1.5", :name quantum.core.reducers/append!, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 14, :method-params ([acc x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 776, :attribution "clojure.core.reducers", :end-line 776, :max-fixed-arity 2, :fn-var true, :arglists (quote ([acc x])), :doc ".adds x to acc and returns acc"}, filter* {:protocol-inline nil, :meta {:private true, :added "1.5", :file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :end-column 30, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}, :column 23, :line 877, :attribution "clojure.core.reducers", :end-line 877, :arglists (quote ([pred] [pred coll])), :doc "Retains values in the reduction of coll for which (pred val)\n  returns logical true. Foldable."}, :private true, :added "1.5", :name quantum.core.reducers/filter*, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 30, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}, :method-params ([pred] [pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 877, :attribution "clojure.core.reducers", :end-line 877, :max-fixed-arity 2, :fn-var true, :arglists ([pred] [pred coll]), :doc "Retains values in the reduction of coll for which (pred val)\n  returns logical true. Foldable."}, drop* {:protocol-inline nil, :meta {:private true, :added "1.5", :file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :end-column 28, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([n] [n coll]), :arglists ([n] [n coll]), :arglists-meta (nil nil)}, :column 23, :line 1068, :attribution "clojure.core.reducers", :end-line 1068, :arglists (quote ([n] [n coll])), :doc "Elides the first n values from the reduction of coll."}, :private true, :added "1.5", :name quantum.core.reducers/drop*, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 28, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([n] [n coll]), :arglists ([n] [n coll]), :arglists-meta (nil nil)}, :method-params ([n] [n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1068, :attribution "clojure.core.reducers", :end-line 1068, :max-fixed-arity 2, :fn-var true, :arglists ([n] [n coll]), :doc "Elides the first n values from the reduction of coll."}, ->Cat {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 724, :column 10, :end-line 724, :end-column 13, :protocols #{cljs.core/ICounted quantum.core.reducers/CollFold cljs.core/ISeqable cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/ICounted cljs.core/ISeqable cljs.core/IReduce}, :factory :positional, :arglists (quote ([cnt left right]))}, :protocols #{cljs.core/ICounted quantum.core.reducers/CollFold cljs.core/ISeqable cljs.core/IReduce}, :name quantum.core.reducers/->Cat, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 13, :method-params ([cnt left right]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 724, :end-line 724, :max-fixed-arity 3, :fn-var true, :arglists (quote ([cnt left right])), :skip-protocol-flag #{cljs.core/ICounted cljs.core/ISeqable cljs.core/IReduce}}, fold+ {:protocol-inline nil, :meta {:added "1.5", :file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :end-column 12, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([obj] [reducef coll] [combinef reducef coll] [n combinef reducef coll]), :arglists ([obj] [reducef coll] [combinef reducef coll] [n combinef reducef coll]), :arglists-meta (nil nil nil nil)}, :column 7, :line 612, :contributors ["Alex Gunnarson"], :attribution "clojure.core.reducers", :todo ["Make more efficient." "So many fns created in this lead to inefficiency."], :end-line 612, :arglists (quote ([obj] [reducef coll] [combinef reducef coll] [n combinef reducef coll])), :doc "Reduces a collection using a (potentially parallel) reduce-combine\n  strategy. The collection is partitioned into groups of approximately\n  n (default 512), each of which is reduced with reducef (with a seed\n  value obtained by calling (combinef) with no arguments). The results\n  of these reductions are then reduced with combinef (default\n  reducef).\n  @combinef must be associative. When called with no\n  arguments, (combinef) must produce its identity element.\n  These operations may be performed in parallel, but the results will preserve order."}, :added "1.5", :name quantum.core.reducers/fold+, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 12, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([obj] [reducef coll] [combinef reducef coll] [n combinef reducef coll]), :arglists ([obj] [reducef coll] [combinef reducef coll] [n combinef reducef coll]), :arglists-meta (nil nil nil nil)}, :method-params ([obj] [reducef coll] [combinef reducef coll] [n combinef reducef coll]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 612, :contributors ["Alex Gunnarson"], :attribution "clojure.core.reducers", :todo ["Make more efficient." "So many fns created in this lead to inefficiency."], :end-line 612, :max-fixed-arity 4, :fn-var true, :arglists ([obj] [reducef coll] [combinef reducef coll] [n combinef reducef coll]), :doc "Reduces a collection using a (potentially parallel) reduce-combine\n  strategy. The collection is partitioned into groups of approximately\n  n (default 512), each of which is reduced with reducef (with a seed\n  value obtained by calling (combinef) with no arguments). The results\n  of these reductions are then reduced with combinef (default\n  reducef).\n  @combinef must be associative. When called with no\n  arguments, (combinef) must produce its identity element.\n  These operations may be performed in parallel, but the results will preserve order."}, flatten+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 925, :column 7, :end-line 925, :end-column 15, :arglists (quote ([coll]))}, :name quantum.core.reducers/flatten+, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 925, :end-line 925, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, foldm+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 654, :column 7, :end-line 654, :end-column 13, :arglists (quote ([obj]))}, :name quantum.core.reducers/foldm+, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 13, :method-params ([obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 654, :end-line 654, :max-fixed-arity 1, :fn-var true, :arglists (quote ([obj]))}, filter+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 891, :column 7, :end-line 891, :end-column 14, :arglists (quote ([func coll]))}, :name quantum.core.reducers/filter+, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 14, :method-params ([func coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 891, :end-line 891, :max-fixed-arity 2, :fn-var true, :arglists (quote ([func coll]))}, fold-pre {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 387, :column 6, :end-line 387, :end-column 14}, :name quantum.core.reducers/fold-pre, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 14, :method-params ([obj__22858__auto__]), :protocol-impl nil, :arglists-meta (), :column 1, :line 387, :end-line 387, :max-fixed-arity 1, :fn-var true, :arglists nil}, -reduce-seq {:protocol-inline nil, :meta {:private true, :file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :end-column 21, :column 10, :line 315, :attribution "Alex Gunnarson", :todo ["Check if this is really the case..." "Improve performance with chunking, etc."], :end-line 315, :arglists (quote ([coll f init])), :doc "For some reason |reduce| is not implemented in ClojureScript for certain types.\n     This is a |loop|-|recur| replacement for it."}, :private true, :name quantum.core.reducers/-reduce-seq, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 21, :method-params ([coll f init]), :protocol-impl nil, :arglists-meta (nil nil), :column 3, :line 315, :attribution "Alex Gunnarson", :todo ["Check if this is really the case..." "Improve performance with chunking, etc."], :end-line 315, :max-fixed-arity 3, :fn-var true, :arglists (quote ([coll f init])), :doc "For some reason |reduce| is not implemented in ClojureScript for certain types.\n     This is a |loop|-|recur| replacement for it."}, Cat {:num-fields 3, :protocols #{cljs.core/ICounted quantum.core.reducers/CollFold cljs.core/ISeqable cljs.core/IReduce}, :name quantum.core.reducers/Cat, :file "src/cljc/quantum/core/reducers.cljc", :end-column 13, :type true, :column 10, :line 724, :record false, :end-line 724, :skip-protocol-flag #{cljs.core/ICounted cljs.core/ISeqable cljs.core/IReduce}}, count* {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 418, :column 7, :end-line 418, :end-column 13, :arglists (quote ([coll])), :attribution "parkour.reducers", :performance "On non-counted collections, |count| is 71.542581 ms, whereas\n                 |count*| is 36.824665 ms - twice as fast!!"}, :performance "On non-counted collections, |count| is 71.542581 ms, whereas\n                 |count*| is 36.824665 ms - twice as fast!!", :name quantum.core.reducers/count*, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 418, :attribution "parkour.reducers", :end-line 418, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, Reduce+ {:meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 286, :column 3, :end-line 286, :end-column 10, :doc nil, :attribution "Alex Gunnarson", :protocol-symbol true, :protocol-info {:methods {reduce+ [[coll f] [coll f init]]}}}, :protocol-symbol true, :name quantum.core.reducers/Reduce+, :file "src/cljc/quantum/core/reducers.cljc", :end-column 10, :column 1, :line 280, :protocol-info {:methods {reduce+ [[coll f] [coll f init]]}}, :attribution "Alex Gunnarson", :info nil, :end-line 286, :impls #{nil default array string}, :doc nil}, foldm-s+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 657, :column 7, :end-line 657, :end-column 15, :arglists (quote ([obj])), :doc "Single-threaded to get around a weird 'ClassCastException' which\n   occurs presumably because of thread overload."}, :name quantum.core.reducers/foldm-s+, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 15, :method-params ([obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 657, :end-line 657, :max-fixed-arity 1, :fn-var true, :arglists (quote ([obj])), :doc "Single-threaded to get around a weird 'ClassCastException' which\n   occurs presumably because of thread overload."}, mapcat+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 846, :column 14, :end-line 846, :end-column 21, :tag Delay, :arglists (quote ([func coll]))}, :name quantum.core.reducers/mapcat+, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 21, :method-params ([func coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 846, :ret-tag Delay, :end-line 846, :max-fixed-arity 2, :tag Delay, :fn-var true, :arglists (quote ([func coll]))}, take-while+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 1039, :column 8, :end-line 1039, :end-column 19, :arglists (quote ([pred coll]))}, :name quantum.core.reducers/take-while+, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 19, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1039, :end-line 1039, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred coll]))}, iterate+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 955, :column 7, :end-line 955, :end-column 15, :arglists (quote ([func seed]))}, :name quantum.core.reducers/iterate+, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 15, :method-params ([func seed]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 955, :end-line 955, :max-fixed-arity 2, :fn-var true, :arglists (quote ([func seed]))}, orig-folder-coll {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 590, :column 7, :end-line 590, :end-column 23, :arglists (quote ([coll-0]))}, :name quantum.core.reducers/orig-folder-coll, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 23, :method-params ([coll-0]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 590, :end-line 590, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll-0]))}, fold-s+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 663, :column 7, :end-line 663, :end-column 14, :arglists (quote ([coll])), :doc "Fold into hash-set.", :todo ["Speed this up!"]}, :name quantum.core.reducers/fold-s+, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 14, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 663, :todo ["Speed this up!"], :end-line 663, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Fold into hash-set."}, foldcat+ {:protocol-inline nil, :meta {:performance "foldcat+ is faster than |into| a PersistentVector because it outputs ArrayLists", :added "1.5", :file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :end-column 15, :column 7, :line 784, :attribution "clojure.core.reducers", :end-line 784, :arglists (quote ([coll])), :doc "Equivalent to (fold cat append! coll)"}, :performance "foldcat+ is faster than |into| a PersistentVector because it outputs ArrayLists", :added "1.5", :name quantum.core.reducers/foldcat+, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 784, :attribution "clojure.core.reducers", :end-line 784, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Equivalent to (fold cat append! coll)"}, fold-size {:name quantum.core.reducers/fold-size, :file "src/cljc/quantum/core/reducers.cljc", :line 583, :column 1, :end-line 583, :end-column 15, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 583, :column 6, :end-line 583, :end-column 15}}, remove* {:protocol-inline nil, :meta {:private true, :added "1.5", :file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :end-column 30, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}, :column 23, :line 893, :attribution "clojure.core.reducers", :end-line 893, :arglists (quote ([pred] [pred coll])), :doc "Removes values in the reduction of coll for which (pred val)\n  returns logical true. Foldable."}, :private true, :added "1.5", :name quantum.core.reducers/remove*, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 30, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}, :method-params ([pred] [pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 893, :attribution "clojure.core.reducers", :end-line 893, :max-fixed-arity 2, :fn-var true, :arglists ([pred] [pred coll]), :doc "Removes values in the reduction of coll for which (pred val)\n  returns logical true. Foldable."}, ->Range {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 960, :column 10, :end-line 960, :end-column 15, :protocols #{cljs.core/ICounted quantum.core.reducers/CollFold cljs.core/ISeqable cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/ICounted cljs.core/ISeqable cljs.core/IReduce}, :factory :positional, :arglists (quote ([start end step]))}, :protocols #{cljs.core/ICounted quantum.core.reducers/CollFold cljs.core/ISeqable cljs.core/IReduce}, :name quantum.core.reducers/->Range, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 15, :method-params ([start end step]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 960, :end-line 960, :max-fixed-arity 3, :fn-var true, :arglists (quote ([start end step])), :skip-protocol-flag #{cljs.core/ICounted cljs.core/ISeqable cljs.core/IReduce}}, map-state {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :end-column 22, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f init] [f init coll]), :arglists ([f init] [f init coll]), :arglists-meta (nil nil)}, :column 13, :line 691, :attribution "transduce.reducers", :todo ["Test if volatiles will work."], :end-line 691, :arglists (quote ([f init] [f init coll])), :doc "Like map, but threads a state through the sequence of transformations.\n  For each x in coll, f is applied to [state x] and should return [state' x'].\n  The first invocation of f uses init as the state."}, :name quantum.core.reducers/map-state, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 22, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f init] [f init coll]), :arglists ([f init] [f init coll]), :arglists-meta (nil nil)}, :method-params ([f init] [f init coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 691, :attribution "transduce.reducers", :todo ["Test if volatiles will work."], :end-line 691, :max-fixed-arity 3, :fn-var true, :arglists ([f init] [f init coll]), :doc "Like map, but threads a state through the sequence of transformations.\n  For each x in coll, f is applied to [state x] and should return [state' x'].\n  The first invocation of f uses init as the state."}, Range {:num-fields 3, :protocols #{cljs.core/ICounted quantum.core.reducers/CollFold cljs.core/ISeqable cljs.core/IReduce}, :name quantum.core.reducers/Range, :file "src/cljc/quantum/core/reducers.cljc", :end-column 15, :type true, :column 10, :line 960, :record false, :end-line 960, :skip-protocol-flag #{cljs.core/ICounted cljs.core/ISeqable cljs.core/IReduce}}, ->t23245 {:protocol-inline nil, :meta {:anonymous true, :protocols #{cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([f seed meta23246])), :file nil}, :protocols #{cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}, :name quantum.core.reducers/->t23245, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :method-params ([f seed meta23246]), :protocol-impl nil, :arglists-meta (nil nil), :anonymous true, :column 3, :factory :positional, :line 939, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f seed meta23246])), :skip-protocol-flag #{cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}}, concat+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 848, :column 7, :end-line 848, :end-column 14, :arglists (quote ([& args])), :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(args)], :arglists ([& args]), :arglists-meta (nil)}}, :name quantum.core.reducers/concat+, :variadic true, :file "src/cljc/quantum/core/reducers.cljc", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(args)], :arglists ([& args]), :arglists-meta (nil)}, :method-params [(args)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 848, :end-line 848, :max-fixed-arity 0, :fn-var true, :arglists ([& args])}, drop-while+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 1100, :column 14, :end-line 1100, :end-column 25, :tag Delay, :arglists (quote ([pred coll]))}, :name quantum.core.reducers/drop-while+, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 25, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1100, :ret-tag Delay, :end-line 1100, :max-fixed-arity 2, :tag Delay, :fn-var true, :arglists (quote ([pred coll]))}, fold-am+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 655, :column 7, :end-line 655, :end-column 15, :arglists (quote ([obj]))}, :name quantum.core.reducers/fold-am+, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 15, :method-params ([obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 655, :end-line 655, :max-fixed-arity 1, :fn-var true, :arglists (quote ([obj]))}, take+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 1024, :column 8, :end-line 1024, :end-column 13, :arglists (quote ([n coll]))}, :name quantum.core.reducers/take+, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 13, :method-params ([n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1024, :end-line 1024, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n coll]))}, fjtask {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 259, :column 17, :end-line 259, :end-column 23, :private true, :arglists (quote ([f]))}, :private true, :name quantum.core.reducers/fjtask, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 23, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 10, :line 259, :end-line 259, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f]))}, reverse-conses {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 179, :column 8, :end-line 179, :end-column 22, :private true, :arglists (quote ([s tail] [s from-tail to-tail])), :attribution "Christophe Grand, http://clj-me.cgrand.net/2013/02/11/from-lazy-seqs-to-reducers-and-back/", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([s tail] [s from-tail to-tail]), :arglists ([s tail] [s from-tail to-tail]), :arglists-meta (nil nil)}}, :private true, :name quantum.core.reducers/reverse-conses, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 22, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([s tail] [s from-tail to-tail]), :arglists ([s tail] [s from-tail to-tail]), :arglists-meta (nil nil)}, :method-params ([s tail] [s from-tail to-tail]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 179, :attribution "Christophe Grand, http://clj-me.cgrand.net/2013/02/11/from-lazy-seqs-to-reducers-and-back/", :end-line 179, :max-fixed-arity 3, :fn-var true, :arglists ([s tail] [s from-tail to-tail])}, map+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 804, :column 7, :end-line 804, :end-column 11, :arglists (quote ([func coll]))}, :name quantum.core.reducers/map+, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 11, :method-params ([func coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 804, :end-line 804, :max-fixed-arity 2, :fn-var true, :arglists (quote ([func coll]))}, keep+ {:name quantum.core.reducers/keep+, :file "src/cljc/quantum/core/reducers.cljc", :line 903, :column 1, :end-line 903, :end-column 11, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 903, :column 6, :end-line 903, :end-column 11}}, coll-fold {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 463, :column 4, :end-line 463, :end-column 13, :protocol quantum.core.reducers/CollFold, :doc nil, :arglists (quote ([coll n combinef reducef]))}, :protocol quantum.core.reducers/CollFold, :name quantum.core.reducers/coll-fold, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 13, :method-params ([coll n combinef reducef]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 462, :end-line 463, :max-fixed-arity 4, :fn-var true, :arglists (quote ([coll n combinef reducef])), :doc nil}, foldm* {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 648, :column 7, :end-line 648, :end-column 13, :arglists (quote ([map-fn obj]))}, :name quantum.core.reducers/foldm*, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 13, :method-params ([map-fn obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 648, :end-line 648, :max-fixed-arity 2, :fn-var true, :arglists (quote ([map-fn obj]))}, fjfork {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 261, :column 17, :end-line 261, :end-column 23, :private true, :arglists (quote ([task]))}, :private true, :name quantum.core.reducers/fjfork, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 23, :method-params ([task]), :protocol-impl nil, :arglists-meta (nil nil), :column 10, :line 261, :end-line 261, :max-fixed-arity 1, :fn-var true, :arglists (quote ([task]))}, fold-sm+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 656, :column 7, :end-line 656, :end-column 15, :arglists (quote ([obj]))}, :name quantum.core.reducers/fold-sm+, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 15, :method-params ([obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 656, :end-line 656, :max-fixed-arity 1, :fn-var true, :arglists (quote ([obj]))}, ->t23193 {:protocol-inline nil, :meta {:anonymous true, :protocols #{quantum.core.reducers/CollFold cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([folder+ coll xf meta23194])), :file nil}, :protocols #{quantum.core.reducers/CollFold cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}, :name quantum.core.reducers/->t23193, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :method-params ([folder+ coll xf meta23194]), :protocol-impl nil, :arglists-meta (nil nil), :anonymous true, :column 8, :factory :positional, :line 552, :max-fixed-arity 4, :fn-var true, :arglists (quote ([folder+ coll xf meta23194])), :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}}, range+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 996, :column 7, :end-line 996, :end-column 13, :arglists (quote ([] [end] [start end] [start end step])), :doc "Returns a reducible collection of nums from start (inclusive) to end\n  (exclusive), by step, where start defaults to 0, step to 1, and end\n  to infinity.", :attribution "Alan Malloy - http://dev.clojure.org/jira/browse/CLJ-993", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([] [end] [start end] [start end step]), :arglists ([] [end] [start end] [start end step]), :arglists-meta (nil nil nil nil)}}, :name quantum.core.reducers/range+, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([] [end] [start end] [start end step]), :arglists ([] [end] [start end] [start end step]), :arglists-meta (nil nil nil nil)}, :method-params ([] [end] [start end] [start end step]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 996, :attribution "Alan Malloy - http://dev.clojure.org/jira/browse/CLJ-993", :end-line 996, :max-fixed-arity 3, :fn-var true, :arglists ([] [end] [start end] [start end step]), :doc "Returns a reducible collection of nums from start (inclusive) to end\n  (exclusive), by step, where start defaults to 0, step to 1, and end\n  to infinity."}, iterate* {:protocol-inline nil, :meta {:private true, :performance "Untested", :file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :end-column 31, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f seed]), :arglists ([f] [f seed]), :arglists-meta (nil nil)}, :column 23, :line 934, :attribution "Alan Malloy - http://dev.clojure.org/jira/browse/CLJ-993", :end-line 934, :arglists (quote ([f] [f seed])), :doc "A reducible collection of [seed, (f seed), (f (f seed)), ...]"}, :private true, :performance "Untested", :name quantum.core.reducers/iterate*, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 31, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f seed]), :arglists ([f] [f seed]), :arglists-meta (nil nil)}, :method-params ([f] [f seed]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 934, :attribution "Alan Malloy - http://dev.clojure.org/jira/browse/CLJ-993", :end-line 934, :max-fixed-arity 2, :fn-var true, :arglists ([f] [f seed]), :doc "A reducible collection of [seed, (f seed), (f (f seed)), ...]"}, reduce+ {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/quantum/src/cljc/quantum/core/reducers.cljc", :line 287, :column 4, :end-line 287, :end-column 11, :protocol quantum.core.reducers/Reduce+, :doc nil, :arglists (quote ([coll f] [coll f init])), :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll f] [coll f init]), :arglists ([coll f] [coll f init]), :arglists-meta (nil nil)}}, :protocol quantum.core.reducers/Reduce+, :name quantum.core.reducers/reduce+, :variadic false, :file "src/cljc/quantum/core/reducers.cljc", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll f] [coll f init]), :arglists ([coll f] [coll f init]), :arglists-meta (nil nil)}, :method-params ([coll f] [coll f init]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 280, :end-line 287, :max-fixed-arity 3, :fn-var true, :arglists ([coll f] [coll f init]), :doc nil}, t23193 {:num-fields 4, :protocols #{quantum.core.reducers/CollFold cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}, :name quantum.core.reducers/t23193, :file "src/cljc/quantum/core/reducers.cljc", :type true, :anonymous true, :column 8, :line 552, :record false, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta cljs.core/IReduce}}}, :require-macros {fn quantum.core.function, quantum.core.function quantum.core.function, log quantum.core.logic, quantum.core.logic quantum.core.logic, macros quantum.core.macros, quantum.core.macros quantum.core.macros, type quantum.core.type, quantum.core.type quantum.core.type}, :cljs.analyzer/constants {:seen #{:else :coll :-reduce}, :order [:-reduce :else :coll]}, :doc "A library for reduction and parallel folding. Alpha and subject\n      to change.  Note that fold and its derivatives require Java 7+ or\n      Java 6 + jsr166y.jar for fork/join support.\n\n      Adds some interesting reducers and folders from different sources\n      gleaned from the far reaches of the internet. Some of them have\n      unexpectedly great performance.\n\n      Also adds a delay at every stage of reducer/folder-transformation.\n      That seemed important at one point, but maybe it isn't actually."}