(def ^:private ^long bits [] nil)
(def ^:private ^int length nil)
(def ^:private ^BitSieve smallSieve (BitSieve.))
(defn
  ^:private
  ^:constructor
  BitSieve
  "/*\n\nConstruct a \"small sieve\" with a base of 0.  This constructor is\nused internally to generate the set of \"small primes\" whose multiples\nare excluded from sieves generated by the main (package private)\nconstructor, BitSieve(BigInteger base, int searchLen).  The length\nof the sieve generated by this constructor was chosen for performance;\nit controls a tradeoff between how much time is spent constructing\nother sieves, and how much time is wasted testing composite candidates\nfor primality.  The length was chosen experimentally to yield good\nperformance.\n     */\n"
  []
  (set! length (* 150 64))
  (set!
   bits
   ["ARRAY" nil (array 0) ((+ (unitIndex (- length 1)) 1)) nil])
  (set 0)
  (let [^int nextIndex 1])
  (let [^int nextPrime 3])
  (loop
   []
    (sieveSingle length (+ nextIndex nextPrime) nextPrime)
    (set! nextIndex (sieveSearch length (+ nextIndex 1)))
    (set! nextPrime (+ (* 2 nextIndex) 1))
    (when (and (> nextIndex 0) (< nextPrime length)) (recur))))
(defn
  ^:constructor
  BitSieve
  "/*\n\nConstruct a bit sieve of searchLen bits used for finding prime number\ncandidates. The new sieve begins at the specified base, which must\nbe even.\n     */\n"
  [^BigInteger base ^int searchLen]
  (set!
   bits
   ["ARRAY" nil (array 0) ((+ (unitIndex (- searchLen 1)) 1)) nil])
  (set! length searchLen)
  (let [^int start 0])
  (let
   [^int step (.sieveSearch smallSieve (.length smallSieve) start)])
  (let [^int convertedStep (+ (* step 2) 1)])
  (let [^MutableBigInteger b (MutableBigInteger. base)])
  (let [^MutableBigInteger q (MutableBigInteger.)])
  (loop
   []
    (set! start (.divideOneWord b convertedStep q))
    (set! start (- convertedStep start))
    (when (= (rem start 2) 0) (swap! start + convertedStep))
    (sieveSingle searchLen (/ (- start 1) 2) convertedStep)
    (set!
     step
     (.sieveSearch smallSieve (.length smallSieve) (+ step 1)))
    (set! convertedStep (+ (* step 2) 1))
    (when (> step 0) (recur))))
(defn
  ^:private
  unitIndex
  "/*\n\nGiven a bit index return unit index containing it.\n     */\n"
  [^int bitIndex]
  (>>> bitIndex 6))
(defn
  ^:private
  bit
  "/*\n\nReturn a unit that masks the specified bit in its unit.\n     */\n"
  [^int bitIndex]
  (<< (long 1) (& bitIndex (- (<< 1 6) 1))))
(defn
  ^:private
  get
  "/*\n\nGet the value of the bit at the specified index.\n     */\n"
  [^int bitIndex]
  (let [^int unitIndex (unitIndex bitIndex)])
  (not= (& (aget bits unitIndex) (bit bitIndex)) 0))
(defn
  ^:private
  set
  "/*\n\nSet the bit at the specified index.\n     */\n"
  [^int bitIndex]
  (let [^int unitIndex (unitIndex bitIndex)])
  (swap! (aget bits unitIndex) | (bit bitIndex)))
(defn
  ^:private
  sieveSearch
  "/*\n\nThis method returns the index of the first clear bit in the search\narray that occurs at or after start. It will not search past the\nspecified limit. It returns -1 if there is no such clear bit.\n     */\n"
  [^int limit ^int start]
  (when (>= start limit) (return -1))
  (let [^int index start])
  (loop
   []
    (when (not (get index)) (return index))
    (inc! index)
    (when (< index (- limit 1)) (recur)))
  -1)
(defn
  ^:private
  sieveSingle
  "/*\n\nSieve a single set of multiples out of the sieve. Begin to remove\nmultiples of the specified step starting at the specified start index,\nup to the specified limit.\n     */\n"
  [^int limit ^int start ^int step]
  (while (< start limit) (set start) (swap! start + step)))
(defn
  retrieve
  "/*\n\nTest probable primes in the sieve and return successful candidates.\n     */\n"
  [^BigInteger initValue ^int certainty ^java.util.Random random]
  (let [^int offset 1])
  (ifor
   [(let [^int i 0])]
   (< i (.length bits))
   (inc! i)
   (let [^long nextLong (bit-not (aget bits i))])
   (ifor
    [(let [^int j 0])]
    (< j 64)
    (inc! j)
    (when
     (= (& nextLong 1) 1)
      (do
        (let
         [^BigInteger
          candidate
          (.add initValue (.valueOf BigInteger offset))])
        (when
         (.primeToCertainty candidate certainty random)
          (return candidate))))
    (swap! nextLong >>> 1)
    (swap! offset + 2)))
  nil)
